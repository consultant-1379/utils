#!/bin/bash
# ********************************************************************
# Ericsson Radio Systems AB									 SCRIPT
# ********************************************************************
#
# (c) Ericsson Radio Systems AB 2019 - All rights reserved.
#
# The copyright to the computer program(s) herein is the property
# of Ericsson Radio Systems AB, Sweden. The programs may be used
# and/or copied only with the written permission from Ericsson Radio
# Systems AB or in accordance with the terms and conditions stipulated
# in the agreement/contract under which the program(s) have been
# supplied.
#
# ********************************************************************
# Name	: eniq_core_install.bsh
# Date	: 20/05/2019
# Revision: \main\Statistics_19.2_EU\05
# Purpose : Main wrapper script handling the installation ENIQ. It will
#		   call all necessary scripts to complete the installation
#
# Usage   : eniq_core_install.bsh
#
# ********************************************************************
#
#   Command Section
#
# ********************************************************************
AWK=/usr/bin/awk
BASENAME=/usr/bin/basename
BASH=/usr/bin/bash
BC=/usr/bin/bc
CAT=/usr/bin/cat
CHMOD=/usr/bin/chmod
CHOWN=/usr/bin/chown
CP=/usr/bin/cp
CPIO=/usr/bin/cpio
DATE=/usr/bin/date
DIRNAME=/usr/bin/dirname
DMIDECODE=/usr/sbin/dmidecode
DRACUT=/usr/sbin/dracut
ECHO='/usr/bin/echo -e'
EGREP=/usr/bin/egrep
EXPR=/usr/bin/expr
FIND=/usr/bin/find
GETENT=/usr/bin/getent
GREP=/usr/bin/grep
GROUPADD=/usr/sbin/groupadd
GTAR=/usr/bin/gtar
GZIP=/usr/bin/gzip
HEAD=/usr/bin/head
MKFS_EXT4=/usr/sbin/mkfs.ext4
MYHOSTNAME=/usr/bin/hostname
ID=/usr/bin/id
IFCONFIG=/usr/sbin/ifconfig
KILL=/usr/bin/kill
LN=/usr/bin/ln
LS=/usr/bin/ls
LSSCSI=/usr/bin/lsscsi
MKDIR=/usr/bin/mkdir
MKSWAP=/usr/sbin/mkswap
MOUNT=/usr/bin/mount
MULTIPATH=/usr/sbin/multipath
MV=/usr/bin/mv
NETSTAT=/usr/bin/netstat
NMCLI=/usr/bin/nmcli
LSBLK=/usr/bin/lsblk
LVCREATE=/usr/sbin/lvcreate
LVREMOVE=/usr/sbin/lvremove
LVS=/usr/sbin/lvs
PARTED=/usr/sbin/parted
PERL=/usr/bin/perl
PING=/usr/bin/ping
PRINTF=/usr/bin/printf
PS=/usr/bin/ps
PVS=/usr/sbin/pvs
PWD=/usr/bin/pwd
PYTHON=/usr/bin/python
PVCREATE=/usr/sbin/pvcreate
RAW=/usr/bin/raw
REBOOT=/usr/sbin/reboot
RM=/usr/bin/rm
SED=/usr/bin/sed
SETFACL=/usr/bin/setfacl
SLEEP=/usr/bin/sleep
SORT=/usr/bin/sort
SSH=/usr/bin/ssh
SU=/usr/bin/su
SWAP=/usr/sbin/swap
SWAPOFF=/usr/sbin/swapoff
SWAPON=/usr/sbin/swapon
SYSTEMCTL=/usr/bin/systemctl
SYSTEMD_ANALYZE=/usr/bin/systemd-analyze
TAIL=/usr/bin/tail
TAR=/usr/bin/tar
TEE=/usr/bin/tee
TOUCH=/usr/bin/touch
UDEVADM=/usr/sbin/udevadm
UMOUNT=/usr/bin/umount
UNAME=/usr/bin/uname
UNZIP=/usr/bin/unzip
USERADD=/usr/sbin/useradd
VGDISPLAY=/usr/sbin/vgdisplay
VGS=/usr/sbin/vgs
VGCREATE=/usr/sbin/vgcreate
VGIMPORT=/usr/sbin/vgimport
VGREMOVE=/usr/sbin/vgremove
WC=/usr/bin/wc
XARGS=/usr/bin/xargs
# ********************************************************************
#
#	   Configuration Section
#
# ********************************************************************

# Default user
DEFAULT_USER=root

# Default cache dir location
DEF_CACHE_DIR="/var/tmp/OM_CACHE"

# DVD LABEL or Jumpstart Directory where all ENIQ SW will reside
ENIQ_BASE_SW=eniq_base_sw

# File used to identify correct DVD
ENIQ_BASE_SW_FILE_ID=".eniq_base_sw"

# Cmd to exec a shell and drop user to it in case of an error
EXEC_SHELL_CMD="exec /bin/bash -o emacs"

# Name of SunOS & ENIQ ini Files
BLK_STOR_INI=block_storage.ini
ENIQ_ENV=niq.rc
ENIQ_INI=niq.ini
SYM_INI=sym_links.ini
IPMP_INI=ipmp.ini
LUN_MAP_INI=lun_map.ini
RBAC_INI=RBAC.ini
SUNOS_INI=SunOS.ini
SENTINEL_INI=sentinel.ini
STORAGE_INI=storage.ini
TP_INI=input_parameters.ini
ECS_INI=ecs.ini
COORD_SYM_INI=coordinator_sym_links.ini
CEP_MED_INI=cep_mediation.ini

# Max size for FS swap partition in Mbytes
MAX_16G_SWAP=16
MAX_8G_SWAP=8

ENIQ_STOP_SERVICES="scheduler engine webserver repdb dwhdb licmgr rmiregistry connectd"
ENIQ_START_SERVICES="connectd rmiregistry licmgr repdb dwhdb engine scheduler webserver"

# Variables used in ENIQ version
ENIQ_VERSION_DIR="version"
ENIQ_STATUS="eniq_status"


# List of service names to be updated after platform install
COMMON_PLATFORM_SERVICE_NAME_LIST="webserver engine lwphelper fls licenceservice scheduler"
SON_PLATFORM_SERVICE_NAME_LIST="${COMMON_PLATFORM_SERVICE_NAME_LIST} glassfish"
EVENTS_PLATFORM_SERVICE_NAME_LIST="${COMMON_PLATFORM_SERVICE_NAME_LIST} controlzone glassfish"
ES_SERVICE_NAME_LIST="controlzone"
STATS_PLATFORM_SERVICE_NAME_LIST="${COMMON_PLATFORM_SERVICE_NAME_LIST}"

SMF_ID_COMMON_STR="svc:/eniq"

ENIQ_SVC_UNIT_LOC="/etc/systemd/system"

ENIQ_SENTINEL_ENV="/eniq/sentinel/etc/sentinel.env"

ENIQ_SENTINEL_BIN_DIR="/eniq/sentinel/bin"

NAMED_CACHE_SMF_ID="svc:/system/name-service-cache"

# Location of WTMPX LOG File
WTMPX_LOG_LOC=/var/adm/wtmpx

#Location of nasplugin.conf file
_NAS_PLUGINS_LOC=/ericsson/storage/plugins/filestore/etc

# Location of interface directory
INTF_DIR="/etc/sysconfig/network-scripts"

# ********************************************************************
#
#	   Pre-execution Operations
#
# ********************************************************************
x86_64=`$UNAME -p|grep -w x86_64`

if [ -e "/etc/zoned" ]; then
	export ZONE=yes
fi

#This is for changing zfs pool name, in this scripts and also in other files
_zfs_pool_change_=0
if [[ "$ZONE" == "yes" && "${_zfs_pool_change_}" -eq 0 ]]; then
	_eniq_installation_cfg_dir_=/eniq/installation/
	for _file_ in $($FIND $_eniq_installation_cfg_dir_ -exec $GREP -l "eniq_sp_1" '{}' \; -print); do
		$SED -e "s/eniq_sp_1/${HNAME}/g" ${_file_} > /tmp/tempfile.tmp
		$CAT /tmp/tempfile.tmp > ${_file_}
		$RM /tmp/tempfile.tmp >> /dev/null 2>&1
	done

	$SED -e "s/"_zfs_pool_change_=0"/"_zfs_pool_change_=1"/g" $0 > /tmp/tempfile.tmp
	$CAT /tmp/tempfile.tmp > $0
	$RM /tmp/tempfile.tmp >> /dev/null 2>&1
	exec $0
	exit 0
fi

# ********************************************************************
#
#   Functions
#
# ********************************************************************
### Function: abort_script ###
#
#   This will is called if the script is aborted thru an error
#   signal sent by the kernel such as CTRL-C or if a serious
#   error is encountered during runtime
#
# Arguments:
#	   $1 - Error message from part of program (Not always used)
# Return Values:
#	   none
abort_script()
{
_err_time_=`$DATE '+%Y-%b-%d_%H.%M.%S'`

if [ "$1" ]; then
	_err_msg_="${_err_time_} - $1"
else
	_err_msg_="${_err_time_} - ERROR : Script aborted.......\n"
fi

if [ "${LOGFILE}" ]; then
	$ECHO -e "\nERROR : ${_err_msg_}\n" | $TEE -a ${LOGFILE}
else
	$ECHO -e "\nERROR : ${_err_msg_}\n"
fi

cd $SCRIPTHOME
$RM -rf ${TEM_DIR}

if [ "$2" ]; then
	if [ ! "${UPGRADE}" -a ! "${RESTORE}" -a ! "${MIGRATION}" ]; then
		${2}
	fi
	exit 1
else
   exit 1
fi
}

### Function: add_extra_packages ###
#
# Add required additional solaris packages
#
# Arguments:
#   none
# Return Values:
#   none
add_extra_packages()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Stage should be called in Solaris version higher than 5.10
if [ "${SOLARIS_10}" ]; then
	log_msg -s "Additional packages installation not required in OS version ${OS_VERSION}." -l ${LOGFILE}
	insert_header_footer foot "Skipping core install stage - ${NEXT_STAGE}" ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

_sol_pkg_list_="ucb database-512"

for _pkg_ in ${_sol_pkg_list_}; do

	# Check if the package string is valid
	$PKG list -avH $_pkg_ 2>&1
	if [ $? -eq 0 ]; then
		$PKG list -avH $_pkg_ > ${TEM_DIR}/pkg_details
		while read _each_ ; do
			# Get the package details
			_pkg_status_=`$ECHO ${_each_} | $AWK '{print $2}' | $CUT -f1 -d-`
			_pkg_name_=`$ECHO ${_each_} | $AWK -F"@" '{print $1}'`

			# Check if package is installed
			if [ "${_pkg_status_}" != "i" ]; then
				# Install the package
				log_msg -s "Installing package ${_pkg_name_}" -l ${LOGFILE}
				$PKG install ${_pkg_name_} >> ${LOGFILE}
				if [ $? -ne 0 ];then
					_err_msg_="Failed to add package $_pkg_name_"
					abort_script $_err_msg_
				else
					log_msg -s "Package $_pkg_name_ installed successfully." -l ${LOGFILE}
				fi
			else
				log_msg -s "Package $_pkg_name_ already installed." -l ${LOGFILE}
			fi
		done < ${TEM_DIR}/pkg_details
	else
		_err_msg_="Package string \"$_pkg_\" is invalid."
		abort_script $_err_msg_
	fi
	$RM -rf ${TEM_DIR}/pkg_details
done

insert_header_footer foot "Successfully added required Solaris packages" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: add_alias_details_to_service_names ###
#
# Add the NAS alias info to service_names
#
# Arguments:
#   none
# Return Values:
#   none
add_alias_details_to_service_names()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

if [ ! "$ZONE" ]; then
		# Need to stop hostsync so that we can start it fine at the end of this stage
		_hostsync_smf_str_=`iniget HOST_SYNC_DAEMON -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v HOST_SYNC_SERVICE_STR`
		if [ ! "${_hostsync_smf_str_}" ]; then
			_err_msg_="Could not read host_syncd SMF string from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		log_msg -s "Stopping ${_hostsync_smf_str_}" -l ${LOGFILE}
		$SYSTEMCTL stop ${_hostsync_smf_str_}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not stop ${_hostsync_smf_str_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
		
		log_msg -s "Disabling ${_hostsync_smf_str_}" -l ${LOGFILE}
		$SYSTEMCTL disable ${_hostsync_smf_str_}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not disable ${_hostsync_smf_str_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
fi

_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file - ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysgrp_=`$ID ${_sysuser_} | $AWK '{print $2}' | $AWK -F\( '{print $2}' | $AWK -F\) '{print $1}'`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not determine group ID of ${_sysuser_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Check if the alias info is in service_names

$CAT /etc/hosts | $EGREP "nas[0-9]|nasconsole|eniq_oss_[0-9]|eniq_events_[0-9]|events_oss_[0-9]" | $EGREP -v "#" > ${TEM_DIR}/nas_details.$$

$CP /etc/hosts /etc/hosts.nas_backup
if [ $? -ne 0 ]; then
	_err_msg_="Could not make a backup of /etc/hosts"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$CAT /etc/hosts | $EGREP -v "nas[0-9]|nasconsole|eniq_oss_[0-9]|eniq_events_[0-9]|events_oss_[0-9]" > ${TEM_DIR}/hosts_nas_details_removed
if [ $? -ne 0 ]; then
	_err_msg_="Could not make a backup of /etc/inet/hosts"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$CP ${TEM_DIR}/hosts_nas_details_removed /etc/hosts
if [ $? -ne 0 ]; then
	_err_msg_="Could not make a backup of /etc/hosts"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ "${SERVER_TYPE}" == "CO" ]; then
	# Update service_names file
	while read _line_; do
		_nas_alias_vip_=`$ECHO ${_line_} | $AWK '{print $1}'`
		_nas_alias_name_=`$ECHO ${_line_} | $AWK '{print $2}'`

		log_msg -s "Adding ${_nas_alias_name_} to ${CLI_CONF_DIR}/service_names" -l $LOGFILE
		update_service_file ${CLI_CONF_DIR}/service_names ${_nas_alias_vip_} ${_nas_alias_name_} ${_nas_alias_name_} "NULL_GRP" "NO_RESTART"
		if [ $? -ne 0 ]; then
			_err_msg_="Failed to update ${CLI_CONF_DIR}/service_names with ${_nas_alias_name_} details"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	done < ${TEM_DIR}/nas_details.$$

	log_msg -s "Changing ownership of ${CLI_CONF_DIR}/service_names to ${_sysuser_}:${_sysgrp_} after NAS alias changes" -l ${LOGFILE}
	$CHOWN ${_sysuser_}:${_sysgrp_} ${CLI_CONF_DIR}/service_names
	if [ $? -ne 0 ]; then
		_err_msg_="Failed to change ownership of ${CLI_CONF_DIR}/service_names to ${_sysuser_}:${_sysgrp_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

fi

if [ ! "$ZONE" ]; then
		# Need to start hostsync to get the alias info back
		_hostsync_smf_str_=`iniget HOST_SYNC_DAEMON -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v HOST_SYNC_SERVICE_STR`
		if [ ! "${_hostsync_smf_str_}" ]; then
			_err_msg_="Could not read host_syncd SMF string from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		log_msg -s "Starting ${_hostsync_smf_str_}" -l ${LOGFILE}
		$SYSTEMCTL start  ${_hostsync_smf_str_}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not start ${_hostsync_smf_str_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
		
		log_msg -s "Enabling ${_hostsync_smf_str_}" -l ${LOGFILE}
		$SYSTEMCTL enable  ${_hostsync_smf_str_}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not enable ${_hostsync_smf_str_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
fi

$SLEEP 30

insert_header_footer foot "Successfully updated NAS alias information in /etc/hosts" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: add_platform_services ###
#
#   Add the platform services info to service_names 
#
# Arguments:
#	   none 
# Return Values:
#	   none
add_platform_services()
{
if [ ! "${UPGRADE}" ]; then
	 _engine_host_ip_address_=${HOST_IP}
	 _engine_host_name_=${HNAME}
else
	 _engine_host_ip_address_=`$CAT ${CLI_CONF_DIR}/service_names|$GREP -iw engine|$AWK -F:: '{print $1}'`
	 _engine_host_name_=`$CAT ${CLI_CONF_DIR}/service_names|$GREP -iw engine|$AWK -F:: '{print $2}'`
	 _platform_service_list_="engine,lwphelper,fls"
fi

$ECHO "" >> ${LOGFILE}
# Update the service_names file with the required services
$ECHO "Adding platform service names to ${CLI_CONF_DIR}/service_names" >> ${LOGFILE}
update_service_file ${CLI_CONF_DIR}/service_names ${_engine_host_ip_address_} ${_engine_host_name_} ${_platform_service_list_} "NULL_GRP"
if [ $? -ne 0 ]; then
	 _err_msg_="Failed to update ${CLI_CONF_DIR}/service_names with platform services"
	 abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$ECHO "Changing ownership of ${CLI_CONF_DIR}/service_names to ${_sysuser_}:${_sysgrp_} after updates for platform" >> ${LOGFILE}
$CHOWN ${_sysuser_}:${_sysgrp_} ${CLI_CONF_DIR}/service_names
if [ $? -ne 0 ]; then
	 _err_msg_="Failed to change ownership of ${CLI_CONF_DIR}/service_names to ${_sysuser_}:${_sysgrp_}"
	 abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
}

### Function: activate_ENIQ_features ###
#
# Call script to activate Tech Packs
#
# Arguments:
#   none
# Return Values:
#   none
activate_ENIQ_features()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

if [ -f ${ENIQ_CONF_DIR}/no_feature -a "${INSTALL_TYPE}" == "stats" ]; then
	insert_header_footer foot "No Initial feature found, No need to activate." ${LOGFILE}
else
	# Set the SW_DIR variable
	get_feature_dir
	if [ "${INSTALL_TYPE}" == "events" ]; then
		FEAT_SW_DIR=${SW_DIR}
		get_sw_dir
	fi

	if [ ! -s ${ENIQ_ADMIN_BIN_DIR}/manage_eniq_services.bsh ]; then
		_err_msg_="Failed to locate ENIQ Service Manager script - ${ENIQ_ADMIN_BIN_DIR}/manage_eniq_services.bsh"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	if [ ! -s ${ENIQ_ADMIN_BIN_DIR}/manage_features.bsh ]; then
		_err_msg_="Failed to locate ENIQ TechPack installer script - ${ENIQ_ADMIN_BIN_DIR}/manage_features.bsh"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
 
	# Get Directory where the list of managed features will be stored
	_feature_list_dir_=`iniget FEATURE_INFO -f ${ENIQ_CONF_DIR}/${ENIQ_INI} -v Feature_Interface_Dir`
	if [ ! "${_feature_list_dir_}" ]; then
		_err_msg_="Failed to read Parameter Feature_Interface_Dir from ${ENIQ_CONF_DIR}/${ENIQ_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	# Does the directory exist
	if [ ! -d "${_feature_list_dir_}" ]; then
		_err_msg_="Directory ${_feature_list_dir_} does not exist"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	# Get the System User.
	_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
	if [ ! "${_sysuser_}" ]; then
		_err_msg_="Could not read parameter ENIQ_SYSUSER from file - ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	_bin_dir_=`$CAT ${ENIQ_CONF_DIR}/${ENIQ_ENV} | $EGREP '^[[:blank:]]*BIN_DIR=' |$AWK -F\= '{print $2}'`
	if [ ! "${_bin_dir_}" ]; then
		_err_msg_="Could not read BIN_DIR parameter from ${ENIQ_CONF_DIR}/${ENIQ_ENV}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	# This is the OSS HNAME for first OSS
	OSS_REF_NAME="${OSS_REF_STR}1"

	# The interfaces file for this oss should be this path
	_eniq_oss_feat_list_=${_feature_list_dir_}/feature_info/${OSS_REF_NAME}/feature_install_list
	if [ ! -s ${_eniq_oss_feat_list_} ]; then
		_err_msg_="${_eniq_oss_feat_list_} not found or empty"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	# Start all the services. I will 'su' to the sysuser as SMF is not in control
	# at this stage
	$RM -f ${TEM_DIR}/service_list.$$
	for _srv_ in ${ENIQ_START_SERVICES}; do
		if [ ! -x ${_bin_dir_}/${_srv_} ]; then
			continue
		fi
		$ECHO "${_bin_dir_}/${_srv_} start" >> ${TEM_DIR}/service_list.$$
		$ECHO "if [ $? -ne 0 ]; then" >> ${TEM_DIR}/service_list.$$
		$ECHO "exit 1" >> ${TEM_DIR}/service_list.$$
		$ECHO "fi" >> ${TEM_DIR}/service_list.$$
	done

	$SU - ${_sysuser_} -c "/usr/bin/bash ${TEM_DIR}/service_list.$$"
	if [ $? -ne 0 ]; then
		abort_script "Exiting...." "${EXEC_SHELL_CMD}"
	fi

	# Run the feature manager script
	$ECHO "\nActivating features using command" >> ${LOGFILE}
	if [ "${INSTALL_TYPE}" == "events" ]; then
	   $ECHO "${ENIQ_ADMIN_BIN_DIR}/manage_features.bsh -d ${FEAT_SW_DIR} -m ${SW_DIR} -a activate -F ${_eniq_oss_feat_list_} -l ${LOGFILE} -I" >> ${LOGFILE}
	   ${BASH} ${ENIQ_ADMIN_BIN_DIR}/manage_features.bsh -d ${FEAT_SW_DIR} -m ${SW_DIR} -a activate -F ${_eniq_oss_feat_list_} -l ${LOGFILE} -I
	else
	   $ECHO "${ENIQ_ADMIN_BIN_DIR}/manage_features.bsh -d ${SW_DIR} -a activate -F ${_eniq_oss_feat_list_} -l ${LOGFILE} -I" >> ${LOGFILE}
	   ${BASH} ${ENIQ_ADMIN_BIN_DIR}/manage_features.bsh -d ${SW_DIR} -a activate -F ${_eniq_oss_feat_list_} -l ${LOGFILE} -I
	fi
	_res_code_=$?
	if [ ${_res_code_} -ne 0 ]; then
		_err_msg_="Failure trying to activate features (code: ${_res_code_})"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	insert_header_footer foot "Successfully activated feature interfaces" ${LOGFILE}
fi
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: add_nas_client_shares ###
#
# Add client for NAS share list
#
# Arguments:
#   none
# Return Values:
#   none
add_nas_client_shares()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type
if [ "${STORAGE_TYPE}" == "fs" ]; then
	insert_header_footer foot "FS Install - Skipping core install stage - ${NEXT_STAGE} " ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

if [ -s ${ENIQ_CONF_DIR}/extra_params/deployment ]; then
	_deployment_=`$CAT ${ENIQ_CONF_DIR}/extra_params/deployment`
else
	_err_msg_="Parameter \"deployment\" incorrectly specified, or is missing from boot command"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ -s ${ENIQ_CONF_DIR}/${SUNOS_INI} ]; then
	_ini_src_dir_=${ENIQ_CONF_DIR}
	_ini_file_=${SUNOS_INI}
else
	_ini_src_dir_=${ENIQ_TEMPL_DIR}
	_ini_file_="${SUNOS_INI}_${SAN_DEVICE}"
fi

_nas_sw_target_dir_=`iniget NAS_STORAGE_API -f ${_ini_src_dir_}/${_ini_file_} -v NAS_API_TARGET_DIR`
if [ ! "${_nas_sw_target_dir_}" ]; then
	_err_msg_="Failed to get NAS API target dir information from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Check required files and scripts exist
if [ ! -s ${_nas_sw_target_dir_}/bin/setup_ssh_FileStore.sh ]; then
	_err_msg_="File ${_nas_sw_target_dir_}/bin/setup_ssh_FileStore.sh not found"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ! -s ${ENIQ_CONF_DIR}/ssh_input_file ]; then
	_err_msg_="File ${ENIQ_CONF_DIR}/ssh_input_file not found"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_nas_sw_target_dir_=`iniget NAS_STORAGE_API -f ${_ini_src_dir_}/${_ini_file_} -v NAS_API_TARGET_DIR`
if [ ! "${_nas_sw_target_dir_}" ]; then
	_err_msg_="Failed to get NAS API target dir information from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_nascli_=${_nas_sw_target_dir_}/bin/nascli
if [ ! -s ${_nascli_} ]; then
	_err_msg_="${_nascli_} not found"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ! "${UPGRADE}" ]; then
	if [ "${CURR_SERVER_TYPE}" == "eniq_ui" -o "${CURR_SERVER_TYPE}" == "eniq_iqr" \
	-o "${CURR_SERVER_TYPE}" == "eniq_mz" -o "${CURR_SERVER_TYPE}" == "stats_engine" \
	-o "${CURR_SERVER_TYPE}" == "stats_iqr" -o "${CURR_SERVER_TYPE}" == "stats_iqw" ]; then

		# Set a variable for the NAS Pool from /eniq/installation/config/storage.ini
		_nas_sysid_=`iniget Storage_NAS_GENERAL -f ${ENIQ_CONF_DIR}/${STORAGE_INI} -v SYS_ID`
		if [ ! "${_nas_sysid_}" ]; then
			 _err_msg_="Could not get NAS sysid value from ${ENIQ_CONF_DIR}/${STORAGE_INI}"
			 abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

		# Checking if NFS are shared already through Co-ordinator
	log_msg -l ${LOGFILE} -s "Checking if NFS are shared over the subnet through Coordinator"
	${_nascli_} list_shares - ${_nas_sysid_} > ${TEM_DIR}/nascli_list_share_output
	if [ $? -ne 0 ]; then
			_err_msg_="Problem encountered while listing shares using ${_nascli_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		if [ -s ${TEM_DIR}/nascli_list_share_output ]; then
			 insert_header_footer foot "Successfully shared NFS over subnet through Coordinator" ${LOGFILE}
		 set_next_stage `$EXPR ${ARRAY_ELEM}+1` 
		 return 0
		else
			 _err_msg_="NAS File systems not shared over the subnet through Coordinator"
			 abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		if [ -s ${ENIQ_CONF_DIR}/${IPMP_INI} ]; then
			local _ipmp_ini_=${ENIQ_CONF_DIR}/${IPMP_INI}
		else
			_err_msg_="IPMP ini file missing "
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
		if [ "${_deployment_}" == "ft" ]; then
			# we only configure 1 vlan i.e. the oss services vlan
			$ECHO "deployment = ft"
			_intf_list_=`iniget IPMP -f ${_ipmp_ini_} | $HEAD -1`
			if [ ! "${_intf_list_}" ]; then
			$ECHO "Could not get list of IPMP interfaces"
				return 1
			fi
		else
			# we configure both services and storage vlans
			_intf_list_=`iniget IPMP -f ${_ipmp_ini_}`
			if [ ! "${_intf_list_}" ]; then
			$ECHO "Could not get list of IPMP interfaces"
				return 1
			fi
		fi

		for _intf_ in ${_intf_list_}; do
			_vlan_name_=`iniget ${_intf_} -f ${ENIQ_CONF_DIR}/${IPMP_INI} -v IPMP_Group_Name`
			if [ ! "${_vlan_name_}" ]; then
				_err_msg_="Could not read IPMP_Group_Name for ${_intf_} in ${ENIQ_CONF_DIR}/${IPMP_INI}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			if [ "${_vlan_name_}" != "stor_grp"  -a  "${_deployment_}" != "ft" ]; then
				continue
			else
				_intf_ip_=`iniget ${_intf_} -f ${ENIQ_CONF_DIR}/${IPMP_INI} -v IPMP_Group_IP`
				if [ ! "${_intf_ip_}" ]; then
					_err_msg_="Could not read IPMP_Group_IP value for ${_intf_} in ${ENIQ_CONF_DIR}/${IPMP_INI}"
					abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				fi

				$ECHO "Adding ${_intf_ip_} as a client of NAS" | $TEE -a ${LOGFILE}
				${_nascli_} add_client - ${_intf_ip_} - -
				if [ $? -ne 0 ]; then
					_err_msg_="Problem encountered adding ${_intf_ip_} as a client of NAS"
					abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				fi
			fi
		done
	fi
fi

insert_header_footer foot "Successfully setup ssh for NAS" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: allow_root_access ###
#
# Updates to allow root to telnet/ftp access
#
# Arguments:
#   none
# Return Values:
#   none
allow_root_access()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Allow root to telnet in

core_install_allow_root_telnet ${LOGFILE} ${TEM_DIR}
if [ $? -ne 0 ]; then
	_err_msg_="Could not allow telnet access for root"
  abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
systemctl enable telnet.socket
systemctl restart telnet.socket
# Allow root to ftp
core_install_allow_root_ftp ${LOGFILE} ${TEM_DIR}
if [ $? -ne 0 ]; then
	_err_msg_="Could not allow ftp access for root"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
systemctl enable vsftpd
systemctl start vsftpd
# Update roots profile
core_install_update_root_profile ${LOGFILE} ${TEM_DIR}
if [ $? -ne 0 ]; then
	_err_msg_="Could not update /.bash_profile file for root"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

setenforce permissive
if [ $? -ne 0 ]; then
	_err_msg_="Could not set to to permissive"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$GREP -w "SELINUX=enforcing" /etc/selinux/config >> /dev/null 2>&1
if [ $? -eq 0 ]; then
   $SED -i 's/SELINUX=enforcing/SELINUX=permissive/g' /etc/selinux/config >> /dev/null 2>&1
   if [ $? -ne 0 ]; then
	  _err_msg_="Could not set to to permissive in the file /etc/selinux/config "
	  abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
   fi
fi

insert_header_footer foot "Successfully completed core install stage - ${NEXT_STAGE}" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: build_ini_file ###
#
# Build the SunOS and niq ini files
#
# Arguments:
#   none
# Return Values:
#   none
build_ini_file()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Set the SW_DIR variable
get_sw_dir

# Read the storage type
read_storage_type

# Setup the NAS files for FS creation
if [ "${STORAGE_TYPE}" == "raw" ]; then
	if [ ! "${RESTORE}" ]; then
		manage_deployment_type
	fi
fi

# Set a variable for the correct inirator script to run
if [ "${INSTALL_TYPE}" == "stats" ]; then
	_inirator_script_="create_stats_ini.bsh"

fi

if [ ! -s $SCRIPTHOME/${_inirator_script_} ]; then
	_err_msg_="Could not locate file $SCRIPTHOME/${_inirator_script_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$ECHO "\nCalling inirator using the following command" >> ${LOGFILE}
if [ ! "${RESTORE}" ]; then
	$ECHO "/bin/bash $SCRIPTHOME/${_inirator_script_} -b ${ENIQ_BASE_DIR} -d $SW_DIR -t ${STORAGE_TYPE} -l ${LOGFILE}" >> ${LOGFILE}
	/bin/bash $SCRIPTHOME/${_inirator_script_} -b ${ENIQ_BASE_DIR} -d $SW_DIR -t ${STORAGE_TYPE} -l ${LOGFILE}
	_res_code_=$?
else
   $ECHO "/bin/bash $SCRIPTHOME/${_inirator_script_} -b ${ENIQ_BASE_DIR} -d $SW_DIR -t ${STORAGE_TYPE} -R -l ${LOGFILE}" >> ${LOGFILE}
	/bin/bash $SCRIPTHOME/${_inirator_script_} -b ${ENIQ_BASE_DIR} -d $SW_DIR -t ${STORAGE_TYPE} -R -l ${LOGFILE}
	_res_code_=$?
fi

if [ ${_res_code_} -eq 0 ]; then
	insert_header_footer foot "Successfully created ini files" ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
elif [ ${_res_code_} -eq 99 ]; then
	return 0
else
	_err_msg_="Error running script $SCRIPTHOME/${_inirator_script_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Do I need to add storage type to ${SUNOS_INI}
_chk_=`iniget STOR_TYPE -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v STORAGE_TYPE`
if [ ! "${_chk_}" ]; then
	if [ -s ${ENIQ_CONF_DIR}/san_details ]; then
	STORAGE_TYPE=`$CAT ${ENIQ_CONF_DIR}/san_details | $EGREP "^STORAGE_TYPE=" | $AWK -F\= '{print $2}'`
	else
	STORAGE_TYPE=fs
	fi

	iniset STOR_TYPE -f ${ENIQ_CONF_DIR}/${SUNOS_INI} STORAGE_TYPE="${STORAGE_TYPE}"
	if [ $? -ne 0 ]; then
	_err_msg_="Could not set STORAGE_TYPE to ${STORAGE_TYPE} in ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

if [ "${STORAGE_TYPE}" == "raw" ]; then
	# Do I need to add san device type to ${SUNOS_INI}
	_chk_=`iniget SAN_DEV -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v SAN_DEVICE`
	if [ ! "${_chk_}" ]; then
	SAN_DEVICE=`$CAT ${ENIQ_CONF_DIR}/san_details | $EGREP "^SAN_DEVICE=" | $AWK -F\= '{print $2}'`
	if [ ! "${SAN_DEVICE}" ]; then
			_err_msg_="Could not read SAN_DEVICE value from ${ENIQ_CONF_DIR}/san_details"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	iniset SAN_DEV -f ${ENIQ_CONF_DIR}/${SUNOS_INI} SAN_DEVICE="${SAN_DEVICE}"
	if [ $? -ne 0 ]; then
		_err_msg_="Could not set SAN_DEVICE to ${SAN_TYPE} in ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	fi
fi

}

### Function: change_mount_owners ###
#
# Change ownership of ALL mounts
#
# Arguments:
#   none
# Return Values:
#   none
change_mount_owners()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" == "fs" ]; then
	insert_header_footer foot "FS Install - Skipping core install stage - ${NEXT_STAGE} " ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

# Get the System User/Group. All directories are owned by this
_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file\n${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysgrp_=`$ID ${_sysuser_} | $AWK '{print $2}' | $AWK -F\( '{print $2}' | $AWK -F\) '{print $1}'`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not determine group ID of ${_sysuser_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_fs_list_=`iniget Storage_NAS_FS_LIST -f ${ENIQ_CONF_DIR}/${STORAGE_INI}`
if [ ! "${_fs_list_}" ]; then
	_err_msg_="Could not read NAS information from ${ENIQ_CONF_DIR}/${STORAGE_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

for _fs_ in ${_fs_list_}; do
	unset _dir_user_ _dir_group_
	_nas_alias_=`iniget ${_fs_} -f ${ENIQ_CONF_DIR}/${STORAGE_INI} -v NFS_HOST`
	if [ ! "${_nas_alias_}" ]; then
		_err_msg_="Could not get NAS ALIAS value for ${_fs_} in ${ENIQ_CONF_DIR}/${STORAGE_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	_nas_dir_=`iniget ${_fs_} -f ${ENIQ_CONF_DIR}/${STORAGE_INI} -v SHARE_PATH`
	if [ ! "${_nas_dir_}" ]; then
		_err_msg_="Could not get NAS DIR value for ${_fs_} in ${ENIQ_CONF_DIR}/${STORAGE_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	_mountpoint_=`iniget ${_fs_} -f ${ENIQ_CONF_DIR}/${STORAGE_INI} -v MOUNT_PATH`
	if [ ! "${_mountpoint_}" ]; then
		_err_msg_="Could not get MOUNT_PATH value for ${_fs_} in ${ENIQ_CONF_DIR}/${STORAGE_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	_dir_user_=`iniget ${_fs_} -f ${ENIQ_CONF_DIR}/${STORAGE_INI} -v OWNER`
	if [ "${_dir_user_}" ]; then
		_new_dir_user_="${_dir_user_}"
	else
		_new_dir_user_="${_sysuser_}"
	fi

	_dir_group_=`iniget ${_fs_} -f ${ENIQ_CONF_DIR}/${STORAGE_INI} -v GROUP`
	if [ "${_dir_group_}" ]; then
		_new_dir_group_="${_dir_group_}"
	else
		_new_dir_group_="${_sysgrp_}"
	fi

	$ECHO "Changing ownership of ${_mountpoint_} to ${_new_dir_user_}:${_new_dir_group_}" | $TEE -a ${LOGFILE}
		$CHOWN ${_new_dir_user_}:${_new_dir_group_} ${_mountpoint_} >> /dev/null 2>&1
		if [ $? -ne 0 ]; then
			_err_msg_="Could not change ownership of ${_mountpoint_} to ${_new_dir_user_}:${_new_dir_group_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

done

# Change ACLs for user dcdata
$ECHO -e "\nChanging ACLs for the FS filesystems" | $TEE -a ${LOGFILE}
_acl_fs_zfs_=`iniget SunOS_ZFS_FS -f ${ENIQ_CONF_DIR}/${SUNOS_INI}`
for _dir_ in ${_acl_fs_zfs_} ; do
	_mount_path_=`iniget ${_dir_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v mountpoint`
	if [ ! "${_mount_path_}" ]; then
		_err_msg_="Could not read ${_dir_}:mountpoint from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	$ECHO "Changing the ACL for ${_mount_path_}" >> ${LOGFILE}
	$SETFACL -m u:dcdata:--- ${_mount_path_}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not restrict dcdata to ${_mount_path_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
done

$ECHO -e "\nChanging ACLs for the all other directories" | $TEE -a ${LOGFILE}
_acl_fs_sunos_=`iniget SunOS_DIRECTORY -f ${ENIQ_CONF_DIR}/${SUNOS_INI}`
for _dir_ in ${_acl_fs_sunos_}; do
	unset _dir_owner_ _mount_path_
	_mount_path_=`iniget ${_dir_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v path`
	if [ ! "${_mount_path_}" ]; then
		_err_msg_="Could not read ${_dir_}:path from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	_dir_owner_=`iniget ${_dir_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v user`
	if [ "${_dir_owner_}" ]; then
		_owner_="${_dir_owner_}"
	else
		_owner_="${_sysuser_}"
	fi

	if [ "${_mount_path_}" != "/eniq/data" -a "${_owner_}" != "dcdata" -a "${_mount_path_}" != "/eniq/home" ]; then
		# If this a ZFS FileSys then GETFACL will not work and we will skip
		$GETFACL ${_mount_path_} >> /dev/null 2>&1
		if [ $? -eq 0 ]; then
			$ECHO "Changing the ACL for ${_mount_path_}" >> ${LOGFILE}
			$SETFACL -m u:dcdata:--- ${_mount_path_}
			if [ $? -ne 0 ]; then
				_err_msg_="$SETFACL -m u:dcdata:--- failed for ${_mount_path_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		fi
	fi
done

insert_header_footer foot "Successfully changed directory permissions" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: check_id ###
#
#   Check that the effective id of the user is correct
#   If not print error msg and exit.
#
# Arguments:
#	   $1 : User ID name
# Return Values:
#	   none
check_id()
{
_check_id_=`$ID | $AWK -F\( '{print $2}' | $AWK -F\) '{print $1}'`
if [ "$_check_id_" != "$1" ]; then
	_err_msg_="You must be $1 to execute this script."
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
}

### Function: cleanup ###
#
# Final stage. Clean up
#
# Arguments:
#   none
# Return Values:
#   none
cleanup()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Set the SW_DIR variable
get_sw_dir

if [ ! -s ${ENIQ_ADMIN_BIN_DIR}/manage_eniq_status.bsh ]; then
	_err_msg_="Failed to locate ENIQ Status script \n${ENIQ_ADMIN_BIN_DIR}/manage_eniq_status.bsh"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file\n${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysgrp_=`$ID ${_sysuser_} | $AWK '{print $2}' | $AWK -F\( '{print $2}' | $AWK -F\) '{print $1}'`
if [ ! "${_sysgrp_}" ]; then
	_err_msg_="Could not determine group ID of ${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Temporary fix to remove ec service names from hosts file. Its only here
# so MZ can install when an EC is to be run on a seperate blade
if [ ! "${UPGRADE}" ]; then
	if [ "${CURR_SERVER_TYPE}" == "eniq_coordinator" ]; then
		$RM -rf ${TEM_DIR}/service_names.$$

		$ECHO "Removing ec service names from ${CLI_CONF_DIR}/service_names file" >> ${LOGFILE}
		$CAT ${CLI_CONF_DIR}/service_names | $EGREP -v "ec_[0-9]*" > ${TEM_DIR}/service_names.$$
		if [ $? -ne 0 ]; then
			_err_msg_="Could not remove ec service names from ${CLI_CONF_DIR}/service_names file"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		$CP ${TEM_DIR}/service_names.$$ ${CLI_CONF_DIR}/service_names
		if [ $? -ne 0 ]; then
			_err_msg_="Could not copy ${TEM_DIR}/service_names.$$ to ${CLI_CONF_DIR}/service_names"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi
fi

# Update the service_names file with the engine service
if [ "${CURR_SERVER_TYPE}" == "stats_engine" ]; then
	engine_services="engine,lwphelper,fls"
	$ECHO "Updating ${_cli_conf_dir_}/service_names with engine information" >> ${LOGFILE}
	update_service_file ${CLI_CONF_DIR}/service_names ${HOST_IP} ${HNAME} ${engine_services} "NULL_GRP"
	if [ $? -ne 0 ]; then
		_err_msg_="Failed to update ${CLI_CONF_DIR}/service_names with ${engine_services} details"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	$ECHO "Changing ownership of ${CLI_CONF_DIR}/service_names to ${_sysuser_}:${_sysgrp_} after updates for ${engine_services}" >> ${LOGFILE}
	$CHOWN ${_sysuser_}:${_sysgrp_} ${CLI_CONF_DIR}/service_names
	if [ $? -ne 0 ]; then
		_err_msg_="Failed to change ownership of ${CLI_CONF_DIR}/service_names to ${_sysuser_}:${_sysgrp_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

$ECHO "Updating ${ENIQ_CONF_DIR}/service_names file" >> ${LOGFILE}
$CP ${CLI_CONF_DIR}/service_names ${ENIQ_CONF_DIR}/service_names
if [ $? -ne 0 ]; then
	_err_msg_="Could not copy ${CLI_CONF_DIR}/service_names to ${ENIQ_CONF_DIR}/service_names"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

#Update the rsyslog.conf file mail.debug value
$ECHO "Updating /etc/rsyslog.conf file" >> ${LOGFILE}
change_rsyslog  /etc/rsyslog.conf
if [ $? -ne 0 ]; then
	_err_msg="Could not change value of mail.debug in the /etc/rsyslog.conf file"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Remove ${ENIQ_CONF_DIR}/no_feature as installation completed
if [ -f ${ENIQ_CONF_DIR}/no_feature -a "${INSTALL_TYPE}" == "stats" ]; then
	$ECHO -e "\n--------------------------IMPORTANT INFORMATION---------------------------------\n" >> ${LOGFILE}
	$ECHO "This installation has been successfully completed. " >> ${LOGFILE}
	$ECHO "As per user selection no initial feature were installed. Only ENIQ base techpacks were installed." >> ${LOGFILE}
	$ECHO -e "\n--------------------------------------------------------------------------------\n" >> ${LOGFILE}
	rm -f ${ENIQ_CONF_DIR}/no_feature
	if [ $? -ne 0 ]; then
		_err_msg="Could not able to remove ${ENIQ_CONF_DIR}/no_feature file"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

if [ ! -s ${ENIQ_STATUS_FILE} ]; then
	$ECHO -e "\nUpdating status file using the following command" >> ${LOGFILE}
	$ECHO "${BASH} ${ENIQ_ADMIN_BIN_DIR}/manage_eniq_status.bsh -d ${SW_DIR} -l ${LOGFILE}" >> ${LOGFILE}
	${BASH} ${ENIQ_ADMIN_BIN_DIR}/manage_eniq_status.bsh -d ${SW_DIR} -l ${LOGFILE}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not create eniq_status or eniq_history files"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	_conf_msg_="Successfully updated ENIQ status file"
else
	_conf_msg_="Successfully completed ENIQ cleanup stage"
fi

insert_header_footer foot "${_conf_msg_}" ${LOGFILE}

if [ ! "${UPGRADE}" ]; then
# Handling for DBCC script.

	if [ "$INSTALL_TYPE" == "stats" ]; then
	_host_name_=`$CAT ${ENIQ_CONF_DIR}/service_names | $GREP dwh_reader_2 | $AWK -F"::" '{print $2}'`

		if [ "${_host_name_}" == ${HNAME} ]; then
			${TOUCH} /eniq/admin/etc/upgrade_II_dbcc_flag_indicator
		fi
	fi

	if [ "${CURR_SERVER_TYPE}" == "eniq_events" -o "${CURR_SERVER_TYPE}" == "eniq_stats" -o "${CURR_SERVER_TYPE}" == "eniq_mz" ]; then
		 ${TOUCH} /eniq/admin/etc/upgrade_II_dbcc_flag_indicator
	fi

	# Remove ${ENIQ_CORE_ETC_DIR}/features_to_be_managed as installation completed
	$RM -rf ${ENIQ_CORE_ETC_DIR}/features_to_be_managed

	$ECHO "ENIQ SW successfully installed" | $TEE -a ${LOGFILE}
fi
}

### Function: clear ###
#
# Clears the terminal screen
#
# Arguments:
#	   none
# Return Values:
#	   none
clear()
{
# Clearing the screen without removing scrollback buffer
$PRINTF '\33[H\33[2J'
}

### Function: common_get_ipmp_info ###
#
# Get the interface related information from user
#
# Arguments:
#   none
# Return Values:
#   none
common_get_ipmp_info()
{
	#to get the ip
	common_get_vlan_ipmp_ip "${_ipmp_group_name_}"
		_group_ip_=${IPMP_IPS}
		iniset ${_ipmp_det_} -f ${TEM_DIR}/${IPMP_INI} IPMP_Group_IP=${IPMP_IPS}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not update ${TEM_DIR}/${IPMP_INI} with IPMP_Group_IP=${IPMP_IPS} for ${_ipmp_det_}"
			abort_script "${_err_msg_}"
		fi
	#to get the netmask
	common_get_vlan_ipmp_netmask "${_ipmp_group_name_}"
		_ipv4_netmask_=${IPMP_NETMASKS}
		iniset ${_ipmp_det_} -f ${TEM_DIR}/${IPMP_INI} IPMP_Group_Netmask=${IPMP_NETMASKS}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not update ${TEM_DIR}/${IPMP_INI} with IPMP_Group_Netmask=${IPMP_NETMASKS} for ${_ipmp_det_}"
			abort_script "${_err_msg_}"
		fi
	#to get the gateway ip
	common_get_vlan_gateway "${_ipmp_group_name_}"
		_gateway_=${IPMP_GATEWAY}
		iniset ${_ipmp_det_} -f ${TEM_DIR}/${IPMP_INI} IPMP_Group_Gateway=${IPMP_GATEWAY}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not update ${TEM_DIR}/${IPMP_INI} with IPMP_Group_Gateway=${IPMP_GATEWAY} for ${_ipmp_det_}"
			abort_script "${_err_msg_}"
		fi
	#to get the arp-ip-target
	common_get_vlan_arp "${_ipmp_group_name_}"
		_arp_target_=${IPMP_ARP}
		iniset ${_ipmp_det_} -f ${TEM_DIR}/${IPMP_INI} ARP_IP_TARGET=${IPMP_ARP}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not update ${TEM_DIR}/${IPMP_INI} with ARP_IP_TARGET=${IPMP_ARP} for ${_ipmp_det_}"
			abort_script "${_err_msg_}"
		fi

	# Get the network address by Netmask & IP address
		if [ "${_ipmp_group_name_}" == "Storage Group" -o "${_ipmp_group_name_}" == "Backup Group" ]; then
			_net_=`get_network_addr "${IPMP_NETMASKS}" "${IPMP_IPS}"`
			_default_netmask_="${_net_}:${IPMP_NETMASKS}"
			_out_msg_="Enter the ${_ipmp_group_name_} VLAN network-number:netmask details"
			common_get_netmask_info "${_out_msg_}" "${_default_netmask_}"
			if [ ! "${NETMASK_INFO}" ]; then
				_err_msg_="Could not determine server network-number:netmask details"
				abort_script "${_err_msg_}"
			fi
			case "${_ipmp_group_name_}" in
				"Storage Group") _vlan_type_="STOR_NETMASK"
					;;
				"Backup Group") _vlan_type_="BKUP_NETMASK"
					;;
			esac

			iniset ${_vlan_type_} -f ${TEM_DIR}/${IPMP_INI} NETMASKS=${NETMASK_INFO}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not update ${TEM_DIR}/${IPMP_INI} with NETMASKS=${NETMASK_INFO}"
				abort_script "${_err_msg_}"
			fi
		fi

		#store all the user input details to temp ipmp file
		$ECHO "\nGroup name:\t${_ipmp_group_name_}" >> $TEM_DIR/ipmp_information
		$ECHO "${_ipmp_group_name_} IP:\t${_group_ip_}" >> $TEM_DIR/ipmp_information
		$ECHO "${_ipmp_group_name_} netmask:\t${_ipv4_netmask_}" >> $TEM_DIR/ipmp_information
		$ECHO "${_ipmp_group_name_} Gateway IP:\t${_gateway_}" >> $TEM_DIR/ipmp_information
		$ECHO "${_ipmp_group_name_} Highly available server IP:\t${_arp_target_}" >> $TEM_DIR/ipmp_information
		if [ "${_ipmp_group_name_}" == "Storage Group" -o "${_ipmp_group_name_}" == "Backup Group" ]; then
			$ECHO "${_ipmp_group_name_} network netmask:\t${NETMASK_INFO}" >> $TEM_DIR/ipmp_information
		fi
}

### Function: configure_ddc ###
#
# DDC related configuration
#
# Arguments:
#	   none
# Return Values:
#	   none
configure_ddc()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

local _sfs_ddc_collection_script_=manageSfsDataCollection.bsh
local _san_ddc_collection_script_=manageSanDataCollection.bsh

# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" == "fs" ];  then
	insert_header_footer foot "${STORAGE_TYPE} install - Skipping core install stage - ${NEXT_STAGE} " ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

if [ "${INSTALL_TYPE}" != "events" ] && [ "${INSTALL_TYPE}" != "stats" ]; then
	insert_header_footer foot "${INSTALL_TYPE} Install - Skipping core install stage - ${NEXT_STAGE} " ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

if [ "${CURR_SERVER_TYPE}" == "stats_coordinator" -o "${CURR_SERVER_TYPE}" == "eniq_coordinator" -o "${CURR_SERVER_TYPE}" == "eniq_events" -o "${CURR_SERVER_TYPE}" == "eniq_stats" ]; then

	#Configuration related to SFS diagnostic data collection.
	if [ -s ${ENIQ_ADMIN_BIN_DIR}/${_sfs_ddc_collection_script_} ] ; then
		log_msg -l ${LOGFILE} -q -s "Executing the command ${ENIQ_ADMIN_BIN_DIR}/${_sfs_ddc_collection_script_} -m enable -l ${LOGFILE}"
		$BASH ${ENIQ_ADMIN_BIN_DIR}/${_sfs_ddc_collection_script_} -m enable -l ${LOGFILE} >> ${LOGFILE}
		if [ $? -ne 0 ] ; then
			local _err_msg_="Failed to execute the script ${ENIQ_ADMIN_BIN_DIR}/${_sfs_ddc_collection_script_}."
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	else
		local _err_msg_="Unable to find the script ${ENIQ_ADMIN_BIN_DIR}/${_sfs_ddc_collection_script_}."
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	#Configuration related to SAN diagnostic data collection.
	if [ -s ${ENIQ_ADMIN_BIN_DIR}/${_san_ddc_collection_script_} ] ; then
		log_msg -l ${LOGFILE} -q -s "Executing the command ${ENIQ_ADMIN_BIN_DIR}/${_san_ddc_collection_script_} -m enable -l ${LOGFILE}"
		$BASH ${ENIQ_ADMIN_BIN_DIR}/${_san_ddc_collection_script_} -m enable -l ${LOGFILE} >> ${LOGFILE}
		if [ $? -ne 0 ] ; then
			local _err_msg_="Failed to execute the script ${ENIQ_ADMIN_BIN_DIR}/${_san_ddc_collection_script_}."
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	else
		local _err_msg_="Unable to find the script ${ENIQ_ADMIN_BIN_DIR}/${_san_ddc_collection_script_}."
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

insert_header_footer foot "Successfully executed the stage ${NEXT_STAGE}." ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: configure_opengeo ###
#
# Configure Template DB for postgis
#
# Arguments:
#	   none
# Return Values:
#	   none
configure_opengeo()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

if [ "${CURR_SERVER_TYPE}" == "eniq_ui" -o "${CURR_SERVER_TYPE}" == "eniq_events" -o "${CURR_SERVER_TYPE}" == "son_coordinator" ]; then
	log_msg -l ${LOGFILE} -q -s "Gathering Opengeo information from ${ENIQ_CONF_DIR}/${SUNOS_INI}"

	_tgt_dir_=`iniget OPENGEO -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v OPENGEO_TARGET_DIR`
	if [ ! "${_tgt_dir_}" ]; then
		_err_msg_="Could not read OPENGEO_TARGET_DIR param from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	_smf_uri_=`iniget OPENGEO -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v POSTGRES_SERVICE_STR`
	if [ ! "${_smf_uri_}" ]; then
		_err_msg_="Could not read POSTGRES_SERVICE_STR param from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	_og_user_=`iniget OPENGEO -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v POSTGRES_USER`
	if [ ! "${_og_user_}" ]; then
		_err_msg_="Could not read POSTGRES_USER param from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	_ogdb_templ_=`iniget OPENGEO -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v POSTGIS_DB`
	if [ ! "${_ogdb_templ_}" ]; then
		_err_msg_="Could not read POSTGIS_DB param from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	_smf_xml_=postgresql_og.xml
	_stor_typ_=`iniget STOR_TYPE -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v STORAGE_TYPE`

	# make sure last xml is copied over
	log_msg -l ${LOGFILE} -q -s "Copying ${ENIQ_TEMPL_DIR}/admin/${_stor_typ_}/${ENIQ_SMF_MANIFEST_LOC}/${_smf_xml_} to ${ENIQ_SMF_MANIFEST_LOC}/${_smf_xml_}"
	$CP ${ENIQ_TEMPL_DIR}/admin/${_stor_typ_}/${ENIQ_SMF_MANIFEST_LOC}/${_smf_xml_} ${ENIQ_SMF_MANIFEST_LOC}/${_smf_xml_}
	if [  $? -ne 0 ]; then
		_err_msg_="Could not copy ${ENIQ_TEMPL_DIR}/admin/${_stor_typ_}/${ENIQ_SMF_MANIFEST_LOC}/${_smf_xml_} to ${ENIQ_SMF_MANIFEST_LOC}/${_smf_xml_}" | $TEE -a $LOGFILE
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	# import/start service
	_start_opengeo_=`$CAT ${ENIQ_TEMPL_DIR}/admin/etc/smf_contract_config | $EGREP $CURR_SERVER_TYPE | $EGREP "postgresql_og" | $AWK -F"::" '{print $4}'`
	if [ "${_start_opengeo_}" == "Y" ]; then
		$SVCS -a | $GREP "${_smf_uri_}" >> /dev/null 2>&1
		if [ $? -ne 0 ]; then
			log_msg -l ${LOGFILE} -q -s "Importing opengeo postgres service ${_smf_xml_}"
			$SVCCFG import ${ENIQ_SMF_MANIFEST_LOC}/${_smf_xml_}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not import postgres service ${_smf_xml_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		fi

		# start service if not started
		if [ "`$SVCS -H -o sta ${_smf_uri_}`" != "ON" ]; then
			log_msg -l ${LOGFILE} -s "Starting opengeo postgres via SMF. Please wait..."
			$SVCADM enable -s ${_smf_uri_}

			# checking if the service comes online
			if [ "`$SVCS -H -o sta ${_smf_uri_}`" != "ON" ]; then
				_timeout_=30
				_time_now_=${SECONDS}
				_max_time_=$(( _time_now_ + _timeout_))
				_start_time_=$_time_now_

				# waiting for _timeout_ seconds if the service comes online
				while (( _time_now_ < _max_time_ )); do
					if [ "`$SVCS -H -o sta ${_smf_uri_}`" == "ON" ]; then
						_time_to_on_=$(( _time_now_ - _start_time_ ))
						log_msg -l ${LOGFILE} -q -s "Service enabled after $_time_to_on_ seconds."
						break
					fi
					_time_now_=${SECONDS}
				done
			fi

			if [ "`$SVCS -H -o sta ${_smf_uri_}`" != "ON" ]; then
				log_msg -l ${LOGFILE} -q -s "Current service state is: `$SVCS -H -o sta ${_smf_uri_}`"
				_err_msg_="Could not start Postgres"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			else
				log_msg -l ${LOGFILE} -s "Successfully started opengeo postgres via SMF."
			fi
		fi

		# configuration for template_postgis
		_postgis_sql_="${_tgt_dir_}/opengeo-8.4/share/contrib/postgis-1.5/postgis.sql"
		_spatial_sql_="${_tgt_dir_}/opengeo-8.4/share/contrib/postgis-1.5/spatial_ref_sys.sql"

		# is there template_postgis created ? only if not, will create it
		$SLEEP 5
		_current_pgdbs_=`$SU - ${_og_user_} -c "psql -l"`
		$ECHO ${_current_pgdbs_} | $GREP template_postgis > /dev/null
		if [ $? -ne 0 ]; then
			_templ_postg_=NO
		fi

		if [ "${_templ_postg_}" == "NO" ]; then
			log_msg -l ${LOGFILE} -q -s "Running the following commands to configure opengeo"
			log_msg -l ${LOGFILE} -q -s "$SU - ${_og_user_} -c \"createdb ${_ogdb_templ_}\""
			$SU - ${_og_user_} -c "createdb ${_ogdb_templ_}"
			if [ $? -ne 0 ]; then
				_err_msg_="Could not create ${_ogdb_templ_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			log_msg -l ${LOGFILE} -q -s "$SU - ${_og_user_} -c \"createlang plpgsql ${_ogdb_templ_}\""
			$SU - ${_og_user_} -c "createlang plpgsql ${_ogdb_templ_}"
			if [ $? -ne 0 ]; then
				_err_msg_="Failed running createlang ${_ogdb_templ_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			log_msg -l ${LOGFILE} -q -s "$SU - ${_og_user_} -c \"psql -f ${_postgis_sql_} ${_ogdb_templ_}\" >/dev/null"
			$SU - ${_og_user_} -c "psql -f ${_postgis_sql_} ${_ogdb_templ_}" >/dev/null
			if [ $? -ne 0 ]; then
				_err_msg_="Could not update ${_ogdb_templ_} from postgis.sql"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			log_msg -l ${LOGFILE} -q -s "$SU - ${_og_user_} -c \"psql -f ${_spatial_sql_} ${_ogdb_templ_}\" >/dev/null"
			$SU - ${_og_user_} -c "psql -f ${_spatial_sql_} ${_ogdb_templ_}" >/dev/null
			if [ $? -ne 0 ]; then
				_err_msg_="Could not update ${_ogdb_templ_} from spatial_ref_sys.sql"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		else
			log_msg -l ${LOGFILE} -s "postgis template already exists, no configuration required"
		fi

	insert_header_footer foot "Successfully configured opengeo" ${LOGFILE}

	fi
else
	insert_header_footer foot "${CURR_SERVER_TYPE} server install - skipping this stage" ${LOGFILE}
fi

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: configure_storage_api ###
#
# Configure storage API
#
# Arguments:
#	$1 : San type
# Return Values:
#	none
configure_storage_api()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" == "fs" ]; then
	insert_header_footer foot "FS Install - Skipping core install stage - ${NEXT_STAGE} " ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
else

	if [ ! "${SAN_DEVICE}" ]; then
		_err_msg_="Could not read SAN_DEVICE param while installing Storage API package"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	if [ -s ${ENIQ_CONF_DIR}/${SUNOS_INI} ]; then
		_ini_src_dir_=${ENIQ_CONF_DIR}
		_ini_file_=${SUNOS_INI}
	else
		_ini_src_dir_=${ENIQ_TEMPL_DIR}
		_ini_file_="${SUNOS_INI}_${SAN_DEVICE}"
	fi

	# Read location of storage API command
	_stor_api_cmd_=`iniget STOR_API -f ${_ini_src_dir_}/${_ini_file_} -v STOR_API_CMD`
	if [ ! "${_stor_api_cmd_}" ]; then
		_err_msg_="Could not read STOR_API_CMD param from ${_ini_src_dir_}/${_ini_file_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	if [ ! -x ${_stor_api_cmd_} ]; then
		_err_msg_="${_stor_api_cmd_} is not found or is not executable"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	if [ "${_san_device_}" != "local" ]; then
		configure_storage_api_san
		if [ $? -ne 0 ]; then
			_err_msg_=""
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	else
		printf '\33[H\33[2J'
		SAN_DEVICE="local"
		${_stor_api_cmd_} --action configure -plugin ${SAN_DEVICE}
		if [ $? -ne 0 ]; then
			_err_msg_=""
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi
	
	## Adding multipath module to initramfs before reboot
	$DRACUT --force --add multipath --include /etc/multipath
	if [ $? -ne 0 ]; then
		 _err_msg_="Failed to add multipath module to initramfs using DRACUT"
		 abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi


	insert_header_footer foot "Successfully configured storage API" ${LOGFILE}

	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	
	## Rebooting the server for configuring san storage api
	if [ ! "${UPGRADE}" -a ! "${RESTORE}" ]; then
		 $ECHO "Rebooting the server to configure san storage api" | $TEE -a ${LOGFILE}
		 $REBOOT
	fi

fi
}


### Function: configure_storage_api_san ###
#
# Configure storage API for the SAN
#
# Arguments:
#	$1 : San type
# Return Values:
#	none
configure_storage_api_san()
{
local _first_time_ _nxt_dev_cnt_

# Read the storage type
read_storage_type

if [ -s ${ENIQ_CONF_DIR}/${SUNOS_INI} ]; then
	_ini_src_dir_=${ENIQ_CONF_DIR}
	_ini_file_=${SUNOS_INI}
else
	_ini_src_dir_=${ENIQ_TEMPL_DIR}
	_ini_file_="${SUNOS_INI}_${SAN_DEVICE}"
fi

# Read location of storage API command
_stor_api_cmd_=`iniget STOR_API -f ${_ini_src_dir_}/${_ini_file_} -v STOR_API_CMD`
if [ ! "${_stor_api_cmd_}" ]; then
	_err_msg_="Could not read STOR_API_CMD param from ${_ini_src_dir_}/${_ini_file_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ! -x ${_stor_api_cmd_} ]; then
	_err_msg_="${_stor_api_cmd_} is not found or is not executable"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

while :; do
	clear
	# Read the name of the IP address of interface that the
	# Storage Agent will listen on
	get_san_agent_inter_ip

	$CP ${ENIQ_CONF_DIR}/${BLK_STOR_INI} ${TEM_DIR}/${BLK_STOR_INI}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy ${ENIQ_CONF_DIR}/${BLK_STOR_INI} to ${TEM_DIR}/${BLK_STOR_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	$RM -f ${TEM_DIR}/store_api_det_file
	$RM -f ${TEM_DIR}/store_confirm_file

	# gets the SAN details for each device
	get_SAN_details

	for (( _san_num_=1; _san_num_<=${SAN_NUM_SRVRS}; _san_num_++ )); do
		$RM -f ${TEM_DIR}/stor_dev_details ${TEM_DIR}/${BLK_STOR_INI}_temp

		# Read the name of the SAN Storage Device
		get_san_device_name ${_san_num_}

		# Read the username & password of the storeage administrator account
		get_san_device_user_pass ${_san_num_}

		# Read the SAN SPA & SPB IP Addresses
		get_san_sp_addr ${_san_num_}

		# Read the SAN Storage Group Name
		get_san_storage_group ${_san_num_}

		# Read the SAN LUN IDs for MainDB, sysMain, zpool and tempDB in comma separated format
		if [ "${SAN_DEVICE}" == "unity" ]; then
			get_san_storage_disks ${_san_num_}
		fi

		# Read the dev number
		_nxt_dev_cnt_=`$CAT ${TEM_DIR}/stor_dev_details| $HEAD -1 | $SED -e 's|\[||g' -e 's|\]||g' | $AWK -F\_ '{print $NF}'`
		${INIADD} -g BLK_STORAGE_DEV_DETAILS -p BLK_STORAGE_DEV_DETAILS_${_nxt_dev_cnt_} -i ${TEM_DIR}/${BLK_STOR_INI} -d ${TEM_DIR}/stor_dev_details -o ${TEM_DIR}/${BLK_STOR_INI}_temp
		if [ $? -ne 0 ]; then
			_err_msg_="Error adding BLK_STORAGE_DEV_DETAILS_${_nxt_dev_cnt_} to ${ENIQ_CONF_DIR}/${BLK_STOR_INI}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		$CP ${TEM_DIR}/${BLK_STOR_INI}_temp ${TEM_DIR}/${BLK_STOR_INI}
		if [ $? -ne 0 ]; then
			_err_msg_="Error appending ini BLK_STORAGE_DEV_DETAILS_${_nxt_dev_cnt_} details to ${ENIQ_CONF_DIR}/${BLK_STOR_INI}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		if [ "${SAN_DEVICE}" != "unity" ]; then
			if [ ! -s ${TEM_DIR}/store_api_det_file ]; then
				$ECHO "agentip=${SAN_AGENT_IP_ADDR}" > ${TEM_DIR}/store_api_det_file
			fi

			$ECHO "${SAN_DEVICE}=${SAN_DEV_NAME}:${SAN_STORAGE_USERNAME}:${SAN_STORAGE_PASS}:${SAN_STORAGE_SPA}:${SAN_STORAGE_SPB}:${SAN_STORAGE_GROUP_NAME}" >> ${TEM_DIR}/store_api_det_file
		else
			$ECHO "${SAN_DEVICE}=${SAN_STORAGE_USERNAME}:${SAN_STORAGE_PASS}:${SAN_STORAGE_SPA}:${SAN_STORAGE_DISKS}:${CONSISTENCY_GROUP_ID}" >> ${TEM_DIR}/store_api_det_file
		fi

		# create temp file to display SAN information for confirmation
		$ECHO "SAN ${_san_num_} Device type : ${SAN_DEVICE}" >> ${TEM_DIR}/store_confirm_file
		$ECHO "SAN ${_san_num_} Device name : ${SAN_DEV_NAME}" >> ${TEM_DIR}/store_confirm_file
		$ECHO "SAN ${_san_num_} Administrator username : ${SAN_STORAGE_USERNAME}" >> ${TEM_DIR}/store_confirm_file
		$ECHO "SAN ${_san_num_} Administrator password : ${SAN_STORAGE_PASS}" >> ${TEM_DIR}/store_confirm_file
		if [ "${SAN_DEVICE}" != "unity" ]; then
			$ECHO "SAN ${_san_num_} Storage processor (A) : ${SAN_STORAGE_SPA}" >> ${TEM_DIR}/store_confirm_file
			$ECHO "SAN ${_san_num_} Storage processor (B) : ${SAN_STORAGE_SPB}" >> ${TEM_DIR}/store_confirm_file
			$ECHO "SAN ${_san_num_} Storage group name : ${SAN_STORAGE_GROUP_NAME} \n " >> ${TEM_DIR}/store_confirm_file
		else
			$ECHO "SAN ${_san_num_} Storage processor : ${SAN_STORAGE_SPA}" >> ${TEM_DIR}/store_confirm_file
			$ECHO "SAN ${_san_num_} Consistency group id : ${CONSISTENCY_GROUP_ID}" >> ${TEM_DIR}/store_confirm_file
			$ECHO "SAN ${_san_num_} Storage Disks : ${SAN_STORAGE_DISKS} \n " >> ${TEM_DIR}/store_confirm_file
		fi
	done

	confirm_user_input

	if [ "${_ans_}" == "Yes" ]; then
		$CAT ${TEM_DIR}/store_confirm_file >> ${LOGFILE}
		break
	else
		continue
	fi
done

# Register the server with the SAN and see the Luns
${_stor_api_cmd_} --action configure -plugin ${SAN_DEVICE} --config ${TEM_DIR}/store_api_det_file
if [ $? -ne 0 ]; then
	_err_msg_=""
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Remove password from ini file
_blk_list_=`iniget BLK_STORAGE_DEV_DETAILS -f ${TEM_DIR}/${BLK_STOR_INI}`
if [ ! "${_blk_list_}" ]; then
	_err_msg_="Failed to get Block device list from ${TEM_DIR}/${BLK_STOR_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

for _blk_ in ${_blk_list_}; do
	iniset ${_blk_} -f ${TEM_DIR}/${BLK_STOR_INI} BLK_STORAGE_PASS="**********"
	if [ $? -ne 0 ]; then
		_err_msg_="Error adding BLK_STORAGE_INTERF_IP to ${ENIQ_CONF_DIR}/${BLK_STOR_INI}"
		abort_script "${_err_msg_}"
	fi
done

# Store the ini file
$CP ${TEM_DIR}/${BLK_STOR_INI} ${ENIQ_CONF_DIR}/${BLK_STOR_INI}
if [ $? -ne 0 ]; then
	_err_msg_="Could not save new version of\n${ENIQ_CONF_DIR}/${BLK_STOR_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
}

### Function: common_confirm_user_input ###
#
# Confirm with user that values entered are correct
#
# Arguments:
#	   none
# Return Values:
#	   none
confirm_user_input()
{
while :; do
	clear

	$ECHO "USER VALUE CONFIRMATION"
	$ECHO "=======================\n"

	$CAT ${TEM_DIR}/store_confirm_file
	$ECHO "\nIs the information above correct (Yes|No)"
	read _ans_

	if [ ! "${_ans_}" ]; then
		continue
	fi

	if [ "${_ans_}" == "Yes" -o "${_ans_}" == "No" ]; then
		break
	else
		continue
	fi
done
}

### Function: create_admin_dir ###
#
# Creates the admin directory
#
# Arguments:
#   none
# Return Values:
#   none
create_admin_dir()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

# Check for admin directory in the templates directory
$ECHO "Checking for ${ENIQ_TEMPL_DIR}/admin" >> ${LOGFILE}
if [ ! -d  ${ENIQ_TEMPL_DIR}/admin ]; then
	_err_msg_="Could not locate directory ${ENIQ_TEMPL_DIR}/admin"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Get the System User/Group. All directories are owned by this
_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file\n${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysgrp_=`$ID ${_sysuser_} | $AWK '{print $2}' | $AWK -F\( '{print $2}' | $AWK -F\) '{print $1}'`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not determine group ID of ${_sysuser_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_rootdir_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_BASE_DIR`
_role_name_=`iniget SunOS_RBAC_ROLE_1 -f ${ENIQ_CONF_DIR}/${RBAC_INI} -v role_name`

if [ ! -d ${_rootdir_}/admin ]; then
	$ECHO "Creating ${_rootdir_}/admin" >> ${LOGFILE}
	$MKDIR -p ${_rootdir_}/admin
	if [ $? -ne 0 ]; then
		_err_msg_="Could not make directory ${_rootdir_}/admin"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

if [ "${STORAGE_TYPE}" == "raw" ]; then  
	# Check mountpoints and mount if not there
	mount_req_dirs
	if [ $? -ne 0 ]; then
		_err_msg_="Could not mount required directories for $NEXT_STAGE"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

if [ ! -d ${_rootdir_}/admin/bin -o "${UPGRADE}" ]; then
	# Make a backup of the smf_contract_config file
	if [ -s ${_rootdir_}/admin/etc/smf_contract_config ]; then
		$ECHO "Making a backup copy of ${_rootdir_}/admin/etc/smf_contract_config" >> ${LOGFILE}
		$CP -p ${_rootdir_}/admin/etc/smf_contract_config ${TEM_DIR}/smf_contract_config.$$
		if [ $? -ne 0 ]; then
			_err_msg_="Could not copy ${_rootdir_}/admin/etc/smf_contract_config ${TEM_DIR}/smf_contract_config.$$"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi

	$RM -rf ${TEM_DIR}/admin
	$MKDIR -p ${TEM_DIR}/admin
	$CP -rp ${ENIQ_TEMPL_DIR}/admin/* ${TEM_DIR}/admin
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy ${ENIQ_TEMPL_DIR}/admin/* to ${TEM_DIR}/admin"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	$ECHO "Updating values in files in ${ENIQ_TEMPL_DIR}/admin" | $TEE -a ${LOGFILE}
	_tem_file_=${TEM_DIR}/tem_file
	for _file_ in `$FIND ${TEM_DIR}/admin -type f`; do
		$RM -f ${_tem_file_}
		$CAT ${_file_} | $SED -e "s|<CHANGE><ENIQ_SYSUSER>|${_sysuser_}|g"	 \
							  -e "s|<CHANGE><ENIQ_ADM_ROLE>|${_role_name_}|g"  \
							  -e "s|<CHANGE><ENIQ_BASE_DIR>|${_rootdir_}|g"	\
		> ${_tem_file_}

		$CP ${_tem_file_} ${_file_}
	done

	$ECHO "Copying updated files from ${TEM_DIR}/admin to ${_rootdir_}/admin" | $TEE -a ${LOGFILE}
	$CP -rp ${TEM_DIR}/admin/* ${_rootdir_}/admin
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy ${TEM_DIR}/admin to ${_rootdir_}/admin"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	_dwhdb_cfg_path_=${_rootdir_}/admin/sybase_conf
	if [ "${INSTALL_TYPE}" == "stats" ]; then
		if [  "${CURR_SERVER_TYPE}" == "stats_coordinator"  ]; then
			$CP -p ${_dwhdb_cfg_path_}/dwhdb_multi.cfg ${_dwhdb_cfg_path_}/dwhdb.cfg
			if [ $? -ne 0 ]; then
				_err_msg_="Could not copy ${_dwhdb_cfg_path_}/dwhdb_multi.cfg to ${_dwhdb_cfg_path_}/dwhdb.cfg"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		else
			$CP -p ${_dwhdb_cfg_path_}/dwhdb_single.cfg ${_dwhdb_cfg_path_}/dwhdb.cfg
			if [ $? -ne 0 ]; then
				_err_msg_="Could not copy ${_dwhdb_cfg_path_}/dwhdb_single.cfg to ${_dwhdb_cfg_path_}/dwhdb.cfg"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		fi
	fi

	
		if [ ! -f  ${_dwhdb_cfg_path_}/dwhdb.cfg ]; then
			_err_msg_="Aborting as database config file ${_dwhdb_cfg_path_}/dwhdb.cfg does not exist"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
   


	# Necessary to preserve file permissions
	$ECHO "Changing ownership of ${_rootdir_}/admin/bin to ${_sysuser_}:${_sysgrp_}" | $TEE -a ${LOGFILE}
	$CHOWN -R ${_sysuser_}:${_sysgrp_} ${_rootdir_}/admin/bin >> /dev/null 2>&1
	if [ $? -ne 0 ]; then
		_err_msg_="Could not change ownership of ${_rootdir_}/admin/${_dir_} to ${_sysuser_}:${_sysgrp_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	
		for _dir_ in sybase_conf sql; do
			$ECHO "Changing ownership of ${_rootdir_}/admin/${_dir_} to ${_sysuser_}:${_sysgrp_}" | $TEE -a ${LOGFILE}
			$CHOWN -R ${_sysuser_}:${_sysgrp_} ${_rootdir_}/admin/${_dir_} >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Could not change ownership of ${_rootdir_}/admin/${_dir_} to ${_sysuser_}:${_sysgrp_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		done
   
fi

if [ "${STORAGE_TYPE}" == "raw" ]; then
	# Update the sym link script permissions
	for _sym_script_ in `$LS ${_rootdir_}/admin/bin | $EGREP "pl$"`; do
		$ECHO "Changing ownership of ${_rootdir_}/admin/bin/${_sym_script_} to root:storage" | $TEE -a ${LOGFILE}
		$CHOWN -R root:storage ${_rootdir_}/admin/bin/${_sym_script_} >> /dev/null 2>&1
		if [ $? -ne 0 ]; then
			_err_msg_="Could not change ownership of ${_rootdir_}/admin/bin/${_sym_script_} to root:storage"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	done

	if [ -s ${_rootdir_}/admin/etc/manage_sym_links.cfg ]; then
		$ECHO "Changing ownership of ${_rootdir_}/admin/etc/manage_sym_links.cfg to root:storage" | $TEE -a ${LOGFILE}
		$CHOWN -R root:storage ${_rootdir_}/admin/etc/manage_sym_links.cfg >> /dev/null 2>&1
		if [ $? -ne 0 ]; then
			_err_msg_="Could not change ownership of ${_rootdir_}/admin/etc/manage_sym_links.cfg to root:storage"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi
fi

if [ -s ${TEM_DIR}/smf_contract_config.$$ -a "${UPGRADE}" ] ; then
	$ECHO "Updating ${_rootdir_}/admin/etc/smf_contract_config" >> ${LOGFILE}
	_current_sim_val_=`$CAT ${TEM_DIR}/smf_contract_config.$$ | $EGREP "${INSTALL_TYPE}" | $GREP -w sim`
	_template_sim_val_=`$CAT ${_rootdir_}/admin/etc/smf_contract_config | $EGREP "${INSTALL_TYPE}" | $GREP -w sim`

	_service_opt_=`$ECHO ${_current_sim_val_}| $AWK -F"::" '{print $4}'`

	if [ "${_service_opt_}" == "Y" ]; then
		$SED -i s/${_template_sim_val_}/${_current_sim_val_}/g ${_rootdir_}/admin/etc/smf_contract_config  
		if [ $? -ne 0 ]; then
			_err_msg_="Could not replace value of sim in the file ${_rootdir_}/admin/etc/smf_contract_config "
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi
fi


insert_header_footer foot "Successfully populated /eniq/admin directory" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}
### Function: create_directories ###
#
# Creates all required Directories
#
# Arguments:
#   none
# Return Values:
#   none
create_directories()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

# Get the System User/Group. All directories are owned by this
_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file\n${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
fi

_sysgrp_=`$ID ${_sysuser_} | $AWK '{print $2}' | $AWK -F\( '{print $2}' | $AWK -F\) '{print $1}'`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not determine group ID of ${_sysuser_}"
	abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
fi

if [ "${STORAGE_TYPE}" == "raw" ]; then
	# Check mountpoints and mount if not there
	mount_req_dirs
	if [ $? -ne 0 ]; then
		_err_msg_="Could not mount required directories for $NEXT_STAGE"
		abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
	fi
fi

$ECHO -e "Getting list of required fs filesystems from ${ENIQ_CONF_DIR}/${SUNOS_INI}\n" >> ${LOGFILE}
_fs_list_=`iniget SunOS_ZFS_FS -f ${ENIQ_CONF_DIR}/${SUNOS_INI}`
for _fs_ in ${_fs_list_}; do
	_fs_name_=`iniget ${_fs_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v name`
	_fs_mount_pt_=`iniget ${_fs_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v mountpoint`
	_fs_perms_=`iniget ${_fs_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v perms`

	$ECHO "Changing filesystem `$BASENAME ${_fs_name_}` ownership to ${_sysuser_}:${_sysgrp_}" | $TEE -a ${LOGFILE}
	$CHOWN ${_sysuser_}:${_sysgrp_} ${_fs_mount_pt_} >> /dev/null 2>&1
	if [ $? -ne 0 ]; then
		_err_msg_="Could not change fs filesystem `$BASENAME ${_fs_name_}` ownership to ${_sysuser_}:${_sysgrp_}"
		abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
	fi

	$ECHO "Changing fileSystem `$BASENAME ${_fs_name_}` permissions to ${_fs_perms_}" | $TEE -a ${LOGFILE}
	$CHMOD ${_fs_perms_} ${_fs_mount_pt_} >> /dev/null 2>&1
	if [ $? -ne 0 ]; then
		_err_msg_="Could not change fs filesystem `$BASENAME ${_fs_name_}` permissions to ${_fs_perms_}"
		abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
	fi
	$ECHO -e "\n"
done

$ECHO -e "\nGetting list of required directories from ${ENIQ_CONF_DIR}/${SUNOS_INI}\n" >> ${LOGFILE}
_dir_list_=`iniget SunOS_DIRECTORY -f ${ENIQ_CONF_DIR}/${SUNOS_INI}`
if [ ! "${_dir_list_}" ]; then
	_err_msg_="Could not get list of required directories from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
fi

for _dir_ in ${_dir_list_}; do
	unset _dir_user_ _dir_group_
	_dir_path_=`iniget ${_dir_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v path`
	_dir_perms_=`iniget ${_dir_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v perms`
	if [ ! "${_dir_path_}" -o ! "${_dir_perms_}" ]; then
		_err_msg_="Could not read information for ${_dir_} from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
	fi

	_dir_user_=`iniget ${_dir_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v user`
	if [ "${_dir_user_}" ]; then
		_new_dir_user_="${_dir_user_}"
	else
		_new_dir_user_="${_sysuser_}"
	fi

	_dir_group_=`iniget ${_dir_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v group`
	if [ "${_dir_group_}" ]; then
		_new_dir_group_="${_dir_group_}"
	else
		_new_dir_group_="${_sysgrp_}"
	fi

	$ECHO "Creating directory ${_dir_path_}" | $TEE -a ${LOGFILE}
	$MKDIR -p ${_dir_path_} >> /dev/null 2>&1
	if [ $? -ne 0 ]; then
		_err_msg_="Could not create directory ${_dir_path_}"
		abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
	fi

	$ECHO "Changing ownership of ${_dir_path_} to ${_new_dir_user_}:${_new_dir_group_}" | $TEE -a ${LOGFILE}
	$CHOWN ${_new_dir_user_}:${_new_dir_group_} ${_dir_path_} >> /dev/null 2>&1
	if [ $? -ne 0 ]; then
		_err_msg_="Could not change ownership of ${_dir_path_} to ${_new_dir_user_}:${_new_dir_group_}"
		abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
	fi

	$ECHO "Changing permissions on ${_dir_path_} to ${_dir_perms_}"  | $TEE -a ${LOGFILE}
	$CHMOD ${_dir_perms_} ${_dir_path_} >> /dev/null 2>&1
	if [ $? -ne 0 ]; then
		_err_msg_="Could not change directory ${_dir_path_} permissions to ${_dir_perms_}"
		abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
	fi

done

insert_header_footer foot "Successfully created required directories" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}


### Function: create_disk_list ###
#
# This will create a formatted ouptput of the disks on the
# machine.
#
# Arguments:
#	   $1 - File to write output into
# Return Values:
#	   none
create_disk_list()
{
if [ ! "${1}" ]; then
	_err_msg_="Function Usage : create_disk_list <ouput_file>"
	abort_script "${_err_msg_}"
fi

_out_file_=${1}
$TOUCH ${_out_file_} >> /dev/null 2>&1
if [ $? -ne 0 ]; then
	_err_msg_="Could not create output file ${_out_file_}"
	abort_script "${_err_msg_}"
fi

$ECHO -e "\nBuilding Disk Table.......Please Wait"

# Get the list of the disks seperated by "@" delimiter
${SCRIPTHOME}/get_disk_list.sh -f -r -d "@" > ${TEM_DIR}/tem_disk_file
if [ ! -s ${TEM_DIR}/tem_disk_file ]; then
	_err_msg_="No disk details returned from command\n${SCRIPTHOME}/get_disk_list.sh -f -r -d "@""
	abort_script "${_err_msg_}"
fi

$GREP -w "ERROR" ${TEM_DIR}/tem_disk_file >> /dev/null 2>&1
if [ $? -eq 0 ]; then
	$ECHO -e "\n"
	$GREP -w "ERROR" ${TEM_DIR}/tem_disk_file
	$ECHO -e "\nCould not read disk information from the listed disks above"
	$ECHO "They will be excluded from the avaiable disk list"
	$ECHO -e "\nPress any key to continue"
	read _any_
fi
$CAT ${TEM_DIR}/tem_disk_file | $GREP -vw "ERROR" > ${_out_file_}
}

### Function: remove_existing_PV_VG ###
#
# Removes existing PV and VG from Unity LUN : Infra owned functionality
#
# Arguments:
#   none
# Return Values:
#   none
remove_existing_PV_VG() 
{
        #Getting the root partition filesystem name 
        _root_fs_=`df -hk / | $GREP root | $AWK -F " " '{print $1}'`
        if [ $? -ne 0 ]; then
            _err_msg_="Could not get the value of _root_fs_"
            abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
        fi

        # Getting root partition's Volume Group name
        _root_vg_=`$ECHO ${_root_fs_} | $AWK -F "/" '{print $4}' |  $AWK -F "-" '{print $1}'`
        if [ $? -ne 0 ]; then
            _err_msg_="Could not get the value of _root_vg_"
            abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
        fi
		
		# Remove existing VG's and PV's
        $TOUCH ${TEM_DIR}/vg_exclude	
        $VGS -o vgname,pvname --noheadings | $GREP -v ${_root_vg_} >> /dev/null
        if [ $? -eq 0 ]; then
            $VGS |  $GREP -v "${_root_vg_}\|VG" | $AWK '{print $1}' >> ${TEM_DIR}/vg_exclude
            if [ $? -ne 0 ]; then
                _err_msg_="Could not get the list of volume group"
                abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
            fi
            while read line; do
                _vgs_=${line}
                $VGREMOVE -f ${_vgs_}
		        if [ $? -ne 0 ]; then
                    _err_msg_="Could not remove volume group"
                    abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
                fi
            done < ${TEM_DIR}/vg_exclude

            _pv_=`$PVS  |  $GREP -v "${_root_vg_}\|PV" | awk '{print $1}'`
            $PVREMOVE ${_pv_}
	        if [ $? -ne 0 ]; then
                _err_msg_="Could not remove PV"
                abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
            fi
        fi
}

### Function: create_disk_partition ###
#
# Creates partition over data disk
#
# Arguments:
#   none
# Return Values:
#   none
create_disk_partition() 
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type
if [ $? -ne 0 ]; then
	_err_msg_="Could not get the value of storage type"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Getting the path of BLKCLI command in Blade server
if [ "${STORAGE_TYPE}" == "raw" ]; then
	if [ -s ${ENIQ_CONF_DIR}/${SUNOS_INI} ]; then
		_ini_src_dir_=${ENIQ_CONF_DIR}
		_ini_file_=${SUNOS_INI}
	else
		_ini_src_dir_=${ENIQ_TEMPL_DIR}
		_ini_file_="${SUNOS_INI}_${SAN_DEVICE}"
	fi

	# Read location of storage API command
	_stor_api_cmd_=`iniget STOR_API -f ${_ini_src_dir_}/${_ini_file_} -v STOR_API_CMD`
	if [ ! "${_stor_api_cmd_}" ]; then
		_err_msg_="Could not read STOR_API_CMD param from ${_ini_src_dir_}/${_ini_file_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	if [ ! -x ${_stor_api_cmd_} ]; then
		_err_msg_="${_stor_api_cmd_} is not found or is not executable"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

#Getting the output of BLKCLI command in Blade
if [ "${STORAGE_TYPE}" == "raw" ]; then
		for (( _count_=0;${_count_}<2;_count_++ ));do
	   		$RM -f ${TEM_DIR}/listluns.txt
				${_stor_api_cmd_} --action listluns >> ${TEM_DIR}/listluns.txt
				if [ $? -ne 0 ]; then
			   		# exit from script if return code non-zero
					_err_msg_="Couldn't get list of LUNs."
					abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				else
					# check if listluns.txt has content in case return code is zero
					if [ ! -s ${TEM_DIR}/listluns.txt ]; then
						continue
						fi
				fi
				break
		done
		
		# Infra Owned functionality : To remove existing PV and VG
		if [ ! "${MIGRATION}" ]; then
		    remove_existing_PV_VG
		fi
else
		#Getting the root partition filesystem name 
		_root_fs_=`df -hk / | $GREP root | $AWK -F " " '{print $1}'`
		if [ $? -ne 0 ]; then
				_err_msg_="Could not get the value of _root_fs_"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

	# Getting root partition's Volume Group name
		_root_vg_=`$ECHO ${_root_fs_} | $AWK -F "/" '{print $4}' |  $AWK -F "-" '{print $1}'`
		if [ $? -ne 0 ]; then
				_err_msg_="Could not get the value of _root_vg_"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		#Getting list of root disks including mirrored disk
		_root_disk_device_=`$LSBLK | $GREP -v "fd0" | $GREP -B 4 ${_root_vg_} | $GREP disk | $AWK '{print $1}' | $SED ':a;N;$!ba;s/\n/|/g'`
		if [ $? -ne 0 ]; then
				_err_msg_="Could not get the value of _root_disk_device_"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		#Getting list of data disk devices
		$LSSCSI | $EGREP -v "storage|enclosu|${_root_disk_device_}|sr0" | $AWK -F " " '{print $7}' | $AWK -F "/" '{print $3}' > ${TEM_DIR}/listluns.txt
		if [ $? -ne 0 ]; then
				_err_msg_="Could not get the list of data disk devices"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

fi

if [ "${STORAGE_TYPE}" == "raw" ]; then
		#Generating the list of SAN devices
			while read line; do
				_disk_device_=`$ECHO $line | $AWK -F ";" '{print $2}'`
				if [ $? -ne 0 ]; then
					 _err_msg_="Could not get SAN disk"
					 abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				fi

				$ECHO ${_disk_device_} >> ${TEM_DIR}/db_disk_list
				if [ $? -ne 0 ]; then
					 _err_msg_="Could not create ${TEM_DIR}/db_disk_list file"
					 abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				fi
		   done < ${TEM_DIR}/listluns.txt	   
else
		#Generating list of data disk for Rack server
		$CP ${TEM_DIR}/listluns.txt ${TEM_DIR}/db_disk_list
		if [ $? -ne 0 ]; then
				_err_msg_="Could not create ${TEM_DIR}/db_disk_list file"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
fi


for _disk_ in `$CAT ${TEM_DIR}/db_disk_list`; do

		#Getting wwid for disks on blade server
		if [ "${STORAGE_TYPE}" == "raw" -a "${_san_device_}" != "local" ]; then
				_partd_lun_=`$EGREP "${_disk_}" ${TEM_DIR}/db_disk_list | $AWK -F ";" '{print $1}'`
				if [ ! "${_partd_lun_}" ]; then
					log_msg -s " Could not get LUN ID for $_disk_" -l ${LOGFILE}
				fi
		fi

		# Excluding already labeled disks if /eniq/installation/config/disks_partitioned file is present
		if [ -f ${ENIQ_CONF_DIR}/disks_partitioned ]; then
				if [ "${STORAGE_TYPE}" == "raw" -a "${_san_device_}" != "local" ]; then
				$GREP -w "${_partd_lun_}" ${ENIQ_CONF_DIR}/disks_partitioned >> /dev/null 2>&1
				if [ $? -eq 0 ]; then
					log_msg -s "${_partd_lun_} already partitioned" -l ${LOGFILE}
					continue
				fi
				else
					$GREP -w "${_disk_}" ${ENIQ_CONF_DIR}/disks_partitioned >> /dev/null 2>&1
					if [ $? -eq 0 ]; then
						log_msg -s "${_disk_} already partitioned" -l ${LOGFILE}
						continue
					fi
				fi
		else
				if [ -f ${TEM_DIR}/partition_disk_list ]; then
			if [ "${STORAGE_TYPE}" == "raw" -a "${_san_device_}" != "local" ]; then
						$GREP -w "${_partd_lun_}" ${ENIQ_CONF_DIR}/disks_partitioned >> /dev/null 2>&1
						if [ $? -eq 0 ]; then
							log_msg -s "${_partd_lun_} already partitioned" -l ${LOGFILE}
							continue
						fi
					else
						$GREP -w "${_disk_}" ${ENIQ_CONF_DIR}/disks_partitioned >> /dev/null 2>&1
						if [ $? -eq 0 ]; then
							log_msg -s "${_disk_} already partitioned" -l ${LOGFILE}
							continue
						fi
					fi	
				 fi
		fi

		#Checking if SAN disk is present in the output of PARTED command. If not
		#present do not create partition for that SAN disk
	if [ "${_san_device_}" == "local" -o "${STORAGE_TYPE}" == "fs" ]; then 
		   $PARTED /dev/${_disk_} -s   >> /dev/null 2>&1
		   if [ $? -ne 0 ]; then
				_err_msg_="Could  not find SAN disk ${_disk_} in the output of PARTED"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		   fi
		   #Changing disk label to GPT
		   $PARTED /dev/${_disk_} -s mklabel gpt
		   if [ $? -ne 0 ]; then
				_err_msg_="Could not change disk label to gpt for ${_disk_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		   fi

		   #Creating one partition over the SAN disk with full size
		   log_msg -s "Staring to create ${_disk_}${PARTITION_NUM} partition" -l ${LOGFILE}
		   $PARTED /dev/${_disk_} -a optimal -s mkpart primary 0% 100% >>/dev/null 2>&1		
	   #Checking if partition is created successfully
		   if [ $? -ne 0 ]; then
				_err_msg_="Failed to create partition ${_disk_}${PARTITION_NUM}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		   else
				log_msg -s "Partition ${_disk_}${PARTITION_NUM} created successfully" -l ${LOGFILE}
		   fi
		   #Setting lvm flag on
		   $PARTED /dev/${_disk_} -s set 1 lvm on
		   if [ $? -ne 0 ]; then
			_err_msg_="Could not set lvm flag for ${_disk_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		   fi
		
		   $ECHO "/dev/${_disk_}" >> ${TEM_DIR}/partition_disk_list
		   if [ $? -ne 0 ]; then
				_err_msg_="Could not update ${TEM_DIR}/partition_disk_list with ${_disk_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		   fi
		else
		
		   $PARTED /dev/mapper/${_disk_} -s  >> /dev/null 2>&1
		   if [ $? -ne 0 ]; then
				_err_msg_="Could not find SAN disk ${_disk_} in the output of PARTED"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		   fi
		   #Changing disk label to GPT
		   $PARTED /dev/mapper/${_disk_} -s mklabel gpt
		   if [ $? -ne 0 ]; then
				 _err_msg_="Could not change disk label to gpt for ${_disk_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	   fi

		  #Creating one partition over the SAN disk with full size
		  log_msg -s "Staring to create ${_disk_}${PARTITION_NUM} partition" -l ${LOGFILE}
		  $PARTED /dev/mapper/${_disk_} -a optimal -s mkpart primary 0% 100% >>/dev/null 2>&1		
		  #Checking if partition is created successfully
		  if [ $? -ne 0 ]; then
			   _err_msg_="Failed to create partition ${_disk_}${PARTITION_NUM}"
			   abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		  else
			   log_msg -s "Partition ${_disk_}${PARTITION_NUM} created successfully\n" -l ${LOGFILE}
		  fi
		
		  #Setting lvm flag on
		  $PARTED /dev/mapper/${_disk_} -s set 1 lvm on
		  if [ $? -ne 0 ]; then
			   _err_msg_="Could not set lvm flag for ${_disk_}"
			   abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		  fi
	
		  if [ "${STORAGE_TYPE}" == "raw" -a "${_san_device_}" != "local" ]; then 
			  $ECHO "${_partd_lun_}" >> ${TEM_DIR}/partition_disk_list
			  if [ $? -ne 0 ]; then
				 _err_msg_="Could not update ${TEM_DIR}/partition_disk_list with ${_disk_}"
				 abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			  fi
		  fi
		
	   fi
done

if [ -f ${TEM_DIR}/partition_disk_list ]; then
	log_msg -s "Updating partitioned data disks in ${ENIQ_CONF_DIR}/disks_partitioned file" -l ${LOGFILE}
	$CAT ${TEM_DIR}/partition_disk_list >> ${ENIQ_CONF_DIR}/disks_partitioned
	if [ $? -ne 0 ]; then
		_err_msg_="Could not update ${ENIQ_CONF_DIR}/disks_partitioned"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

insert_header_footer foot "Successfully created partitions over data disks" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: create_dwhdb ###
#
# Create the dwh database
#
# Arguments:
#   none
# Return Values:
#   none
create_dwhdb()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" == "raw" ]; then
	# Read the deployment
	_deployment_=`$CAT ${ENIQ_CONF_DIR}/extra_params/deployment`
	if [ ! "${_deployment_}" ]; then
		_err_msg_="Could determine the deployment type from ${ENIQ_CONF_DIR}/extra_params/deployment"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

# Move the required files to where the ENIQ CLI program expects them
_cli_conf_dir_=`$CAT ${ENIQ_CONF_DIR}/${ENIQ_ENV} | $EGREP "^[[:blank:]]*CONF_DIR="|$AWK -F\= '{print $2}'|$SED -e 's|"||g'`
if [ ! "${_cli_conf_dir_}" ]; then
	_err_msg_="Could not read CONF_DIR parameter from ${ENIQ_CONF_DIR}/${ENIQ_ENV}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_iq_dir_=`iniget SYBASE_IQ -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v SYBASE_IQ_TARGET_DIR`
if [ ! "${_cli_conf_dir_}" ]; then
	_err_msg_="Could not read SYBASE_IQ_TARGET_DIR parameter from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Check required files and scripts exist
if [ ! -s ${_cli_conf_dir_}/${ENIQ_ENV} ]; then
	_err_msg_="File ${_cli_conf_dir_}/${ENIQ_ENV} not found, or is empty"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
else
	log_msg -l ${LOGFILE} -q -s "Sourcing ${_cli_conf_dir_}/niq.rc"
	. ${_cli_conf_dir_}/niq.rc
fi

if [ -s ${_iq_dir_}/IQ.sh ]; then
	_iq_env_file_="${_iq_dir_}/IQ.sh"
else
	   _err_msg_="Could not locate SYBASE environ file under ${_iq_dir_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
. ${_iq_env_file_}

if [ ! -s ${ENIQ_ADMIN_BIN_DIR}/dwhdb ]; then
	_err_msg_="${ENIQ_ADMIN_BIN_DIR}/dwhdb script not found, or is not executable"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ! -s ${SCRIPTHOME}/create_dwhdb.bsh ]; then
	_err_msg_="${SCRIPTHOME}/create_dwhdb.bsh script not found"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ! -s ${SCRIPTHOME}/add_main_dbspaces.bsh ]; then
	_err_msg_="${SCRIPTHOME}/add_main_dbspaces.bsh script not found"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ! -s ${SCRIPTHOME}/add_temp_dbspaces.bsh ]; then
	_err_msg_="${SCRIPTHOME}/add_temp_dbspaces.bsh script not found"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ! -s ${SCRIPTHOME}/dboptions_dwhdb.bsh ]; then
	_err_msg_="${SCRIPTHOME}/dboptions_dwhdb.bsh script not found"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi


_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysgrp_=`$ID ${_sysuser_} | $AWK '{print $2}' | $AWK -F\( '{print $2}' | $AWK -F\) '{print $1}'`
if [ ! "${_sysgrp_}" ]; then
	_err_msg_="Could not determine group ID of ${_sysuser_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

log_msg -l ${LOGFILE} -q -s "\nChanging ownership of ${SCRIPTHOME}/create_dwhdb.bsh to ${_sysuser_}:${_sysgrp_}"
$CHOWN ${_sysuser_}:${_sysgrp_} ${SCRIPTHOME}/create_dwhdb.bsh
if [ $? -ne 0 ]; then
	_err_msg_="Could not change ownership of ${SCRIPTHOME}/create_dwhdb.bsh to ${_sysuser_}:${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

log_msg -l ${LOGFILE} -q -s "Changing ownership of ${SCRIPTHOME}/add_main_dbspaces.bsh to ${_sysuser_}:${_sysgrp_}"
$CHOWN ${_sysuser_}:${_sysgrp_} ${SCRIPTHOME}/add_main_dbspaces.bsh
if [ $? -ne 0 ]; then
	_err_msg_="Could not change ownership of ${SCRIPTHOME}/add_main_dbspaces.bsh to ${_sysuser_}:${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

log_msg -l ${LOGFILE} -q -s "Changing ownership of ${SCRIPTHOME}/add_temp_dbspaces.bsh to ${_sysuser_}:${_sysgrp_}"
$CHOWN ${_sysuser_}:${_sysgrp_} ${SCRIPTHOME}/add_temp_dbspaces.bsh
if [ $? -ne 0 ]; then
	_err_msg_="Could not change ownership of ${SCRIPTHOME}/add_temp_dbspaces.bsh to ${_sysuser_}:${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Update the service_names file
log_msg -l ${LOGFILE} -q -s "Adding dwhdb service name to ${_cli_conf_dir_}/service_names"
update_service_file ${_cli_conf_dir_}/service_names ${HOST_IP} ${HNAME} dwhdb "NULL_GRP"
if [ $? -ne 0 ]; then
	_err_msg_="Failed to update ${_cli_conf_dir_}/service_names with dwhdb information"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

log_msg -l ${LOGFILE} -q -s "Changing ownership of ${_cli_conf_dir_}/service_names to ${_sysuser_}:${_sysgrp_} after updates for dwhdb"
$CHOWN ${_sysuser_}:${_sysgrp_} ${_cli_conf_dir_}/service_names
if [ $? -ne 0 ]; then
	_err_msg_="Failed to change ownership of ${_cli_conf_dir_}/service_names to ${_sysuser_}:${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ -s ${ENIQ_ADMIN_DIR}/sybase_conf/${CURR_SERVER_TYPE}/dwhdb.cfg ]; then
	DWHDB_CFG_PATH=${ENIQ_ADMIN_DIR}/sybase_conf/${CURR_SERVER_TYPE}
elif [ -s ${ENIQ_ADMIN_DIR}/sybase_conf/dwhdb.cfg ]; then
	DWHDB_CFG_PATH=${ENIQ_ADMIN_DIR}/sybase_conf/
else
	_err_msg_="Files ${ENIQ_ADMIN_DIR}/sybase_conf/dwhdb.cfg and ${ENIQ_ADMIN_DIR}/sybase_conf/${CURR_SERVER_TYPE}/dwhdb.cfg do not exist"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Create an IQ log dir
$MKDIR -p ${ENIQ_LOG_DIR}/iq
$CHOWN ${_sysuser_}:${_sysgrp_} ${ENIQ_LOG_DIR}/iq
if [ $? -ne 0 ]; then
	_err_msg_="Could not change ownership of ${ENIQ_LOG_DIR}/iq to ${_sysuser_}:${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

log_msg -s "\nDeploying dwh configuration files..." -l ${LOGFILE}
# Make a backup of dwhdb.cfg
if [ -f ${DWH_DIR}/dwhdb.cfg ]; then
	log_msg -s "Backing up ${DWH_DIR}/dwhdb.cfg file" -l ${LOGFILE}
	$CP ${DWH_DIR}/dwhdb.cfg ${DWH_DIR}/dwhdb.cfg.`$DATE '+%y%m%d'`
	if [ $? -ne 0 ]; then
		_err_msg_="Could not move ${DWH_DIR}/dwhdb.cfg to ${DWH_DIR}/dwhdb.cfg.`$DATE '+%y%m%d'`"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

# Update log info in dwhdb.cfg
if [ -f ${DWHDB_CFG_PATH}/dwhdb.cfg ]; then
	_tmp_cfg_=${DWH_DIR}/dwhdb.cfg.tmp
	$CAT ${DWHDB_CFG_PATH}/dwhdb.cfg | $SED -e "s|@@path_to_log@@|${IQLOGDIR}|" \
		-e "s|@@dwh_instance@@|dwhdb|g" > $_tmp_cfg_
	if [ $? -ne 0 ]; then
		_err_msg_="Could not update ${DWH_DIR}/dwhdb.cfg"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi


	_initial_cache_max_=`iniget DWH -v InitialMaxCache -f ${ENIQ_CONF_DIR}/${ENIQ_INI}`
	if [ ! -z "$_initial_cache_max_" ] ; then
		$CAT $_tmp_cfg_ | $SED -e "s|^-c .*|-c $_initial_cache_max_|g" > ${_tmp_cfg_}.3
		if [ $? -ne 0 ]; then
			_err_msg_="Could not update ${DWH_DIR}/dwhdb.cfg with max initial cache size"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
		$MV ${_tmp_cfg_}.3 ${_tmp_cfg_}
	fi
	if [ "${STORAGE_TYPE}" == "raw" ]; then
		if [ "${_deployment_}" == "large" ]; then
			_no_connections_=`iniget DWH -v NumberOfConnectionsLarge -f ${ENIQ_CONF_DIR}/${ENIQ_INI}`
			if [ ! -z "$_no_connections_" ] ; then
				$CAT $_tmp_cfg_ | $SED -e "s|^-gm .*|-gm $_no_connections_|g" > ${_tmp_cfg_}.4
				if [ $? -ne 0 ]; then
					_err_msg_="Could not update ${DWH_DIR}/dwhdb.cfg with Number Of Connections(-gm)"
					abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				fi
				$MV ${_tmp_cfg_}.4 ${_tmp_cfg_}
			fi
		fi
	fi


	$MV ${_tmp_cfg_} ${DWH_DIR}/dwhdb.cfg
	if [ $? -ne 0 ]; then
		_err_msg_="Could not set ${DWH_DIR}/dwhdb.cfg"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	$CHMOD 440 ${DWH_DIR}/dwhdb.cfg
	if [ $? -ne 0 ]; then
		_err_msg_="Could not change permissions of ${DWH_DIR}/dwhdb.cfg to -r--r-----"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	log_msg -l ${LOGFILE} -q -s "\nChanging ownership of ${DWH_DIR}/dwhdb.cfg to ${_sysuser_}:${_sysgrp_}"
	$CHOWN ${_sysuser_}:${_sysgrp_} ${DWH_DIR}/dwhdb.cfg
	if [ $? -ne 0 ]; then
		_err_msg_="Could not change ownership of ${DWH_DIR}/dwhdb.cfg to ${_sysuser_}:${_sysgrp_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
else
	_err_msg_="File ${DWHDB_CFG_PATH}/dwhdb.cfg does not exist"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

#Start the Util Server
UTIL_PORT=`iniget DB -v DWHUtilServerPort -f ${_cli_conf_dir_}/${ENIQ_INI}`
if [ ! "${UTIL_PORT}" ]; then
	_err_msg_="Could not read UtilServerPort value from ${_cli_conf_dir_}/${ENIQ_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

DBA_PASSWORD=`inigetpassword DB -v DBAPassword -f ${_cli_conf_dir_}/${ENIQ_INI}`
if [ ! "${DBA_PASSWORD}" ]; then
	if [ -f ${ENIQ_BASE_DIR}/sw/installer/dbusers ]; then
		DBA_PASSWORD=`${ENIQ_BASE_DIR}/sw/installer/dbusers dba dwhrep`
		if [ ! "${DBA_PASSWORD}" ] ; then
			_err_msg_="Could not get dwhdb DBA Password from ${ENIQ_BASE_DIR}/sw/installer/dbusers"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	else
		_err_msg_="Could not read DBAPassword value from ${_cli_conf_dir_}/${ENIQ_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

if [ ! -f ${DWH_DIR}/install.complete ]; then
	if [ -f  ${DWH_DIR}/*.db ]; then
		log_msg -s "\nDWH Database installation was not completed before. Cleaning up..." -l ${LOGFILE}
		$SU - ${_sysuser_} -c "${ENIQ_ADMIN_BIN_DIR}/dwhdb stop" >> /dev/null 2>&1
		$MV ${DWH_DIR}/dwhdb.cfg ${TEM_DIR}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not move ${DWH_DIR}/dwhdb.cfg to ${TEM_DIR}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
		$RM -rf ${DWH_DIR}/*
		$MV ${TEM_DIR}/dwhdb.cfg ${DWH_DIR}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not move ${TEM_DIR}/dwhdb.cfg to ${DWH_DIR}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
		log_msg -s "Cleanup complete" -l ${LOGFILE}
	fi

	_tmp_log_=${TEM_DIR}/dwh_create.log
	$TOUCH -a ${_tmp_log_}
	$CHOWN ${_sysuser_}:${_sysgrp_} ${_tmp_log_}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not change ownership of ${_tmp_log_} to ${_sysuser_}:${_sysgrp_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	log_msg -s "\nStarting DWH Database creation..." -l ${LOGFILE}
	log_msg -l ${LOGFILE} -q -s "Calling dwdb creation script using command"
	log_msg -l ${LOGFILE} -q -s "$SU - ${_sysuser_} -c \"${BASH} ${SCRIPTHOME}/create_dwhdb.bsh -c ${_cli_conf_dir_} -n ${_cli_conf_dir_}/${ENIQ_INI} -s ${ENIQ_CONF_DIR}/${SYM_INI} -t ${STORAGE_TYPE} -l ${_tmp_log_}\""
	$SU - ${_sysuser_} -c "${BASH} ${SCRIPTHOME}/create_dwhdb.bsh -c ${_cli_conf_dir_} -n ${_cli_conf_dir_}/${ENIQ_INI} -s ${ENIQ_CONF_DIR}/${SYM_INI} -t ${STORAGE_TYPE} -l ${_tmp_log_}"
	if [ $? -ne 0 ]; then
		$CAT ${_tmp_log_} >> ${LOGFILE}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not copy ${_tmp_log_} to ${LOGFILE}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
		_err_msg_="Creating DWH Database failed"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	$CAT ${_tmp_log_} >> ${LOGFILE}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not append ${_tmp_log_} to ${LOGFILE}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	DWHDATE=`$DATE '+%y%m%d_%H%M%S'`
	$ECHO ${DWHDATE} > ${DWH_DIR}/install.complete
	$CHMOD 440 ${DWH_DIR}/install.complete
	if [ $? -ne 0 ]; then
		_err_msg_="Could not change permissions of ${DWH_DIR}/install.complete to -r--r-----"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
else
	log_msg -s "DWH database already created." -l ${LOGFILE}
fi

# Change the permissions
if [ "${STORAGE_TYPE}" == "raw" ]; then
	_dbfile_list_=`iniget DWH_DBSPACES_MAIN -f ${ENIQ_CONF_DIR}/${SYM_INI}`
	if [ "${_dbfile_list_}" ]; then
		for _space_ in ${_dbfile_list_}; do
			_raw_device_=`iniget ${_space_} -f ${ENIQ_CONF_DIR}/${SYM_INI} -v Link`
			if [ ! "${_raw_device_}" ]; then
				_err_msg_="Could not read values from ${ENIQ_CONF_DIR}/${SYM_INI}"
				abort_script "${_err_msg_}"
			fi

			log_msg -l ${LOGFILE} -q -s "Changing ownership of ${_raw_device_} to ${_sysuser_}:${_sysgrp_}"
			$CHOWN -R ${_sysuser_}:${_sysgrp_} ${_raw_device_}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not change ownership of ${_raw_device_} to ${_sysuser_}:${_sysgrp_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			log_msg -l ${LOGFILE} -q -s "Changing permissions of ${_raw_device_} to -rw-rw----"
			$CHMOD 660 ${_raw_device_}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not change permissions of ${_raw_device_} to -rw-rw----"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		done
	else
		_err_msg_="Could not read DWH_DBSPACES_MAIN from ${ENIQ_CONF_DIR}/${SYM_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

_tmp_log_=${TEM_DIR}/dwh_spaces.log
$TOUCH -a ${_tmp_log_}
$CHOWN ${_sysuser_}:${_sysgrp_} ${_tmp_log_}
if [ $? -ne 0 ]; then
	_err_msg_="Could not change ownership of ${_tmp_log_} to ${_sysuser_}:${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Add in the dbspaces
$ECHO "\nAdding main dbspaces..." | $TEE -a ${_tmp_log_}
$ECHO "Beginning to add main dbspaces using command" >> ${_tmp_log_}
$ECHO "$SU - ${_sysuser_} -c \"${BASH} ${SCRIPTHOME}/add_main_dbspaces.bsh -c ${_cli_conf_dir_} -d ${_cli_conf_dir_}/${ENIQ_INI} -s ${ENIQ_CONF_DIR}/${SYM_INI} -l ${_tmp_log_}\"" >> ${_tmp_log_}
$SU - ${_sysuser_} -c "${BASH} ${SCRIPTHOME}/add_main_dbspaces.bsh -c ${_cli_conf_dir_} -d ${_cli_conf_dir_}/${ENIQ_INI} -s ${ENIQ_CONF_DIR}/${SYM_INI} -l ${_tmp_log_}"
if [ $? -ne 0 ]; then
	$CAT ${_tmp_log_} >> ${LOGFILE}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy ${_tmp_log_} to ${LOGFILE}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	_err_msg_="Failed to add main DBSPACES"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
else
	$ECHO "Successfully added main DBSPACES" | $TEE -a ${_tmp_log_}
fi

# Change the permissions
if [ "${STORAGE_TYPE}" == "raw" ]; then
	_dbfile_list_=`iniget DWH_DBSPACES_TEMP -f ${ENIQ_CONF_DIR}/${SYM_INI}`
	if [ "${_dbfile_list_}" ]; then
		for _space_ in ${_dbfile_list_}; do
			_raw_device_=`iniget ${_space_} -f ${ENIQ_CONF_DIR}/${SYM_INI} -v Link`
			if [ ! "${_raw_device_}" ]; then
				_err_msg_="Could not read values from ${ENIQ_CONF_DIR}/${SYM_INI}"
				abort_script "${_err_msg_}"
			fi

			$ECHO "Changing ownership of ${_raw_device_} to ${_sysuser_}:${_sysgrp_}" >> ${_tmp_log_}
			$CHOWN -R ${_sysuser_}:${_sysgrp_} ${_raw_device_}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not change ownership of ${_raw_device_} to ${_sysuser_}:${_sysgrp_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			$ECHO "Changing permissions of ${_raw_device_} to -rw-rw----" >> ${_tmp_log_}
			$CHMOD 660 ${_raw_device_}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not change permissions of ${_raw_device_} to -rw-rw----"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		done
	else
		log_msg -s "No Additional LUNs specified for temp dbspaces" -l ${LOGFILE}
	fi
fi

$ECHO "\nAdding temp dbspaces..." | $TEE -a ${_tmp_log_}
$ECHO "Beginning to add temp dbspaces using command" >> ${_tmp_log_}
$ECHO "$SU - ${_sysuser_} -c \"${BASH} ${SCRIPTHOME}/add_temp_dbspaces.bsh -c ${_cli_conf_dir_} -d ${_cli_conf_dir_}/${ENIQ_INI} -s ${ENIQ_CONF_DIR}/${SYM_INI} -l ${_tmp_log_}\"" >> ${_tmp_log_}
$SU - ${_sysuser_} -c "${BASH} ${SCRIPTHOME}/add_temp_dbspaces.bsh -c ${_cli_conf_dir_} -d ${_cli_conf_dir_}/${ENIQ_INI} -s ${ENIQ_CONF_DIR}/${SYM_INI} -l ${_tmp_log_}"
if [ $? -ne 0 ]; then
	$CAT ${_tmp_log_} >> ${LOGFILE}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy ${_tmp_log_} to ${LOGFILE}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	_err_msg_="Failed to add temp DBSPACES"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
else
	$ECHO "Successfully added temp DBSPACES" | $TEE -a ${_tmp_log_}
fi

$ECHO "\nSetting DWH database db options..." | $TEE -a ${_tmp_log_}
$ECHO "Setting dwhdb options using command" >> ${_tmp_log_}
$ECHO "$SU - ${_sysuser_} -c \"${BASH} ${SCRIPTHOME}/dboptions_dwhdb.bsh -l ${_tmp_log_} -c ${_cli_conf_dir_} -d ${_cli_conf_dir_}/${ENIQ_INI}\"" >> ${_tmp_log_}

# Change ownership of sql files
$CHOWN ${_sysuser_}:${_sysgrp_} ${ENIQ_ADMIN_DIR}/sql/*
if [ $? -ne 0 ]; then
	_err_msg_="Could not change ownership of ${ENIQ_ADMIN_DIR}/sql files to ${_sysuser_}:${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$ECHO "Changing ownership of ${SCRIPTHOME}/dboptions_dwhdb.bsh to ${_sysuser_}:${_sysgrp_}" >> ${LOGFILE}
$CHOWN ${_sysuser_}:${_sysgrp_} ${SCRIPTHOME}/dboptions_dwhdb.bsh
if [ $? -ne 0 ]; then
	_err_msg_="Could not change ownership of ${SCRIPTHOME}/dboptions_dwhdb.bsh to ${_sysuser_}:${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$SU - ${_sysuser_} -c "${BASH} ${SCRIPTHOME}/dboptions_dwhdb.bsh -l ${_tmp_log_} -c ${_cli_conf_dir_} -d ${_cli_conf_dir_}/${ENIQ_INI}"
if [ $? -ne 0 ]; then
	$CAT ${_tmp_log_} >> ${LOGFILE}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy ${_tmp_log_} to ${LOGFILE}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	_err_msg_="DWH Database option setting failed"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$CAT ${_tmp_log_} >> ${LOGFILE}
if [ $? -ne 0 ]; then
	_err_msg_="Could not append ${_tmp_log_} to ${LOGFILE}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Update the service_names file with the dwh_reader_1 service
if [ "${CURR_SERVER_TYPE}" == "eniq_stats" ]; then
	log_msg -l ${LOGFILE} -q -s "Adding dwh_reader_1 information to ${_cli_conf_dir_}/service_names"
	update_service_file ${CLI_CONF_DIR}/service_names ${HOST_IP} ${HNAME} dwh_reader_1 "NULL_GRP"
	if [ $? -ne 0 ]; then
		_err_msg_="Failed to update ${CLI_CONF_DIR}/service_names with ${_reader_name_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	log_msg -l ${LOGFILE} -q -s "Changing ownership of ${CLI_CONF_DIR}/service_names to ${_sysuser_}:${_sysgrp_} after updates"
	$CHOWN ${_sysuser_}:${_sysgrp_} ${CLI_CONF_DIR}/service_names
	if [ $? -ne 0 ]; then
		_err_msg_="Failed to change ownership of ${CLI_CONF_DIR}/service_names to ${_sysuser_}:${_sysgrp_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

insert_header_footer foot "Successfully completed stage - ${NEXT_STAGE}" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: create_groups ###
#
# Creates all required Groups
#
# Arguments:
#   none
# Return Values:
#   none
create_groups()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

if [ ! -f /etc/group.orig ]; then
	$CP -p /etc/group /etc/group.orig
fi

# Handling of gid in case of extra MZ addition.
 
if [ "${CURR_SERVER_TYPE}" == "eniq_mz" ]; then
	 if [ ! -d ${ENIQ_BASE_DIR}/home ]; then
		   $ECHO "Creating ${ENIQ_BASE_DIR}/home directory" | $TEE -a ${LOGFILE}
		   $MKDIR -p ${ENIQ_BASE_DIR}/home
	 fi

	 _nas_alias_=`iniget Storage_NAS_HOME -f ${ENIQ_CONF_DIR}/${STORAGE_INI} -v NFS_HOST`
	 _nas_dir_=`iniget Storage_NAS_HOME -f ${ENIQ_CONF_DIR}/${STORAGE_INI} -v SHARE_PATH`
	 _mountpoint_=`iniget Storage_NAS_HOME -f ${ENIQ_CONF_DIR}/${STORAGE_INI} -v MOUNT_PATH`
   
	  # Flag to determine if a mount is required
		   _mount_=0

	  $ECHO "Checking if ${_mountpoint_} is already mounted" >> ${LOGFILE}
	  _mount_exists_=`$MOUNT | $GREP "${_mountpoint_}" | $AWK '{print $1}'`
		if [ ! "${_mount_exists_}" ]; then
			_mount_=1
		fi

	 if [ ${_mount_} -eq 1 ]; then 
		  $ECHO "Mounting ${_nas_alias_}:${_nas_dir_} on ${_mountpoint_}" | $TEE -a ${LOGFILE}
		  $MOUNT -t nfs -o vers=3 ${_nas_alias_}:${_nas_dir_} ${_mountpoint_} >> /dev/null 2>&1
		  if [ $? -ne 0 ]; then
			  _err_msg_="Could not mount required  ${_nas_alias_}:${_nas_dir_} on ${_mountpoint_}" 
			  abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}" 
		  fi
	 fi
fi


_update_=0

# Get a list of groups to be created
$ECHO "Getting list of required groups from ${ENIQ_CONF_DIR}/${SUNOS_INI}\n" >> ${LOGFILE}
_grp_list_=`iniget SunOS_GROUP -f ${ENIQ_CONF_DIR}/${SUNOS_INI}`
for _grp_ in ${_grp_list_}; do
	_grp_name_=`iniget ${_grp_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v name`
	_grp_id_=`iniget ${_grp_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v gid`
	$GETENT group ${_grp_name_} >> /dev/null 2>&1
	if [ $? -eq 0 ]; then
		$ECHO "Group ${_grp_name_} already created" | $TEE -a ${LOGFILE}
		continue
	fi

	$ECHO "Creating group ${_grp_name_}" | $TEE -a ${LOGFILE}
	unset _gid_str_
	if [ "${_grp_id_}" ]; then
		_gid_str_="-g ${_grp_id_}"
	else
	  if [ "${CURR_SERVER_TYPE}" == "eniq_mz" ]; then
			if [ "${_grp_name_}" == "dcdata" ]; then
				 _grp_id_=`$LS -l /eniq/home | $GREP "${_grp_name_}" | $AWK '{print $4}'`
					if [ "${_grp_id_}" ]; then
						_gid_str_="-g ${_grp_id_}"
					else
					  log_msg -l ${LOGFILE} -t -q -s "Could not evaluate gid for ${_grp_name_}"
					fi
			fi 
	  fi
	fi

	$GROUPADD ${_gid_str_} ${_grp_name_}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not create group ${_grp_name_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	_update_=1
done

if [ "${CURR_SERVER_TYPE}" == "eniq_mz" ]; then
		  # Unmounting file system
		 $ECHO "Unmounting ${_nas_alias_}:${_nas_dir_} on ${_mountpoint_}" | $TEE -a ${LOGFILE}
		 $UMOUNT -f ${ENIQ_BASE_DIR}/home >> /dev/null 2>&1
fi

if [ ${_update_} -eq 1 ]; then
	insert_header_footer foot "Successfully created groups" ${LOGFILE}
else
	insert_header_footer foot "Successfully completed core install stage - ${NEXT_STAGE}" ${LOGFILE}
fi

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: create_cep_med_nas_shares ###
#
# Share NAS filesystems for the CEP Mediation servers
# (storage vlan ip read from cep_mediation.ini)
#
# Arguments:
#   none
# Return Values:
#   none
create_cep_med_nas_shares()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" == "fs" ]; then
	insert_header_footer foot "FS Install - Skipping core install stage - ${NEXT_STAGE} " ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

if [ ! -s ${ENIQ_CONF_DIR}/${CEP_MED_INI} ]; then
	_err_msg_="CEP Mediation ini file ${ENIQ_CONF_DIR}/${CEP_MED_INI} not found"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Check if the CEP_MEDIATION_INCLUDED parameter ADD_CEP_MED
# If yes then create the shares for CEP Mediation
# If no then CEP MEDIATION is not being used and do not create the shares
_add_cep_med_=`iniget CEP_MEDIATION_INCLUDED -f ${ENIQ_CONF_DIR}/${CEP_MED_INI} -v ADD_CEP_MED`
if [ ! "${_add_cep_med_}" ]; then
	_err_msg_="ADD_CEP_MED not set in ${ENIQ_CONF_DIR}/${CEP_MED_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ "${_add_cep_med_}" == "No" ]; then
	insert_header_footer foot "ADD_CEP_MED set to No - Skipping core install stage - ${NEXT_STAGE} " ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

# Get the System User/Group. All directories are owned by this
_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysgrp_=`$ID ${_sysuser_} | $AWK '{print $2}' | $AWK -F\( '{print $2}' | $AWK -F\) '{print $1}'`
if [ ! "${_sysgrp_}" ]; then
	_err_msg_="Could not determine group ID of ${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_cli_conf_dir_=`$CAT ${ENIQ_CONF_DIR}/${ENIQ_ENV} | $EGREP "^[[:blank:]]*CONF_DIR=" | $AWK -F\= '{print $2}' | $SED -e 's|"||g'`
if [ ! "${_cli_conf_dir_}" ]; then
	_err_msg_="Could not read CONF_DIR parameter from ${ENIQ_CONF_DIR}/${ENIQ_ENV}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_nas_sw_target_dir_=`iniget NAS_STORAGE_API -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v NAS_API_TARGET_DIR`
if [ ! "${_nas_sw_target_dir_}" ]; then
	_err_msg_="Failed to get NAS API target dir information from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_nascli_=${_nas_sw_target_dir_}/bin/nascli
if [ ! -s ${_nascli_} ]; then
	_err_msg_="${_nascli_} not found"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_cep_med_list_=`iniget CEP_MEDIATION -f ${ENIQ_CONF_DIR}/${CEP_MED_INI}`
if [ ! "${_cep_med_list_}" ]; then
	_err_msg_="Could not get a list of CEP Mediation servers"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

for _cm_ in ${_cep_med_list_}; do
	_cep_med_hostname_=`iniget ${_cm_} -f ${ENIQ_CONF_DIR}/${CEP_MED_INI} -v CEP_MED_HOSTNAME`
	_cep_med_serv_ip_=`iniget ${_cm_} -f ${ENIQ_CONF_DIR}/${CEP_MED_INI} -v SERVICES_IP`
	_cep_med_stor_ip_=`iniget ${_cm_} -f ${ENIQ_CONF_DIR}/${CEP_MED_INI} -v STORAGE_IP`
	_cep_med_alias_=`iniget ${_cm_} -f ${ENIQ_CONF_DIR}/${CEP_MED_INI} -v ALIAS`
	if [ ! "${_cep_med_serv_ip_}" -o ! "${_cep_med_stor_ip_}" -o ! "${_cep_med_hostname_}" -o ! "${_cep_med_alias_}" ]; then
		_err_msg_="Could not read required parameters for ${_cm_} from ${ENIQ_CONF_DIR}/${CEP_MED_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	$ECHO "\nAdding ${_cep_med_stor_ip_} as a client of NAS for ${_cm_}" | $TEE -a ${LOGFILE}
	${_nascli_} add_client - ${_cep_med_stor_ip_} - -
	if [ $? -ne 0 ]; then
		_err_msg_="Problem encountered adding ${_cep_med_stor_ip_} as a client of NAS\n"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	# Add the cep mediation services to the service_names file
	$ECHO "Updating ${_cli_conf_dir_}/service_names with ${_cep_med_alias_} information" >> ${LOGFILE}
	update_service_file ${_cli_conf_dir_}/service_names ${_cep_med_serv_ip_} ${_cep_med_hostname_} ${_cep_med_alias_} "NULL_GRP"
	if [ $? -ne 0 ]; then
		_err_msg_="Failed to update ${_cli_conf_dir_}/service_names with cep mediation services"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	$ECHO "Changing ownership of ${_cli_conf_dir_}/service_names to ${_sysuser_}:${_sysgrp_} after adding ${_cep_med_alias_}" >> ${LOGFILE}
	$CHOWN ${_sysuser_}:${_sysgrp_} ${_cli_conf_dir_}/service_names
	if [ $? -ne 0 ]; then
		_err_msg_="Failed to change ownership of ${_cli_conf_dir_}/service_names to ${_sysuser_}:${_sysgrp_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
done

insert_header_footer foot "Successfully completed stage - ${NEXT_STAGE}" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: create_iq_interf ###
#
# Create the SYBASE IQ interfaces file
#
# Arguments:
#	   none
# Return Values:
#	   none
create_iq_interf()
{
_iqdir_=$1
if [ ! -d ${_iqdir_} ]; then
	_err_msg_="Could not locate Sybase IQ directory ${_iqdir_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ! -s  ${ENIQ_TEMPL_DIR}/interfaces ]; then
	_err_msg_="Could not locate ${ENIQ_TEMPL_DIR}/interfaces"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_dwh_port_num_=`iniget DWH -f ${ENIQ_CONF_DIR}/${ENIQ_INI} -v PortNumber`
if [ ! "${_dwh_port_num_}" ]; then
	_err_msg_="Could not read DWH Port Number from ${ENIQ_CONF_DIR}/${ENIQ_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_rep_port_num_=`iniget REP -f ${ENIQ_CONF_DIR}/${ENIQ_INI} -v PortNumber`
if [ ! "${_rep_port_num_}" ]; then
	_err_msg_="Could not read REP Port Number from ${ENIQ_CONF_DIR}/${ENIQ_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$CAT ${ENIQ_TEMPL_DIR}/interfaces |$SED -e "s|<CHANGE><DWH_PORT_NUM>|${_dwh_port_num_}|g"   \
							  -e "s|<CHANGE><REP_PORT_NUM>|${_rep_port_num_}|g" \
	> ${TEM_DIR}/interfaces

if [ $? -ne 0 ]; then
	_err_msg_="Could not create Sybase IQ Interfaces File"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$CP ${TEM_DIR}/interfaces ${_iqdir_}
if [ $? -ne 0 ]; then
	_err_msg_="Could not copy Sybase IQ Interfaces File to ${_iqdir_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
}

### Function: create_iq_mpx ###
#
# Change IQ to a multiplex DB
#
# Arguments:
#	   none
# Return Values:
#	   none
create_iq_mpx()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

_reader_name_="dwh_reader_1"

# Check required files and scripts exist
if [ ! -s ${CLI_CONF_DIR}/niq.rc ]; then
	_err_msg_="File ${CLI_CONF_DIR}/niq.rc not found, or is empty"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
else
	log_msg -l ${LOGFILE} -q -s "Sourcing ${CLI_CONF_DIR}/niq.rc"
	. ${CLI_CONF_DIR}/niq.rc
fi

if [ ! -s ${IQ_DIR}/IQ.sh ]; then
	_err_msg_="${IQ_DIR}/IQ.sh script not found, or is empty"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
else
	log_msg -l ${LOGFILE} -q -s "Sourcing information from ${IQ_DIR}/IQ.sh"
	. ${IQ_DIR}/IQ.sh
fi

if [ ! -s ${ENIQ_ADMIN_BIN_DIR}/dwhdb ]; then
	_err_msg_="${ENIQ_ADMIN_BIN_DIR}/dwhdb script not found, or is not executable"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ! -s ${SCRIPTHOME}/create_reader.bsh ]; then
	_err_msg_="${SCRIPTHOME}/create_reader.bsh script not found"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ! -s ${SCRIPTHOME}/update_hosts_file.bsh ]; then
	_err_msg_="Failed to find ${SCRIPTHOME}/update_hosts_file.bsh"
	   abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysgrp_=`$ID ${_sysuser_} | $AWK '{print $2}' | $AWK -F\( '{print $2}' | $AWK -F\) '{print $1}'`
if [ ! "${_sysgrp_}" ]; then
	_err_msg_="Could not determine group ID of ${_sysuser_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

log_msg -l ${LOGFILE} -q -s "\nChanging ownership of ${SCRIPTHOME}/create_reader.bsh to ${_sysuser_}:${_sysgrp_}"
$CHOWN ${_sysuser_}:${_sysgrp_} ${SCRIPTHOME}/create_reader.bsh
if [ $? -ne 0 ]; then
	_err_msg_="Could not change ownership of ${SCRIPTHOME}/create_reader.bsh to ${_sysuser_}:${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi



# Verify that the alias name can be resolved
log_msg -s "\nPerforming ping test on ${_reader_name_} ..." -l ${LOGFILE}
$PING -c 1 ${_reader_name_} >> /dev/null 2>&1
if [ $? -ne 0 ]; then
	log_msg -s "Unable to resolve alias name. Updating /etc/hosts" -l ${LOGFILE}
	log_msg -l ${LOGFILE} -q -s "Updating host file as work round to resolve reader name"
	log_msg -s "Updating host file with the following entries - ${HOST_IP} ${HNAME} ${_reader_name_}" -l ${LOGFILE}
	$CP /etc/hosts ${TEM_DIR}/hosts.${_reader_name_}
	if [ $? -ne 0 ]; then
		_err_msg_="Failed to backup /etc/hosts file"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	$ECHO "${HOST_IP} ${HNAME} ${_reader_name_}" >> /etc/hosts
	if [ $? -ne 0 ]; then
		_err_msg_="Problem  Adding ${HOST_IP} ${HNAME} ${_reader_name_} to /etc/hosts"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

else
	log_msg -s "Alias name successfully resolved." -l ${LOGFILE}
fi

# Ensure dwhdb is online
$SU - ${_sysuser_} -c "${ENIQ_ADMIN_BIN_DIR}/dwhdb start"
if [ $? -ne 0 ]; then
	restore_hosts_file ${TEM_DIR}/hosts.${_reader_name_}
	_err_msg_="DWH database failed to start"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
else
	log_msg -s "\nDWH database coordinator successfully started" -l ${LOGFILE}
fi

_tmp_log_=${TEM_DIR}/reader_create.log
$TOUCH -a ${_tmp_log_}
$CHOWN ${_sysuser_}:${_sysgrp_} ${_tmp_log_}
if [ $? -ne 0 ]; then
	restore_hosts_file ${TEM_DIR}/hosts.${_reader_name_}
	_err_msg_="Could not change ownership of ${_tmp_log_} to ${_sysuser_}:${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Create the first reader instance
log_msg -s "\nCreating initial reader..." -l ${LOGFILE}
log_msg -l ${LOGFILE} -q -s "Calling reader creation script using command"
log_msg -l ${LOGFILE} -q -s "$SU - ${_sysuser_} -c \"${BASH} ${SCRIPTHOME}/create_reader.bsh -l ${_tmp_log_} -c ${CLI_CONF_DIR} -d ${CLI_CONF_DIR}/${ENIQ_INI} -r ${_reader_name_} -s ${ENIQ_CONF_DIR}/${SYM_INI}\""
$SU - ${_sysuser_} -c "${BASH} ${SCRIPTHOME}/create_reader.bsh -l ${_tmp_log_} -c ${CLI_CONF_DIR} -d ${CLI_CONF_DIR}/${ENIQ_INI} -r ${_reader_name_} -s ${ENIQ_CONF_DIR}/${SYM_INI}"
if [ $? -ne 0 ]; then
	restore_hosts_file ${TEM_DIR}/hosts.${_reader_name_}
	$CAT ${_tmp_log_} >> ${LOGFILE}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy ${_tmp_log_} to ${LOGFILE}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	_err_msg_="Failed to create IQ reader multiplex"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

restore_hosts_file ${TEM_DIR}/hosts.${_reader_name_}
insert_header_footer foot "Successfully completed core install stage - ${NEXT_STAGE}" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: create_lun_map ###
#
# Create LUN MAP ini file
#
# Arguments:
#   none
# Return Values:
#   none
create_lun_map()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" == "fs" ]; then
	insert_header_footer foot "FS Install - Skipping core install stage - ${NEXT_STAGE} " ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

if [ -s ${ENIQ_CONF_DIR}/${SUNOS_INI} ]; then
	_ini_src_dir_=${ENIQ_CONF_DIR}
	_ini_file_=${SUNOS_INI}
else
	_ini_src_dir_=${ENIQ_TEMPL_DIR}
	_ini_file_="${SUNOS_INI}_${SAN_DEVICE}"
fi


# Read location of storage API command
_stor_api_cmd_=`iniget STOR_API -f ${_ini_src_dir_}/${_ini_file_} -v STOR_API_CMD`
if [ ! "${_stor_api_cmd_}" ]; then
	_err_msg_="Could not read STOR_API_CMD param from ${_ini_src_dir_}/${_ini_file_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ! -x ${_stor_api_cmd_} ]; then
	_err_msg_="${_stor_api_cmd_} is not found or is not executable"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Create a formatted list of available LUNS
DISK_LIST=/tmp/disk_list
create_disk_list ${DISK_LIST}
if [ $? -ne 0 ]; then
	_err_msg_="Error getting formatted list of disks for Lun Map ini creation"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

for (( _count_=0;${_count_}<2;_count_++ ));do
	$RM -f ${TEM_DIR}/listluns.txt
	${_stor_api_cmd_} --action listluns >> ${TEM_DIR}/listluns.txt
	if [ $? -ne 0 ]; then
		# exit from script if return code non-zero
		_err_msg_="Couldn't get list of LUNs."
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	else
		# check if listluns.txt has content in case return code is zero
		if [ ! -s ${TEM_DIR}/listluns.txt ]; then
			continue
		fi
	fi
	break
done

if [ ! -s ${TEM_DIR}/listluns.txt ]; then
	_err_msg_="Error getting list of luns for Lun Map ini creation"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Create the LUN MAP iniial template
$RM -f ${TEM_DIR}/${LUN_MAP_INI}
$ECHO -e "[LUN_MAP_DETAILS]\n" >> ${TEM_DIR}/${LUN_MAP_INI}

_cnt_=1
# Add each disk detail to lun map ini
while read _disk_details_; do
	_disk_id_=`$ECHO ${_disk_details_}|$AWK -F\@ '{print $1}'`
	_hba_=`$ECHO ${_disk_details_}|$AWK -F\@ '{print $2}'`
	_size_=`$ECHO ${_disk_details_}|$AWK -F\@  '{print $3}'|$AWK '{print $1}'|$AWK -F\. '{print $1}'`
	_vendor_=`$ECHO ${_disk_details_}|$AWK -F\@ '{print $4}'`
	_prod_det_=`$ECHO ${_disk_details_}|$AWK -F\@ '{print $5}'`

	_lun_map_det_=`$EGREP -i -w ${_disk_id_} ${TEM_DIR}/listluns.txt`
	if [ "${_lun_map_det_}" ]; then
		_lun_id_=`$ECHO ${_lun_map_det_}|$AWK -F\; '{print $1}'`
		_lun_desc_=`$ECHO ${_lun_map_det_}|$AWK -F\; '{print $3}'`
	else
		_lun_id_="local"
		_lun_desc_="none"
	fi

	$RM -f ${TEM_DIR}/lun_map_ins_det
	$ECHO "[LUN_MAP_DETAILS_${_cnt_}]" >> ${TEM_DIR}/lun_map_ins_det
	$ECHO "DISK_ID=${_disk_id_}" >> ${TEM_DIR}/lun_map_ins_det
	$ECHO "HBA=${_hba_}" >> ${TEM_DIR}/lun_map_ins_det
	$ECHO "SIZE=${_size_}" >> ${TEM_DIR}/lun_map_ins_det
	$ECHO "VENDOR=${_vendor_}" >> ${TEM_DIR}/lun_map_ins_det
	$ECHO "PRODUCT_DETAIL=${_prod_det_}" >> ${TEM_DIR}/lun_map_ins_det
	$ECHO "LUN_ID=${_lun_id_}" >> ${TEM_DIR}/lun_map_ins_det
	$ECHO "LUN_DESC=${_lun_desc_}" >> ${TEM_DIR}/lun_map_ins_det
	$ECHO "LINK=" >> ${TEM_DIR}/lun_map_ins_det

	$RM -f ${TEM_DIR}/${LUN_MAP_INI}_temp
	$ECHO "Updating ${ENIQ_CONF_DIR}/${LUN_MAP_INI} with LUN_MAP_DETAILS_${_cnt_}" >> ${LOGFILE}

	${INIADD} -g LUN_MAP_DETAILS -p LUN_MAP_DETAILS_${_cnt_} -i ${TEM_DIR}/${LUN_MAP_INI} -d ${TEM_DIR}/lun_map_ins_det -o ${TEM_DIR}/${LUN_MAP_INI}_temp
	if [ $? -ne 0 ]; then
		_err_msg_="Error adding LUN_MAP_DETAILS_${_cnt_} to ${ENIQ_CONF_DIR}/${LUN_MAP_INI}"
		abort_script "${_err_msg_}"
	fi

	$CP ${TEM_DIR}/${LUN_MAP_INI}_temp ${TEM_DIR}/${LUN_MAP_INI}
	if [ $? -ne 0 ]; then
		_err_msg_="Error appending ini LUN_MAP_DETAILS_${_cnt_} details to ${ENIQ_CONF_DIR}/${LUN_MAP_INI}"
		abort_script "${_err_msg_}"
	fi

	let _cnt_=_cnt_+1
done <${DISK_LIST}

$CP ${TEM_DIR}/${LUN_MAP_INI} ${ENIQ_CONF_DIR}/${LUN_MAP_INI}
if [ $? -ne 0 ]; then
	_err_msg_="Error copying temporary ini file to ${ENIQ_CONF_DIR}/${LUN_MAP_INI}"
	abort_script "${_err_msg_}"
fi

insert_header_footer foot "Successfully created LUN Map ini file" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: create_nas_filesystems ###
#
# Create filesystems on NAS
#
# Arguments:
#   none
# Return Values:
#   none
create_nas_filesystems()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" == "fs" ]; then
	insert_header_footer foot "FS Install - Skipping core install stage - ${NEXT_STAGE} " ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

_nas_sysid_=`iniget Storage_NAS_GENERAL -f ${ENIQ_CONF_DIR}/${STORAGE_INI} -v SYS_ID`
if [ ! "${_nas_sysid_}" ]; then
	_err_msg_="Could not get NAS sysid value from ${ENIQ_CONF_DIR}/${STORAGE_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_nas_sw_target_dir_=`iniget NAS_STORAGE_API -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v NAS_API_TARGET_DIR`
if [ ! "${_nas_sw_target_dir_}" ]; then
	_err_msg_="Failed to get NAS API target dir information from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ! -s ${_nas_sw_target_dir_}/plugins/nas/etc/nasplugin.conf_template ]; then
	_err_msg_="${_nas_sw_target_dir_}/plugins/nas/etc/nasplugin.conf_template not found, or is empty"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Set a variable for the number of SFS LUNs
_nas_sysid_=`iniget Storage_NAS_GENERAL -f ${ENIQ_CONF_DIR}/${STORAGE_INI} -v SYS_ID`
if [ ! "${_nas_sysid_}" ]; then
	_err_msg_="Could not get NAS sysid value from ${ENIQ_CONF_DIR}/${STORAGE_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Fetch the SFS version
_SFS_version_=`$CAT ${_NAS_PLUGINS_LOC}/nasplugin.conf |$GREP SFS_VERSION | $AWK -F"=" '{print $2}'`

if [ $? -ne 0 ]; then
	_err_msg_="Failed to fetch the SFS version form the file ${_NAS_PLUGINS_LOC}/nasplugin.conf "
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# If SFS version is 7.4 then login to support user and do switch to master to get the storage pool list 
if [ ${_SFS_version_} == 7.4 ]; then
	_num_disks_=`${SU} - storadm -c "${SSH} -o StrictHostKeyChecking=no -n support@nasconsole '/opt/VRTSnas/clish/bin/clish -u master -c '\''storage pool list'\'''"|${EGREP} "^[[:blank:]]*${_nas_sysid_}[[:blank:]]+"|${WC} -w`

	if [ $? -ne 0 ]; then
		_err_msg_="Error executing \"storage pool list\" on NAS or command not found"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	
else

	_num_disks_=`${SU} - storadm -c "${SSH} -o StrictHostKeyChecking=no -n master@nasconsole storage pool list"|${EGREP} "^[[:blank:]]*${_nas_sysid_}[[:blank:]]+"|${WC} -w`

	if [ $? -ne 0 ]; then
		_err_msg_="Error executing \"storage pool list\" on NAS or command not found"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi	
_num_cols_=0
if [ "${_num_disks_}" ]; then
	_num_disks_=`expr ${_num_disks_} - 1`
	if [ ${_num_disks_} -ge 2 ]; then
		_num_cols_=${_num_disks_}
	fi
else
	_err_msg_="storage pool list returned nothing"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ${_num_cols_} -ne 0 ]; then
	core_install_set_stripe_width ${LOGFILE} ${TEM_DIR} ${_num_cols_} ${_nas_sw_target_dir_}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not set stripe width for SFS"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi


_nascli_=${_nas_sw_target_dir_}/bin/nascli
if [ ! -s ${_nascli_} ]; then
	_err_msg_="${_nascli_} not found"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$ECHO "\nCreating NAS filesystems using values in ${ENIQ_CONF_DIR}/${STORAGE_INI}" | $TEE -a ${LOGFILE}
${_nascli_} create_fs - - - -
if [ $? -ne 0 ]; then
	_err_msg_="Problem encountered creating NAS filesystems"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

insert_header_footer foot "Successfully created filesystems on NAS" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: create_nas_shares ###
#
# Share NAS filesystems to storage VLAN
#
# Arguments:
#   none
# Return Values:
#   none
create_nas_shares()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" == "fs" ]; then
	insert_header_footer foot "FS Install - Skipping core install stage - ${NEXT_STAGE} " ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

if [ -s ${ENIQ_CONF_DIR}/extra_params/deployment ]; then
	_deployment_=`$CAT ${ENIQ_CONF_DIR}/extra_params/deployment`
else
	_err_msg_="Parameter \"deployment\" incorrectly specified, or is missing from boot command"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_nas_sw_target_dir_=`iniget NAS_STORAGE_API -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v NAS_API_TARGET_DIR`
if [ ! "${_nas_sw_target_dir_}" ]; then
	_err_msg_="Failed to get NAS API target dir information from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_nascli_=${_nas_sw_target_dir_}/bin/nascli
if [ ! -s ${_nascli_} ]; then
	_err_msg_="${_nascli_} not found"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ "${_deployment_}" == "ft" ]; then
	# we only configure 1 vlan i.e. the oss services vlan
	_intf_list_=`iniget IPMP -f ${ENIQ_CONF_DIR}/${IPMP_INI} | $HEAD -1`
	if [ ! "${_intf_list_}" ]; then
		_err_msg_="Could not build a list of IPMP blocks from ${ENIQ_CONF_DIR}/${IPMP_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
else
	# we configured both services and storage vlans
	_intf_list_=`iniget IPMP -f ${ENIQ_CONF_DIR}/${IPMP_INI}`
	if [ ! "${_intf_list_}" ]; then
		_err_msg_="Could not build a list of IPMP blocks from ${ENIQ_CONF_DIR}/${IPMP_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

for _intf_ in ${_intf_list_}; do
	_vlan_name_=`iniget ${_intf_} -f ${ENIQ_CONF_DIR}/${IPMP_INI} -v IPMP_Group_Name`
	if [ ! "${_vlan_name_}" ]; then
		_err_msg_="Could not read IPMP_Group_Name for ${_intf_} in ${ENIQ_CONF_DIR}/${IPMP_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	if [ "${_deployment_}" != "ft" ]; then
		if [ "${_vlan_name_}" != "stor_grp" ]; then
			continue
		fi
	fi

	_intf_ip_=`iniget ${_intf_} -f ${ENIQ_CONF_DIR}/${IPMP_INI} -v IPMP_Group_IP`
	if [ ! "${_intf_ip_}" ]; then
		_err_msg_="Could not read IPMP_Group_IP value for ${_intf_} in ${ENIQ_CONF_DIR}/${IPMP_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	# Reading value of IPMP_Group_Netmask from /eniq/installation/config/ipmp.ini
	_net_mask_ip_=`iniget ${_intf_} -f ${ENIQ_CONF_DIR}/${IPMP_INI} -v IPMP_Group_Netmask`
	if [ ! "${_net_mask_ip_}" ]; then
		_err_msg_="Could not read IPMP_Group_Netmask value for ${_intf_} in ${ENIQ_CONF_DIR}/${IPMP_INI}"
		abort_script "$_err_msg_"
	fi

	# Generating subnet value using NetMask IP
	_subnet_=`get_network_from_netmask ${_net_mask_ip_}`
	if [ ! "${_subnet_}" ]; then
		  _err_msg_="Could not generate subnet value using NetMask IP"
		  abort_script "$_err_msg_"
	fi

   if [ "${_vlan_name_}" != "stor_grp" ]; then
		# Reading Network IP from /etc/netmasks
		_network_ip_=`$CAT /etc/netmasks | $GREP ${_net_mask_ip_} | $EGREP -v "#" | $AWK -F " " '{print $1}'`
		if [ ! "${_network_ip_}" ]; then
			_err_msg_="Could not read network IP from /etc/netmasks"
			abort_script "$_err_msg_"
		fi
   else
		# Reading Network IP from ipmp ini
		_network_ip_=`iniget STOR_NETMASK -f ${ENIQ_CONF_DIR}/${IPMP_INI} -v NETMASKS | $CUT -d":" -f1`
		if [ ! "${_network_ip_}" ]; then
			_err_msg_="Could not read Network IP from ${ENIQ_CONF_DIR}/${IPMP_INI}"
			abort_script "$_err_msg_"
		fi
   fi

	# Sharing NFS over the subnet
	log_msg -l ${LOGFILE} -s "Adding ${_network_ip_}/${_subnet_} as a client of NAS"
	${_nascli_} add_client - ${_network_ip_}/${_subnet_} - -
	if [ $? -ne 0 ]; then
		_err_msg_="Problem encountered adding ${_network_ip_}/${_subnet_} as a client of NAS"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

done

insert_header_footer foot "Successfully shared NAS filesystems to storage VLAN" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: create_nas_users ###
#
#
# Arguments:
#	   none
# Return Values:
#	   none
create_nas_users()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" == "fs" ]; then
	insert_header_footer foot "FS Install - Skipping core install stage - ${NEXT_STAGE} " ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

if [ -s ${ENIQ_CONF_DIR}/${SUNOS_INI} ]; then
	_ini_src_dir_=${ENIQ_CONF_DIR}
	_ini_file_=${SUNOS_INI}
else
	_ini_src_dir_=${ENIQ_TEMPL_DIR}
	_ini_file_="${SUNOS_INI}_${SAN_DEVICE}"
fi

_nas_sw_target_dir_=`iniget NAS_STORAGE_API -f ${_ini_src_dir_}/${_ini_file_} -v NAS_API_TARGET_DIR`
if [ ! "${_nas_sw_target_dir_}" ]; then
	_err_msg_="Failed to get NAS API target dir information from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Check required files and scripts exist
if [ ! -x ${_nas_sw_target_dir_}/bin/create_nas_users.sh ]; then
	_err_msg_="File ${_nas_sw_target_dir_}/bin/create_nas_users.sh not found or not executable"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

log_msg -s "Creating NAS users" -l ${LOGFILE}
log_msg -s "with command: ${_nas_sw_target_dir_}/bin/create_nas_users.sh" -q -l ${LOGFILE}
${_nas_sw_target_dir_}/bin/create_nas_users.sh
if [ $? -ne 0 ]; then
	_err_msg_="${_nas_sw_target_dir_}/bin/create_nas_users.sh exited due to an error"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Change the permissions of the storage dir
change_stor_perms "${_ini_src_dir_}/${_ini_file_}" "${ENIQ_CORE_INST_DIR}/etc/nas_plugin_perms.cfg" ${LOGFILE}
if [ $? -ne 0 ]; then
	_err_msg_="Failed to update permissions for storage dir"
	abort_script "${_err_msg_}"
fi

insert_header_footer foot "Successfully completed stage - ${NEXT_STAGE}" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: create_db_sym_links ###
#
# Creates all symlinks
#
# Arguments:
#   none
# Return Values:
#   none
create_db_sym_links()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" == "fs" ]; then
	insert_header_footer foot "FS Install - No DB Sym links to be created" ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

# Get the System User/Group. All directories are owned by this
_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysgrp_=`$ID ${_sysuser_} | $AWK '{print $2}' | $AWK -F\( '{print $2}' | $AWK -F\) '{print $1}'`
if [ ! "${_sysgrp_}" ]; then
	_err_msg_="Could not determine group ID of ${_sysuser_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Check required files and scripts exist
if [ ! -s ${ENIQ_CONF_DIR}/${SYM_INI} ]; then
	_err_msg_="File ${ENIQ_CONF_DIR}/${SYM_INI} not found, or is empty"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sys_main_db_list_=`iniget DWH_SYSTEM_MAIN -f ${ENIQ_CONF_DIR}/${SYM_INI}`
if [ ! "${_sys_main_db_list_}" ]; then
	_err_msg_="Could not read DWH_SYSTEM_MAIN from ${ENIQ_CONF_DIR}/${SYM_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_main_db_list_=`iniget DWH_DBSPACES_MAIN -f ${ENIQ_CONF_DIR}/${SYM_INI}`
if [ ! "${_main_db_list_}" ]; then
	_err_msg_="Could not read DWH_DBSPACES_MAIN from ${ENIQ_CONF_DIR}/${SYM_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_temp_db_list_=`iniget DWH_DBSPACES_TEMP -f ${ENIQ_CONF_DIR}/${SYM_INI}`
if [ ! "${_temp_db_list_}" ]; then
	_err_msg_="Could not read DWH_DBSPACES_TEMP from ${ENIQ_CONF_DIR}/${SYM_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Check for udev rules file if exist or not
if [ ! -f ${UDEV_FILE} ]; then
	err_msg_="UDEV rules files does not exist"
	abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
fi

# Activate the raw device created in udev rules
$UDEVADM  control --reload-rules
if [ $? -ne 0 ]; then
	_err_msg_="Could not reload udev rules for raw device"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
$UDEVADM  trigger --type=devices --action=change
if [ $? -ne 0 ]; then
	_err_msg_="Could not trigger udev rules for raw device"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$SLEEP 5

# Check if the raw devices are created or not
_count_=0
while :; do
	
	$RAW -qa | $GREP raw >> /dev/null 2>&1
	if [ $? -eq 0 ]; then
		break
	else
		$SLEEP 1
		_count_=`$EXPR ${_count_} + 1`
		if [ ${_count_} -eq 10 ]; then
			err_msg_="Could not create raw device"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
		continue
	fi
done


_full_db_list_="${_main_db_list_} ${_temp_db_list_} ${_sys_main_db_list_}"
for _db_ in ${_full_db_list_}; do
	# Read the Path
	_db_path_=`iniget ${_db_} -f ${ENIQ_CONF_DIR}/${SYM_INI} -v Path`
	if [ ! "${_db_path_}" ]; then
		_err_msg_="Could not read path paramater for ${_db_} in ${ENIQ_CONF_DIR}/${SYM_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	# Read the Link
	_db_link_=`iniget ${_db_} -f ${ENIQ_CONF_DIR}/${SYM_INI} -v Link`
	if [ ! "${_db_link_}" ]; then
		_err_msg_="Could not read link paramater for ${_db_} in ${ENIQ_CONF_DIR}/${SYM_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	# Does the actual RAW device exist?? Might not be shared from Storage Group to host
	if [ ! -c "${_db_link_}" ]; then
		_err_msg_="${_db_link_} device path does not exist"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	# Does Path exist already
	$LS ${_db_path_} >> /dev/null 2>&1
	if [ $? -eq 0 ]; then
		if [ "$RESTORE" ]; then
			$RM ${_db_path_} >> /dev/null 2>&1
		else
			if [ ! -h ${_db_path_} ]; then
				_err_msg_="${_db_path_} is not a Symbolic link"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			_chk_link_=`$LS -l ${_db_path_} | $AWK '{print $NF}'`
			if [ "${_chk_link_}" != "${_db_link_}" ]; then
				_err_msg_="DB Symlink ${_db_path_} already exists but points at incorrect device"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			# Change Ownership of symbolic Link
			$ECHO -e "Changing ownership of ${_db_path_} to ${_sysuser_}:${_sysgrp_}" | $TEE -a ${LOGFILE}
			$CHOWN -h ${_sysuser_}:${_sysgrp_} ${_db_path_}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not change ownership of ${_db_path_} to ${_sysuser_}:${_sysgrp_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			
			cd $SCRIPTHOME
			
			continue
		fi
	fi

	# Make the symbolic Link
	$ECHO -e "Creating symbolic link between ${_db_link_} and ${_db_path_}" | $TEE -a ${LOGFILE}
	$LN -s ${_db_link_} ${_db_path_} >> /dev/null 2>&1
	if [ $? -ne 0 ]; then
		_err_msg_="Could not create symlink between ${_db_link_} and ${_db_path_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	# Change Ownership of symbolic Link
	$ECHO -e "Changing ownership of ${_db_path_} to ${_sysuser_}:${_sysgrp_}" | $TEE -a ${LOGFILE}
	$CHOWN -h ${_sysuser_}:${_sysgrp_} ${_db_path_}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not change ownership of ${_db_path_} to ${_sysuser_}:${_sysgrp_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	cd $SCRIPTHOME
   
done

insert_header_footer foot "Successfully created DB Sym Links" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: create_reader_mpx ###
#
# Create a reader instance for IQ multiplex
#
# Arguments:
#	   none
# Return Values:
#	   none
create_reader_mpx()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

_exit_stage_=0

if [ -s ${ENIQ_CONF_DIR}/extra_params/deployment ]; then
	_deployment_=`$CAT ${ENIQ_CONF_DIR}/extra_params/deployment`
else
	_err_msg_="Parameter \"deployment\" incorrectly specified, or is missing from boot command"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ! -s ${ENIQ_ADMIN_DIR}/etc/smf_contract_config ]; then
	_err_msg_="Parameter \"deployment\" incorrectly specified, or is missing from boot command"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ "${CURR_SERVER_TYPE}" == "eniq_ui" -a "${RESTORE}" ]; then
	# Am i a reader
	SERVER_NAME=`/usr/bin/hostname`
	IP_ADDRESS=`$GETENT hosts ${SERVER_NAME} | $AWK '{print $1}' | $SORT -u`
	READER_ALIAS=`$CAT ${CLI_CONF_DIR}/service_names | $GREP "${IP_ADDRESS}" | $GREP "dwh_" | $AWK -F"::" '{print $3}'`
	if [ ${READER_ALIAS} ]; then
		$ECHO "${READER_ALIAS}::${IP_ADDRESS}" >> ${ENIQ_CONF_DIR}/.reader_info
	fi
fi

if [ "${CURR_SERVER_TYPE}" == "eniq_ui" -a -s ${ENIQ_CONF_DIR}/.reader_info ]; then
	log_msg -l ${LOGFILE} -q -s "Setting up files for reader instance on this server"
	$CAT ${ENIQ_ADMIN_DIR}/etc/smf_contract_config | $SED -e "s|${CURR_SERVER_TYPE}::ENIQ::dwh_reader::N|${CURR_SERVER_TYPE}::ENIQ::dwh_reader::Y|g" > ${TEM_DIR}/smf_config.$$
	$CP ${TEM_DIR}/smf_config.$$ ${ENIQ_ADMIN_DIR}/etc/smf_contract_config
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy ${TEM_DIR}/smf_config.$$ to ${ENIQ_ADMIN_DIR}/etc/smf_contract_config"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	_exit_stage_=0
else
	_exit_stage_=1
fi

if [ "${CURR_SERVER_TYPE}" == "eniq_iqr" -o "${CURR_SERVER_TYPE}" == "stats_iqr" ]; then
	_exit_stage_=0
fi

if [ "${_exit_stage_}" -eq 1 ]; then
	log_msg -s "\nNo reader instance to be installed on this server" -l ${LOGFILE}
	insert_header_footer foot "Successfully completed stage - ${NEXT_STAGE}" ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

# Check required files and scripts exist
if [ ! -s ${CLI_CONF_DIR}/niq.rc ]; then
	_err_msg_="File ${CLI_CONF_DIR}/niq.rc not found, or is empty"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
else
	log_msg -l ${LOGFILE} -q -s "Sourcing ${CLI_CONF_DIR}/niq.rc"
	. ${CLI_CONF_DIR}/niq.rc
fi

if [ ! -s ${CLI_CONF_DIR}/service_names ]; then
	_err_msg_="File ${CLI_CONF_DIR}/service_names not found, or is empty"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ! -s ${SCRIPTHOME}/create_reader.bsh ]; then
	_err_msg_="${SCRIPTHOME}/create_reader.bsh script not found"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ! -s ${SCRIPTHOME}/add_reader_temp_dbspace.bsh ]; then
	_err_msg_="${SCRIPTHOME}/add_reader_temp_dbspace.bsh script not found"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ! -s ${ENIQ_ADMIN_BIN_DIR}/dwh_reader ]; then
	_err_msg_="${ENIQ_ADMIN_BIN_DIR}/dwh_reader script not found, or is not executable"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysgrp_=`$ID ${_sysuser_} | $AWK '{print $2}' | $AWK -F\( '{print $2}' | $AWK -F\) '{print $1}'`
if [ ! "${_sysgrp_}" ]; then
	_err_msg_="Could not determine group ID of ${_sysuser_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Create an IQ log dir
$MKDIR -p ${ENIQ_LOG_DIR}/iq
$CHOWN ${_sysuser_}:${_sysgrp_} ${ENIQ_LOG_DIR}/iq
if [ $? -ne 0 ]; then
	_err_msg_="Could not change ownership of ${ENIQ_LOG_DIR}/iq to ${_sysuser_}:${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Check mountpoints and mount if not there
mount_req_dirs install_sybaseiq
if [ $? -ne 0 ]; then
	_err_msg_="Could not mount required directories for \"install_sybaseiq\""
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Check required files and scripts exist
if [ ! -s ${IQ_DIR}/IQ.sh ]; then
	_err_msg_="${IQ_DIR}/IQ.sh script not found, or is empty"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
else
	log_msg -l ${LOGFILE} -q -s "Sourcing information from ${IQ_DIR}/IQ.sh"
	. ${IQ_DIR}/IQ.sh
fi

# Update dwh.ini with reader info if this is installation
if [ ! "${RESTORE}" ]; then
	if [ ! -s ${ENIQ_CONF_DIR}/.reader_info ]; then
	_err_msg_="Could not find ${ENIQ_CONF_DIR}/.reader_info file, or it is empty"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	update_reader_info
fi

# Create the reader instance
_reader_name_=`$CAT ${CLI_CONF_DIR}/service_names | $EGREP "${HOST_IP}" | $EGREP "dwh_reader_" | $AWK -F\:: '{print $3}'`
if [ ! "${_reader_name_}" ]; then
	_err_msg_="Could not determine reader name from ${CLI_CONF_DIR}/service_names"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_reader_num_=`$ECHO ${_reader_name_} | $AWK -F_ '{print $NF}'`
if [ ! "${_reader_num_}" ]; then
	_err_msg_="Could not determine reader number from ${_reader_name_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_tmp_log_=${TEM_DIR}/reader_mpx_create.log
$TOUCH -a ${_tmp_log_}
$CHOWN ${_sysuser_}:${_sysgrp_} ${_tmp_log_}
if [ $? -ne 0 ]; then
	_err_msg_="Could not change ownership of ${_tmp_log_} to ${_sysuser_}:${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Reader params
Server_Name=`/usr/bin/hostname`
IP_ADDRESS=`$GETENT hosts ${Server_Name} | $AWK '{print $1}' | $SORT -u`
READER_NUM=`$ECHO ${_reader_name_} | $AWK -F\_ '{print $NF}'`
#eval READER_DIR=$(echo \${DWH_DIR_R${READER_NUM}})
READER_DIR=${DWH_READER_DIR}

log_msg -s "\nDeploying dwh_reader configuration files..." -l ${LOGFILE}
# Make a backup of dwhdb.cfg
if [ -f ${READER_DIR}/dwhdb.cfg ]; then
	log_msg -s "Backing up ${READER_DIR}/dwhdb.cfg file" -l ${LOGFILE}
	$MV -f ${READER_DIR}/dwhdb.cfg ${READER_DIR}/dwhdb.cfg.`$DATE '+%y%m%d'`
	if [ $? -ne 0 ]; then
		_err_msg_="Could not move ${DWH_DIR}/dwhdb.cfg to ${DWH_DIR}/dwhdb.cfg.`$DATE '+%y%m%d'`"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

# Update log info in dwhdb.cfg
if [ -f ${ENIQ_ADMIN_DIR}/sybase_conf/${CURR_SERVER_TYPE}/dwhdb.cfg ]; then
	DWHDB_CFG_PATH=${ENIQ_ADMIN_DIR}/sybase_conf/${CURR_SERVER_TYPE}
elif [ -f ${ENIQ_ADMIN_DIR}/sybase_conf/dwhdb.cfg ]; then
	DWHDB_CFG_PATH=${ENIQ_ADMIN_DIR}/sybase_conf/
else
	_err_msg_="Files ${ENIQ_ADMIN_DIR}/sybase_conf/dwhdb.cfg and ${ENIQ_ADMIN_DIR}/sybase_conf/${CURR_SERVER_TYPE}/dwhdb.cfg do not exist"
fi

if [ -f ${DWHDB_CFG_PATH}/dwhdb.cfg ]; then
	$CAT ${DWHDB_CFG_PATH}/dwhdb.cfg | $SED -e "s|@@path_to_log@@|${IQLOGDIR}|" -e "s|@@dwh_instance@@|${_reader_name_}|g" > ${READER_DIR}/dwhdb.cfg
	if [ $? -ne 0 ]; then
		_err_msg_="Could not update ${READER_DIR}/dwhdb.cfg"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	$CHMOD 440 ${READER_DIR}/dwhdb.cfg
	if [ $? -ne 0 ]; then
		_err_msg_="Could not change permissions of ${DWH_DIR}/dwhdb.cfg to -r--r-----"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	log_msg -l ${LOGFILE} -q -s "\nChanging ownership of ${READER_DIR}/dwhdb.cfg to ${_sysuser_}:${_sysgrp_}"
	$CHOWN ${_sysuser_}:${_sysgrp_} ${READER_DIR}/dwhdb.cfg
	if [ $? -ne 0 ]; then
		_err_msg_="Could not change ownership of ${READER_DIR}/dwhdb.cfg to ${_sysuser_}:${_sysgrp_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
else
	_err_msg_="File ${DWHDB_CFG_PATH}/dwhdb.cfg does not exist"
	abort_script "${_err_msg_}"
fi

# Create a new reader instance
log_msg -s "Creating a new reader..." -l ${LOGFILE}
log_msg -l ${LOGFILE} -q -s "Calling reader creation script using command"
log_msg -l ${LOGFILE} -q -s "$SU - ${_sysuser_} -c \"${BASH} ${SCRIPTHOME}/create_reader.bsh -l ${_tmp_log_} -c ${CLI_CONF_DIR} -d ${CLI_CONF_DIR}/${ENIQ_INI} -r ${_reader_name_} -s ${ENIQ_CONF_DIR}/${SYM_INI}\""
$SU - ${_sysuser_} -c "${BASH} ${SCRIPTHOME}/create_reader.bsh -l ${_tmp_log_} -c ${CLI_CONF_DIR} -d ${CLI_CONF_DIR}/${ENIQ_INI} -r ${_reader_name_} -s ${ENIQ_CONF_DIR}/${SYM_INI}"
if [ $? -ne 0 ]; then
	$CAT ${_tmp_log_} >> ${LOGFILE}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy ${_tmp_log_} to ${LOGFILE}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	_err_msg_="Failed to create IQ reader multiplex"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Start the Reader
$ECHO "Starting dwh_reader..." | $TEE -a ${_tmp_log_}
$SU - ${_sysuser_} -c "${ENIQ_ADMIN_BIN_DIR}/dwh_reader start"
if [ $? -ne 0 ]; then
	$CAT ${_tmp_log_} >> ${LOGFILE}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy ${_tmp_log_} to ${LOGFILE}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	_err_msg_="DWH reader failed to start"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
else
	$ECHO "DWH database reader successfully started" | $TEE -a ${_tmp_log_}
fi

# Add Reader temp dbspaces
$ECHO "Adding temp dbpsaces to reader..." | $TEE -a ${_tmp_log_}
$ECHO "Beginning to add temp dbspaces using command" >> ${_tmp_log_}
$ECHO "$SU - ${_sysuser_} -c \"${BASH} ${SCRIPTHOME}/add_reader_temp_dbspace.bsh -c ${CLI_CONF_DIR} -d ${CLI_CONF_DIR}/${ENIQ_INI} -l ${LOGFILE} -s ${ENIQ_CONF_DIR}/${SYM_INI}\"" >> ${_tmp_log_}
$SU - ${_sysuser_} -c "${BASH} ${SCRIPTHOME}/add_reader_temp_dbspace.bsh -c ${CLI_CONF_DIR} -d ${CLI_CONF_DIR}/${ENIQ_INI} -l ${_tmp_log_} -s ${ENIQ_CONF_DIR}/${SYM_INI}"
if [ $? -ne 0 ]; then
	$CAT ${_tmp_log_} >> ${LOGFILE}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy ${_tmp_log_} to ${LOGFILE}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	_err_msg_="Failed to create reader temp DBSPACES"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$CAT ${_tmp_log_} >> ${LOGFILE}
if [ $? -ne 0 ]; then
	_err_msg_="Could not append ${_tmp_log_} to ${LOGFILE}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Update the IQ interfaces file
if [ ! -s ${ENIQ_BASE_DIR}/sybase_iq/interfaces ]; then
	_err_msg_="Could not locate Sybase IQ interfaces file"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

log_msg -l ${LOGFILE} -q -s "Updating ${ENIQ_BASE_DIR}/sybase_iq/interfaces with ${_reader_name_} information"
update_iq_intf_file ${ENIQ_BASE_DIR}/sybase_iq/interfaces ${CLI_CONF_DIR}/${ENIQ_INI} ${_reader_name_}
if [ $? -ne 0 ]; then
	_err_msg_="Could not update ${ENIQ_BASE_DIR}/sybase_iq/interfaces with ${_reader_name_} information"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$RM -rf ${ENIQ_CONF_DIR}/.reader_info

insert_header_footer foot "Successfully completed stage - ${NEXT_STAGE}" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: slot_configuration ###
#
# regenerates the required slots on 1st reader and every writer
#
# Arguments:
#   none
# Return Values:
#   none
slot_configuration()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Need to start hostsync to get the alias info back
_hostsync_smf_str_=`iniget HOST_SYNC_DAEMON -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v HOST_SYNC_SERVICE_STR`
if [ ! "${_hostsync_smf_str_}" ]; then
		_err_msg_="Could not read host_syncd SMF string from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

log_msg -s "Starting ${_hostsync_smf_str_}" -l ${LOGFILE}
$SYSTEMCTL start  ${_hostsync_smf_str_}
if [ $? -ne 0 ]; then
	_err_msg_="Could not start ${_hostsync_smf_str_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

log_msg -s "Enabling ${_hostsync_smf_str_}" -l ${LOGFILE}
$SYSTEMCTL enable  ${_hostsync_smf_str_}
if [ $? -ne 0 ]; then
	_err_msg_="Could not enable ${_hostsync_smf_str_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_update_slots_=0
CURRENT_SERVER_NAME=`/usr/bin/hostname`
IP_ADDRESS=`$GETENT hosts ${CURRENT_SERVER_NAME} | $AWK '{print $1}' | $SORT -u`
READER_ALIAS=`$CAT ${CLI_CONF_DIR}/service_names | $GREP "${IP_ADDRESS}" | $GREP "dwh_reader_1" | $AWK -F"::" '{print $3}'`
if [ "${CURR_SERVER_TYPE}" == "stats_engine" ]; then
	_update_slots_=1
fi

if [ "${CURR_SERVER_TYPE}" == "stats_iqr" -o "${CURR_SERVER_TYPE}" == "events_iqr" ]; then
	if [ "${READER_ALIAS}" ]; then
		_update_slots_=1
	fi
fi
_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ${_update_slots_} -eq 1 ]; then
	_add_service_users_=${ENIQ_BASE_DIR}/sw/bin/add_service_users
	if [ -s $_add_service_users_ ] ; then
		$ECHO "Updating service user details in repdb ..." >> ${LOGFILE}
		$SU - ${_sysuser_} -c "$_add_service_users_ -all" >> ${LOGFILE}
		if [ $? -ne 0 ]; then
			_err_msg_="Failed updating service user details in repdb ..."
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi

	# Run the regenerateslots function
	regenerateslots
else
	$ECHO "Skipping regenerateslots for this server" | $TEE -a ${LOGFILE}
fi

insert_header_footer foot "Successfully completed stage - ${NEXT_STAGE}" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: create_users ###
#
# Creates all required Users
#
# Arguments:
#   none
# Return Values:
#   none
create_users()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

if [ ! -f /etc/passwd.orig ]; then
	$CP -p /etc/passwd /etc/passwd.orig
fi

if [ ! -d ${ENIQ_BASE_DIR}/home ]; then
	$ECHO "Creating ${ENIQ_BASE_DIR}/home directory" | $TEE -a ${LOGFILE}
	$MKDIR -p ${ENIQ_BASE_DIR}/home
fi


if [ ! -s ${ENIQ_COMMON_SW_DIR}/connectd/bin/generate_ssh_key.bsh ]; then
	_err_msg_="Could not find ${ENIQ_COMMON_SW_DIR}/connectd/bin/generate_ssh_key.bsh script"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

read_storage_type

if [ "${STORAGE_TYPE}" == "raw" ]; then
	# Check mountpoints and mount if not there
	mount_req_dirs
	if [ $? -ne 0 ]; then
		_err_msg_="Could not mount required directories for $NEXT_STAGE"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi


_update_=0
# Get a list of users to be created
$ECHO "Creating list of users from ${ENIQ_CONF_DIR}/${SUNOS_INI}" >> ${LOGFILE}
_user_list_=`iniget SunOS_USER -f ${ENIQ_CONF_DIR}/${SUNOS_INI}`
for _user_ in ${_user_list_}; do
	_user_name_=`iniget ${_user_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v name`
	$GETENT passwd ${_user_name_} >> /dev/null 2>&1
	if [ $? -eq 0 ]; then
		$ECHO -e "\nUser ${_user_name_} already created" | $TEE -a ${LOGFILE}
		continue
	fi

	_user_uid_=`iniget ${_user_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v uid`
	_user_gid_=`iniget ${_user_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v gid`
	_user_sgid_=`iniget ${_user_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v sgid`
	_user_realname_=`iniget ${_user_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v realname`
	_user_home_=`iniget ${_user_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v home`
	_user_shell_=`iniget ${_user_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v shell`
	_user_passwd_=`iniget ${_user_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v password`


   
	unset _uid_str_
	if [ "${_user_uid_}" ]; then
		_uid_str_="-u ${_user_uid_}"
	fi

	unset _sgid_str_
	if [ "${_user_sgid_}" ]; then
		_sgid_str_="-G ${_user_sgid_}"
	fi

	# Check if there is a skeleton directory for this user...
	unset _user_skel_ _arch_
	_arch_=`$UNAME -p`
	if [ -d ${ENIQ_TEMPL_DIR}/${_arch_}/skel_dir ]; then
		_user_skel_="-m -k ${ENIQ_TEMPL_DIR}/${_arch_}/skel_dir"
	fi

   # Check if home's subdirectories are present for RACK, if not, create them else they'll be mounted
   if [ "${STORAGE_TYPE}" == "fs" ]; then
		$ECHO -e "\nCreating home subdirectory ${_user_home_} for ${_user_name_}" | $TEE -a ${LOGFILE}
		if [ ! -d "${_user_home_}" ]; then
				$MKDIR -p ${_user_home_}
		fi
   fi

	$ECHO -e "\nCreating user \"${_user_name_}\"" | $TEE -a ${LOGFILE}
	$ECHO "$USERADD -m -d ${_user_home_} -s ${_user_shell_} -c "${_user_realname_}" ${_uid_str_} -g ${_user_gid_} ${_sgid_str_} ${_user_skel_} ${_user_name_}" >> ${LOGFILE}
	$USERADD -m -d ${_user_home_} -s ${_user_shell_} -c "${_user_realname_}" ${_uid_str_} -g ${_user_gid_} ${_sgid_str_} ${_user_skel_} ${_user_name_} > /dev/null 2>&1
	if [ $? -ne 0 ]; then
		_err_msg_="Could not create user ${_user_name_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	#changing ownership
	if [ "${STORAGE_TYPE}" == "fs" ]; then
		$ECHO "Changing ${_user_home_} ownership to ${_user_name_}:${_user_gid_}" | $TEE -a ${LOGFILE}
		$CHOWN ${_user_name_}:${_user_gid_} ${_user_home_}
		if [ $? -ne 0 ]; then
		_err_msg_="Could not change ownership of ${_user_home_} to ${_user_name_}:${_user_gid_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi

	# Change the permissions
	$ECHO "Changing ${_user_home_} permissions to -rwxr-x---" | $TEE -a ${LOGFILE}
	$CHMOD 750 ${_user_home_}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not change permissions of ${_user_home_} to -rwxr-x---"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	if [ ! -f /etc/shadow.orig ]; then
		$CP -p /etc/shadow /etc/shadow.orig
	fi

	$ECHO "Updating /etc/shadow file for ${_user_name_}" >> ${LOGFILE}
	$CAT /etc/shadow | $SED -e "s/^\(${_user_name_}:\)[^:]*\(:.*\)$/\1${_user_passwd_}\2/" >${TEM_DIR}/shadow
		$CP ${TEM_DIR}/shadow /etc/shadow
	_update_=1

	if [ "${_user_name_}" == "dcuser" ]; then
		if [ "${SERVER_TYPE}" == "CO" ]; then
			$ECHO -e "\nCreating ssh keys for ${_user_name_}" | $TEE -a ${LOGFILE}
			/usr/bin/bash ${ENIQ_COMMON_SW_DIR}/connectd/bin/generate_ssh_key.bsh -u ${_user_name_} -l ${LOGFILE}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not generate ssh keys for ${_user_name_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			if [ -s ${_user_home_}/.ssh/id_rsa.pub ]; then
				$ECHO "Updating ${_user_home_}/.ssh/authorized_keys file" | $TEE -a ${LOGFILE}
				$CP ${_user_home_}/.ssh/id_rsa.pub ${_user_home_}/.ssh/authorized_keys
				if [ $? -ne 0 ]; then
					_err_msg_="Could not copy ${_user_home_}/.ssh/id_rsa.pub to ${_user_home_}/.ssh/authorized_keys"
					abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				fi
			else
				_err_msg_="${_user_home_}/.ssh/id_rsa.pub does not exist after key generation"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		fi

		$ECHO "Changing ${_user_home_}/.ssh permissions to -rwx------" | $TEE -a ${LOGFILE}
		$CHMOD 700 ${_user_home_}/.ssh
		if [ $? -ne 0 ]; then
			_err_msg_="Could not change permissions of ${_user_home_}.ssh to -rwx------"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi
done

if [ ${_update_} -eq 1 ]; then
	insert_header_footer foot "Successfully created users" ${LOGFILE}
else
	insert_header_footer foot "Successfully completed core install stage - ${NEXT_STAGE}" ${LOGFILE}
fi

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: create_rbac_roles ###
#
# Create RBAC roles
#
# Arguments:
#   none
# Return Values:
#   none
create_rbac_roles()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

if [ ! -s ${SCRIPTHOME}/create_eniq_rbac.bsh ]; then
	_err_msg_="Could not locate file ${SCRIPTHOME}/create_eniq_rbac.bsh"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Create the required ENIQ sudo roles
$ECHO "\nCalling ENIQ sudo roles creation script using command" >> ${LOGFILE}
$ECHO "$BASH ${SCRIPTHOME}/create_eniq_rbac.bsh -f \"${ENIQ_CONF_DIR}/${RBAC_INI}\" -s \"${ENIQ_CONF_DIR}/${SUNOS_INI}\" -l ${LOGFILE}" >> ${LOGFILE}
$BASH ${SCRIPTHOME}/create_eniq_rbac.bsh -f "${ENIQ_CONF_DIR}/${RBAC_INI}" -s "${ENIQ_CONF_DIR}/${SUNOS_INI}" -l ${LOGFILE}
if [ $? -ne 0 ]; then
	_err_msg_="Failed to update ENIQ RBAC Roles"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

insert_header_footer foot "Successfully completed configuration for ENIQ user roles." ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: create_repdb ###
#
#
# Arguments:
#	   none
# Return Values:
#	   none
create_repdb()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

_cli_conf_dir_=`$CAT ${ENIQ_CONF_DIR}/${ENIQ_ENV} | $EGREP "^[[:blank:]]*CONF_DIR=" | $AWK -F\= '{print $2}' | $SED -e 's|"||g'`
if [ ! "${_cli_conf_dir_}" ]; then
	_err_msg_="Could not read CONF_DIR parameter from ${ENIQ_CONF_DIR}/${ENIQ_ENV}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Check required files and scripts exist
if [ ! -s ${_cli_conf_dir_}/${ENIQ_ENV} ]; then
	_err_msg_="File ${_cli_conf_dir_}/${ENIQ_ENV} not found, or is empty"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
else
	$ECHO "Sourcing ${_cli_conf_dir_}/${ENIQ_ENV}" >> ${LOGFILE}
	. ${_cli_conf_dir_}/${ENIQ_ENV}
fi

# Check required files and scripts exist
if [ ! -s ${ASA_DIR}/bin64/sa_config.sh ]; then
	_err_msg_="File ${ASA_DIR}/bin64/sa_config.sh not found, or is empty"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
else
	$ECHO "Sourcing ${ASA_DIR}/bin64/sa_config.sh\n" >> ${LOGFILE}
	. ${ASA_DIR}/bin64/sa_config.sh
fi

if [ ! -s ${ENIQ_ADMIN_BIN_DIR}/repdb ]; then
	_err_msg_="${ENIQ_ADMIN_BIN_DIR}/repdb script not found, or is not executable"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ! -s ${SCRIPTHOME}/create_repdb.bsh ]; then
	_err_msg_="${SCRIPTHOME}/create_repdb.bsh script not found, or is not executable"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ! -s ${SCRIPTHOME}/dboptions_repdb.bsh ]; then
	_err_msg_="${SCRIPTHOME}/dboptions_repdb.bsh script not found"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysgrp_=`$ID ${_sysuser_} | $AWK '{print $2}' | $AWK -F\( '{print $2}' | $AWK -F\) '{print $1}'`
if [ ! "${_sysgrp_}" ]; then
	_err_msg_="Could not determine group ID of ${_sysuser_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$ECHO "Changing ownership of ${SCRIPTHOME}/create_repdb.bsh to ${_sysuser_}:${_sysgrp_}" >> ${LOGFILE}
$CHOWN ${_sysuser_}:${_sysgrp_} ${SCRIPTHOME}/create_repdb.bsh
if [ $? -ne 0 ]; then
	_err_msg_="Could not change ownership of ${SCRIPTHOME}/create_repdb.bsh to ${_sysuser_}:${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$ECHO "Changing ownership of ${SCRIPTHOME}/dboptions_repdb.bsh to ${_sysuser_}:${_sysgrp_}\n" >> ${LOGFILE}
$CHOWN ${_sysuser_}:${_sysgrp_} ${SCRIPTHOME}/dboptions_repdb.bsh
if [ $? -ne 0 ]; then
	_err_msg_="Could not change ownership of ${SCRIPTHOME}/dboptions_repdb.bsh to ${_sysuser_}:${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$ECHO "Deploying configuration files...\n" | $TEE -a ${LOGFILE}
if [ -f ${REP_DIR}/repdb.cfg ]; then
	$ECHO "Backuping old configuration file" | $TEE -a ${LOGFILE}
	$MV -f ${REP_DIR}/repdb.cfg ${REP_DIR}/repdb.cfg.`$DATE '+%y%m%d'`
	if [ $? -ne 0 ]; then
		_err_msg_="Could not move ${REP_DIR}/repdb.cfg to ${REP_DIR}/repdb.cfg.`$DATE '+%y%m%d'`"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

# Update log info in repdb.cfg
if [ -f ${ENIQ_ADMIN_DIR}/sybase_conf/repdb.cfg ]; then
	$CP ${ENIQ_ADMIN_DIR}/sybase_conf/repdb.cfg ${REP_DIR}/repdb.cfg
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy ${REP_DIR}/repdb.cfg"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	$CHMOD 440 ${REP_DIR}/repdb.cfg | $TEE -a ${LOGFILE}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not change permissions of ${REP_DIR}/repdb.cfg to -r--r-----"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	$ECHO "Changing ownership of ${REP_DIR}/repdb.cfg to ${_sysuser_}:${_sysgrp_}\n" >> ${LOGFILE}
	$CHOWN ${_sysuser_}:${_sysgrp_} ${REP_DIR}/repdb.cfg
	if [ $? -ne 0 ]; then
		_err_msg_="Could not change ownership of ${REP_DIR}/repdb.cfg to ${_sysuser_}:${_sysgrp_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
else
	_err_msg_="File ${ENIQ_ADMIN_DIR}/sybase_conf/repdb.cfg does not exist"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Update the service_names file with the repdb service
$ECHO "Updating ${_cli_conf_dir_}/service_names with repdb information" >> ${LOGFILE}
update_service_file ${_cli_conf_dir_}/service_names ${HOST_IP} ${HNAME} repdb "NULL_GRP"
if [ $? -ne 0 ]; then
	_err_msg_="Failed to update ${_cli_conf_dir_}/service_names with repdb"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$ECHO "Changing ownership of ${_cli_conf_dir_}/service_names to ${_sysuser_}:${_sysgrp_} after updates for repdb" >> ${LOGFILE}
$CHOWN ${_sysuser_}:${_sysgrp_} ${_cli_conf_dir_}/service_names
if [ $? -ne 0 ]; then
	_err_msg_="Failed to change ownership of ${_cli_conf_dir_}/service_names to ${_sysuser_}:${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ -f ${REP_DIR}/install.complete ]; then
	$ECHO "\nrepdb already created." | $TEE -a ${LOGFILE}
else
	if [ -f  ${REP_DIR}/*.db ]; then
		$ECHO "\nCleaning up previous repdb installation ..." | $TEE -a ${LOGFILE}
		$SU - ${_sysuser_} -c "${ENIQ_ADMIN_BIN_DIR}/repdb stop" >> /dev/null 2>&1

		$MV ${REP_DIR}/repdb.cfg ${TEM_DIR}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not move ${REP_DIR}/repdb.cfg to ${TEM_DIR}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		$RM -rf ${REP_DIR}/*

		$MV ${TEM_DIR}/repdb.cfg ${REP_DIR}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not move ${TEM_DIR}/repdb.cfg to ${REP_DIR}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		$ECHO "Cleanup complete" | $TEE -a ${LOGFILE}
	fi

	$ECHO "Creating temp logfile in ${TEM_DIR}/repdb_create.log" >> ${LOGFILE}
	_temp_log_=${TEM_DIR}/repdb_create.log
	$TOUCH -a ${_temp_log_}
	$ECHO "Changing ownership of ${TEM_DIR}/repdb_create.log to ${_sysuser_}:${_sysgrp_}" >> ${LOGFILE}
	$CHOWN ${_sysuser_}:${_sysgrp_} ${_temp_log_}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not change ownership of ${_temp_log_} to ${_sysuser_}:${_sysgrp_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	$ECHO "\nStarting repdb creation..." | $TEE -a ${LOGFILE}
	$ECHO "Calling repdb creation script using command" >> ${LOGFILE}
	$ECHO "$SU - ${_sysuser_} -c \"${BASH} ${SCRIPTHOME}/create_repdb.bsh -c ${_cli_conf_dir_} -d ${_cli_conf_dir_}/${ENIQ_INI} -s ${STORAGE_TYPE} -l ${_temp_log_}\"" >> ${LOGFILE}
	$SU - ${_sysuser_} -c "${BASH} ${SCRIPTHOME}/create_repdb.bsh -c ${_cli_conf_dir_} -d ${_cli_conf_dir_}/${ENIQ_INI} -s ${STORAGE_TYPE} -l ${_temp_log_}"
	if [ $? -ne 0 ]; then
		$ECHO "Importing information from ${TEM_DIR}/repdb_create.log to ${LOGFILE}" >> ${LOGFILE}
		$CAT ${_temp_log_} >> ${LOGFILE}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not copy ${_temp_log_} to ${LOGFILE}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
		_err_msg_="Creating REP Database failed"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	$ECHO "\nSetting repdb database options..." | $TEE -a ${_temp_log_}
	$ECHO "$SU - ${_sysuser_} -c \"${BASH} ${SCRIPTHOME}/dboptions_repdb.bsh -c ${_cli_conf_dir_} -d ${_cli_conf_dir_}/${ENIQ_INI} -l ${_temp_log_}\"" >> ${_temp_log_}
	$SU - ${_sysuser_} -c "${BASH} ${SCRIPTHOME}/dboptions_repdb.bsh -c ${_cli_conf_dir_} -d ${_cli_conf_dir_}/${ENIQ_INI} -l ${_temp_log_}"
	if [ $? -ne 0 ]; then
		$ECHO "Importing information from ${TEM_DIR}/repdb_create.log to ${LOGFILE}" >> ${LOGFILE}
		$CAT ${_temp_log_} >> ${LOGFILE}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not copy ${_temp_log_} to ${LOGFILE}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
		_err_msg_="REP Database option setting failed"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	$ECHO "Importing information from ${TEM_DIR}/repdb_create.log to ${LOGFILE}" >> ${LOGFILE}
	$CAT ${_temp_log_} >> ${LOGFILE}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy ${_temp_log_} to ${LOGFILE}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	REPDATE=`date '+%y%m%d_%H%M%S'`
	$ECHO ${REPDATE} > ${REP_DIR}/install.complete
	$CHMOD 440 ${REP_DIR}/install.complete
	if [ $? -ne 0 ]; then
		_err_msg_="Could not change permissions of ${REP_DIR}/install.complete to -r--r-----"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

insert_header_footer foot "Successfully completed stage - ${NEXT_STAGE}" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: remove_swap_fs ###
#
# Removing swap filesystem if already exist
#
# Arguments:
#   none
# Return Values:
#   none
remove_swap_fs()
{
_swap_vol_name_=`iniget SunOS_FS_SWAP_VOL -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v name`
if [ ! "${_swap_vol_name_}" ]; then
	_err_msg_="Failed to get swap volume name"
	abort_script "${_err_msg_}" 
fi

# Remove the volume from the fstab if necessary
$CAT ${FSTAB} | $EGREP "^[[:blank:]]*\/dev\/mapper\/${_swap_vol_name_}" >> /dev/null 2>&1
if [ $? -eq 0 ]; then
	$CAT ${FSTAB} | $EGREP -v "^[[:blank:]]*\/dev\/mapper\/${_swap_vol_name_}" > ${TEM_DIR}/fstab
	$CP ${TEM_DIR}/fstab ${FSTAB}
fi

# Remove the volume from swap
$SWAPOFF  /dev/mapper/${_swap_vol_name_} >> /dev/null 2>&1

# Destroy the swap FS
$LVREMOVE -f /dev/mapper/${_swap_vol_name_} >> /dev/null 2>&1
}

### Function: create_logical_volume_filesystem ###
#
# Creates all required Filesystems
#
# Arguments:
#   none
# Return Values:
#   none
create_logical_volume_filesystem()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type
if [ $? -ne 0 ]; then
	_err_msg_="Could not get the value of storage type"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ "${STORAGE_TYPE}" == "raw" ]; then

	log_msg -s "Creating a list of volume groups from ${ENIQ_CONF_DIR}/${SUNOS_INI}\n" -l ${LOGFILE}
	_pool_list_=`iniget SunOS_FS_POOL -f ${ENIQ_CONF_DIR}/${SUNOS_INI}`
	for _pool_ in ${_pool_list_}; do
	   _pool_disk_layout_=`iniget ${_pool_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v disk_layout`
	   if [ ! "${_pool_disk_layout_}" ]; then
			_err_msg_="Could not determine disk ${_pool_disk_layout_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	   fi
	done

	# Getting the size of Volume Group
	if [ -f ${ENIQ_CONF_DIR}/lun_map.ini ]; then

		_disk_label_list_=`iniget LUN_MAP_DETAILS -f ${ENIQ_CONF_DIR}/lun_map.ini`
		if [ ! "${_disk_label_list_}" ]; then
			_err_msg_="Could not determine value of _disk_label_list_"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		for _tag_ in ${_disk_label_list_}; do
	
			_disk_id_=`iniget ${_tag_} -f ${ENIQ_CONF_DIR}/lun_map.ini -v DISK_ID`
			if [ ! "${_disk_id_}" ]; then
				_err_msg_="Could not determine _disk_id_ for ${_tag_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		
			if [ "${_disk_id_}" == "${_pool_disk_layout_}" ]; then
				_disk_tag_=${_tag_}
				break
			fi	
	
		done

		if [ ! "${_disk_tag_}" ]; then
			_err_msg_="Could not find the block for ${_pool_disk_layout_} in ${ENIQ_CONF_DIR}/lun_map.ini"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	
		_disk_size_=`iniget ${_disk_tag_} -f ${ENIQ_CONF_DIR}/lun_map.ini -v SIZE`
		if [ ! "${_disk_size_}" ]; then
			_err_msg_="Could not determine disk size of ${_pool_disk_layout_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

	else
		_err_msg_="Could not locate lun_map.ini file"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	if [  "${CURR_SERVER_TYPE}" == "stats_coordinator" -o "${CURR_SERVER_TYPE}" == "eniq_stats" ]; then
		_avail_disk_size_=`$EXPR ${_disk_size_} - ${MAX_16G_SWAP}`
		if [ ! "${_avail_disk_size_}"  ]; then
			_err_msg_="Could not determine avaialable disk size ${_pool_disk_layout_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	else
		_avail_disk_size_=`$EXPR ${_disk_size_} - ${MAX_8G_SWAP}`
		if [ ! "${_avail_disk_size_}"  ]; then
			_err_msg_="Could not determine disk size available space of ${_pool_disk_layout_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi

	if [ ! "${MIGRATION}" ]; then
		# Getting the tag for FS size based on server type
		get_fs_size_tag

		log_msg -s "Creating list of file systems from ${ENIQ_CONF_DIR}/${SUNOS_INI}\n" -l ${LOGFILE}

		_fs_list_=`iniget SunOS_ZFS_FS -f ${ENIQ_CONF_DIR}/${SUNOS_INI}`
		for _fs_ in ${_fs_list_}; do
			_fs_name_=`iniget ${_fs_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v name`
			_fs_mount_pt_=`iniget ${_fs_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v mountpoint`
			_fs_perms_=`iniget ${_fs_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v perms`
			_fs_vg_=`$ECHO ${_fs_name_} | $AWK -F\- '{print $1}'`
			_fs_lv_=`$ECHO ${_fs_name_} | $AWK -F\- '{print $2}'`
			_fs_size_=`iniget ${_fs_size_tag_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v "${_fs_lv_}" | $AWK -F ":" '{print $1}'`
			_fs_overhead_=`iniget ${_fs_size_tag_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v "${_fs_lv_}" | $AWK -F ":" '{print $3}'`
			if [ ! "${_fs_name_}" -o ! "${_fs_mount_pt_}" -o ! "${_fs_perms_}" -o ! "${_fs_vg_}" -o ! "${_fs_lv_}" -o ! "${_fs_size_}" -o ! "${_fs_overhead_}" ]; then
				_err_msg_="Could not read FS parameters from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			_final_fs_size_=`$ECHO "scale=6; ${_fs_size_}/100" | $BC`

			_size_fs_=`$AWK -v _disk_size_=${_avail_disk_size_} -v _final_size_=${_final_fs_size_} 'BEGIN {print _disk_size_ * _final_size_}'`
			if [ ! "${_size_fs_}"  ]; then
				_err_msg_="Could not determine fs size of ${_fs_name_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			$VGDISPLAY ${_fs_vg_} >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Could not locate FS volume group - ${_fs_vg_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			# Destroy the FS if it exists
			$RM -rf ${_fs_mount_pt_}/* >> /dev/null 2>&1
		
			$UMOUNT -l ${_fs_mount_pt_} >> /dev/null 2>&1
			log_msg -s "Removing the ${_fs_name_} filesystem" -l ${LOGFILE}
			$LVREMOVE -y /dev/${_fs_vg_}/${_fs_lv_} >> /dev/null 2>&1
		
			if [ -f "${FSTAB}" ]; then
				if  ${EGREP} -q ${_fs_vg_}-${_fs_lv_} ${FSTAB}
				then
				$SED -i "/${_fs_vg_}-${_fs_lv_}/d" ${FSTAB} >> /dev/null 2>&1
				if [ $? -ne 0 ]; then
					_err_msg_="Could not delete Mount Point in ${FSTAB} file"
					abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				fi
				fi
			else
				_err_msg_="Could not locate ${FSTAB} file"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			log_msg -s "Creating fileSystem `$BASENAME ${_fs_name_}`" -l ${LOGFILE}
			$LVCREATE -y -L ${_size_fs_}G -n ${_fs_lv_} ${_fs_vg_}  >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Could not create FS logicalvolume  - ${_fs_lv_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		
			$UMOUNT -l ${_fs_mount_pt_} >> /dev/null 2>&1
		
			log_msg -s "Formatting fileSystem `$BASENAME ${_fs_name_}` with ${FS_TYPE} filesystem" -l ${LOGFILE}
			${MKFS_EXT4} -m ${_fs_overhead_} /dev/${_fs_vg_}/${_fs_lv_} >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Could not format FS `$BASENAME ${_fs_name_}` with ${FS_TYPE} "
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
			log_msg -s "Creating Mount Point" -l ${LOGFILE}
			$MKDIR -p ${_fs_mount_pt_}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not create Mount Point"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		
			log_msg -s "Updating ${FSTAB} file with filesystem `$BASENAME ${_fs_name_}` on ${_fs_mount_pt_}\n" -l ${LOGFILE}
			$ECHO "/dev/mapper/${_fs_vg_}-${_fs_lv_} ${_fs_mount_pt_}				   ${FS_TYPE}	auto,rw		0 2" >> ${FSTAB}
		   
			if [ $? -ne 0 ]; then
				_err_msg_="Could not Update ${FSTAB} file with filesystem `$BASENAME ${_fs_name_}` on ${_fs_mount_pt_} and Reverting back to original fstab file"
				#Reverting back to original fstab file
				$MV ${FSTAB}_orig ${FSTAB}
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi			

		done
		$MOUNT -a >> /dev/null 2>&1
		if [ $? -ne 0 ]; then
			_err_msg_="Could not mount filesystem"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

	fi

        ##Updating /etc/lvm/lvm.conf file with snapshot autoextend parameters
        if [ ! -f /etc/lvm/lvm.conf.orig ]; then
             $CP -p /etc/lvm/lvm.conf /etc/lvm/lvm.conf.orig >> /dev/null 2>&1
             if [ $? -ne 0 ]; then
                  _err_msg_="Could not make backup of /etc/lvm/lvm.conf"
                  abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
             fi
        fi

        ##Set autoextend threshold to 90%
        $SED -i 's/snapshot_autoextend_threshold = 100/snapshot_autoextend_threshold = 90/g' /etc/lvm/lvm.conf >> /dev/null 2>&1
        if [ $? -ne 0 ]; then
             _err_msg_="Could not set snapshot_autoextend_threshold to 90 in /etc/lvm/lvm.conf"
             abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
        fi

        ##Set autoextend percent to 10%
        $SED -i 's/snapshot_autoextend_percent = 20/snapshot_autoextend_percent = 10/g' /etc/lvm/lvm.conf >> /dev/null 2>&1
        if [ $? -ne 0 ]; then
             _err_msg_="Could not set snapshot_autoextend_percent to 10 in /etc/lvm/lvm.conf"
             abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
        fi

        ##Restarting lvm2-monitor service
        $SYSTEMCTL restart lvm2-monitor
        if [ $? -ne 0 ]; then
             _err_msg_="Failed to restart lvm2-monitor service"
             abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
        fi

	# Create the swap partition
	if [ "${INSTALL_TYPE}" == "stats" -a "${_san_device_}" != "local" ]; then
		_total_mem_=`$FREE -g | $EGREP Mem | $AWK '{print $2}'`
		if [  "${CURR_SERVER_TYPE}" == "stats_coordinator" -o "${CURR_SERVER_TYPE}" == "eniq_stats" ]; then
			MAX_SWAP=${MAX_16G_SWAP}
		else
			MAX_SWAP=${MAX_8G_SWAP}
		fi

		if [ ${_total_mem_} -gt ${MAX_SWAP} ]; then
			_swap_vol_size_=${MAX_SWAP}
		else
			_swap_vol_size_=${_total_mem_}
		fi

		#Removing swap filesystem if already exist
		remove_swap_fs

		#Create the swap FS
		_vg_=`$ECHO ${_swap_vol_name_} | $AWK -F - '{print $1}'`
		_lv_=`$ECHO ${_swap_vol_name_} | $AWK -F - '{print $2}'`
		if [ ! "${_vg_}" -o ! "${_lv_}" ]; then
			_err_msg_="Could not determine swap volume group ${_vg_} and logical volume  ${_lv_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		$LVCREATE -y -L ${_swap_vol_size_}G -n ${_lv_} ${_vg_} >> /dev/null 2>&1
		if [ $? -ne 0 ]; then
			_err_msg_="Could not create swap volume `$BASENAME ${_swap_vol_name_}`"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	
		$UMOUNT -l /dev/mapper/${_swap_vol_name_} >> /dev/null 2>&1

		# Add the volume to swap
		log_msg -s "Adding Logical Volume ${_swap_vol_name_} to swap" -l ${LOGFILE}
		$MKSWAP /dev/mapper/${_swap_vol_name_} >> ${LOGFILE}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not add Logical Volume `$BASENAME ${_swap_vol_name_}` to swap"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		else
			log_msg -s "Successfully added ${_swap_vol_name_} to swap" -l ${LOGFILE}
		fi

		$SWAPON /dev/mapper/${_swap_vol_name_} >> /dev/null 2>&1
		if [ $? -ne 0 ]; then
			_err_msg_="Could not activate swap volume ${_swap_vol_name_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		log_msg -s "Adding entry of ${_swap_vol_name_} in fstab" -l ${LOGFILE}
		$ECHO "/dev/mapper/${_swap_vol_name_} swap					swap	auto,rw		0 0" >> ${FSTAB}
	fi
else

	if [ -s ${ENIQ_CONF_DIR}/extra_params/deployment ]; then
		_deployment_=`$CAT ${ENIQ_CONF_DIR}/extra_params/deployment`
	else
		_err_msg_="Parameter \"deployment\" incorrectly specified, or is missing from boot command"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	 log_msg -s "Creating a list of volume groups from ${ENIQ_CONF_DIR}/${SUNOS_INI}\n" -l ${LOGFILE}
	_pool_list_=`iniget SunOS_FS_POOL -f ${ENIQ_CONF_DIR}/${SUNOS_INI}`
	for _pool_ in ${_pool_list_}; do
	   _pool_name_=`iniget ${_pool_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v name`
	   if [ ! "${_pool_name_}" ]; then
		  _err_msg_="Could not determine Volume Group ${_pool_name_}"
		  abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	   fi
	done

	# Getting the size of Volume Group
	 _vg_size_=`$VGS ${_pool_name_} --noheadings -o vg_size | $SED -e 's/[^0-9.]//g'`
	if [ ! "${_vg_size_}" ]; then
		  _err_msg_="Could not determine Volume Group size"
		  abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	 _vg_size_unit_=`$VGS ${_pool_name_} --noheadings -o vg_size | $SED -e 's/[^a-z]//g'`
	if [ ! "${_vg_size_unit_}" ]; then
		  _err_msg_="Could not determine Volume Group size unit"
		  abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	if [ "${_vg_size_unit_}" == "t" ]; then
		 _vg_size_=`$ECHO " scale=4; ${_vg_size_}*1024" | $BC`
	fi

	#Getting Volume Group size excluding swap volume
	if [ "${_deployment_}" == "small" -o "${_deployment_}" == "ft" ]; then
		_avail_pool_size_=`$ECHO " scale=4; ${_vg_size_} - ${MAX_16G_SWAP} - ${MAX_16G_SWAP}" | $BC`
		if [ ! "${_avail_pool_size_}"  ]; then
			_err_msg_="Could not determine avaialable pool size in ${_pool_name_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
		#Making available pool size to half for Comapct deployments
		_avail_pool_size_=`$ECHO " scale=4; ${_avail_pool_size_}/2" | $BC`
		 if [ ! "${_avail_pool_size_}"  ]; then
			_err_msg_="Could not determine avaialable pool size in ${_pool_name_} for Comapct deployment"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

	else
		_avail_pool_size_=`$ECHO " scale=4; ${_vg_size_} - ${MAX_16G_SWAP}" | $BC`
		if [ ! "${_avail_pool_size_}"  ]; then
			_err_msg_="Could not determine avaialable pool size in ${_pool_name_} "
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi

	log_msg -s "Setting Available pool size for FLS Filesystem in ${ENIQ_CONF_DIR}/${SUNOS_INI}\n" -l ${LOGFILE}
	iniset eniq_stats_fls_available_size -f ${ENIQ_CONF_DIR}/${SUNOS_INI} aval_fs_size_for_fls="${_avail_pool_size_}"
	if [ $? -ne 0 ]; then
		 _err_msg_="Could not update ${ENIQ_CONF_DIR}/${SUNOS_INI} for avail_fs_size_for_fls"
		 abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi


	if [ ! "${MIGRATION}" ]; then
		# Getting the tag for FS size based on server type
		get_fs_size_tag

		# Getting current hardware generation
		_hard_gen_=`$DMIDECODE -s system-product-name | $AWK -F " " '{print $2}'`
		if [ ! "${_hard_gen_}" ]; then
			 _err_msg_="Could not determine current hardware generation"
			 abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		_fs_size_tag_=${_hard_gen_}_${_fs_size_tag_}


		log_msg -s "Creating list of file systems from ${ENIQ_CONF_DIR}/${SUNOS_INI}\n" -l ${LOGFILE}

		_fs_list_=`iniget SunOS_ZFS_FS -f ${ENIQ_CONF_DIR}/${SUNOS_INI}`
		for _fs_ in ${_fs_list_}; do
			_fs_name_=`iniget ${_fs_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v name`
			_fs_mount_pt_=`iniget ${_fs_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v mountpoint`
			_fs_perms_=`iniget ${_fs_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v perms`
			_fs_vg_=`$ECHO ${_fs_name_} | $AWK -F\- '{print $1}'`
			_fs_lv_=`$ECHO ${_fs_name_} | $AWK -F\- '{print $2}'`
			_fs_size_=`iniget ${_fs_size_tag_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v "${_fs_lv_}" | $AWK -F ":" '{print $1}'`
			_fs_overhead_=`iniget ${_fs_size_tag_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v "${_fs_lv_}" | $AWK -F ":" '{print $3}'`
			if [ ! "${_fs_name_}" -o ! "${_fs_mount_pt_}" -o ! "${_fs_perms_}" -o ! "${_fs_vg_}" -o ! "${_fs_lv_}" -o ! "${_fs_size_}" -o ! "${_fs_overhead_}" ]; then
				_err_msg_="Could not read FS parameters from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			_final_fs_size_=`$ECHO "scale=6; ${_fs_size_}/100" | $BC`

			_size_fs_=`$ECHO " scale=4; ${_avail_pool_size_}*${_final_fs_size_}" | $BC`
			if [ ! "${_size_fs_}"  ]; then
				_err_msg_="Could not determine fs size of ${_fs_name_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			_size_fs_min_=`iniget FS_MIN_SIZE -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ${_fs_lv_}`
			if [  "${_size_fs_min_}"  ]; then
				  if [ "$($ECHO "${_size_fs_} < ${_size_fs_min_}" | bc)" -eq 1 ]; then
						_size_fs_="${_size_fs_min_}"
				  fi
			fi

			$VGDISPLAY ${_fs_vg_} >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Could not locate FS volume group - ${_fs_vg_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			# Destroy the FS if it exists
			$RM -rf ${_fs_mount_pt_}/* >> /dev/null 2>&1
		
			$UMOUNT -l ${_fs_mount_pt_} >> /dev/null 2>&1
			log_msg -s "Removing the ${_fs_name_} filesystem" -l ${LOGFILE}
			$LVREMOVE -y /dev/${_fs_vg_}/${_fs_lv_} >> /dev/null 2>&1
		
			if [ -f "${FSTAB}" ]; then
				if  ${EGREP} -q ${_fs_vg_}-${_fs_lv_} ${FSTAB}
				then
					$SED -i "/${_fs_vg_}-${_fs_lv_}/d" ${FSTAB} >> /dev/null 2>&1
					if [ $? -ne 0 ]; then
						_err_msg_="Could not delete Mount Point in ${FSTAB} file"
						abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
					fi
				fi
			else
				_err_msg_="Could not locate ${FSTAB} file"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
			if  [ "${_deployment_}" == "small" -o "${_deployment_}" == "ft" ]; then
				log_msg -s "Creating fileSystem `$BASENAME ${_fs_name_}`" -l ${LOGFILE}
				$LVCREATE -y --type mirror -L ${_size_fs_}G -m1 -n ${_fs_lv_} ${_fs_vg_}  >> /dev/null 2>&1
				if [ $? -ne 0 ]; then
					_err_msg_="Could not create FS logicalvolume  - ${_fs_lv_}"
					abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				fi
			else
				log_msg -s "Creating fileSystem `$BASENAME ${_fs_name_}`" -l ${LOGFILE}
				$LVCREATE -y -L ${_size_fs_}G -n ${_fs_lv_} ${_fs_vg_}  >> /dev/null 2>&1
				if [ $? -ne 0 ]; then
					_err_msg_="Could not create FS logicalvolume  - ${_fs_lv_}"
					abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				fi
		
			fi
			$UMOUNT -l ${_fs_mount_pt_} >> /dev/null 2>&1
		
			log_msg -s "Formatting fileSystem `$BASENAME ${_fs_name_}` with ${FS_TYPE} filesystem" -l ${LOGFILE}
			${MKFS_EXT4} -m ${_fs_overhead_}  /dev/${_fs_vg_}/${_fs_lv_} >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Could not format FS `$BASENAME ${_fs_name_}` with ${FS_TYPE} "
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
			log_msg -s "Creating Mount Point" -l ${LOGFILE}
			$MKDIR -p ${_fs_mount_pt_}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not create Mount Point"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			log_msg -s "Updating ${FSTAB} file with filesystem `$BASENAME ${_fs_name_}` on ${_fs_mount_pt_}\n" -l ${LOGFILE}
			$ECHO "/dev/mapper/${_fs_vg_}-${_fs_lv_} ${_fs_mount_pt_}				   ${FS_TYPE}	defaults	   0 2" >> ${FSTAB}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not Update ${FSTAB} file with filesystem `$BASENAME ${_fs_name_}` on ${_fs_mount_pt_} and Reverting back to original fstab file"
				#Reverting back to original fstab file
				$MV ${FSTAB}_orig ${FSTAB}
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		done
		$MOUNT -a >> /dev/null 2>&1
		if [ $? -ne 0 ]; then
			_err_msg_="Could not mount filesystem"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi

        ##Updating /etc/lvm/lvm.conf file with snapshot autoextend parameters
        if [ ! -f /etc/lvm/lvm.conf.orig ]; then
             $CP -p /etc/lvm/lvm.conf /etc/lvm/lvm.conf.orig >> /dev/null 2>&1
             if [ $? -ne 0 ]; then
                  _err_msg_="Could not make backup of /etc/lvm/lvm.conf"
                  abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
             fi
        fi

        ##Set autoextend threshold to 90%
        $SED -i 's/snapshot_autoextend_threshold = 100/snapshot_autoextend_threshold = 90/g' /etc/lvm/lvm.conf >> /dev/null 2>&1
        if [ $? -ne 0 ]; then
             _err_msg_="Could not set snapshot_autoextend_threshold to 90 in /etc/lvm/lvm.conf"
             abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
        fi

        ##Set autoextend percent to 10%
        $SED -i 's/snapshot_autoextend_percent = 20/snapshot_autoextend_percent = 10/g' /etc/lvm/lvm.conf >> /dev/null 2>&1
        if [ $? -ne 0 ]; then
             _err_msg_="Could not set snapshot_autoextend_percent to 10 in /etc/lvm/lvm.conf"
             abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
        fi

        ##Restarting lvm2-monitor service
        $SYSTEMCTL restart lvm2-monitor
        if [ $? -ne 0 ]; then
             _err_msg_="Failed to restart lvm2-monitor service"
             abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
        fi

	# Create the swap partition
	if [ "${INSTALL_TYPE}" == "stats"  ]; then
		_total_mem_=`$FREE -g | $EGREP Mem | $AWK '{print $2}'`
		if [  "${CURR_SERVER_TYPE}" == "stats_coordinator" -o "${CURR_SERVER_TYPE}" == "eniq_stats" ]; then
			MAX_SWAP=${MAX_16G_SWAP}
		else
			MAX_SWAP=${MAX_8G_SWAP}
		fi

		if [ ${_total_mem_} -gt ${MAX_SWAP} ]; then
			_swap_vol_size_=${MAX_SWAP}
		else
			_swap_vol_size_=${_total_mem_}
		fi

		#Removing swap filesystem if already exist
		remove_swap_fs

		#Create the swap FS
		_vg_=`$ECHO ${_swap_vol_name_} | $AWK -F - '{print $1}'`
		_lv_=`$ECHO ${_swap_vol_name_} | $AWK -F - '{print $2}'`
		if [ ! "${_vg_}" -o ! "${_lv_}" ]; then
			_err_msg_="Could not determine swap volume group ${_vg_} and logical volume  ${_lv_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
		if  [ "${_deployment_}" == "small" -o "${_deployment_}" == "ft" ]; then
			log_msg -s "Creating fileSystem `$BASENAME ${_swap_vol_name_}`" -l ${LOGFILE}
			$LVCREATE -y --type mirror -L ${_swap_vol_size_}G  -m1 -n ${_lv_} ${_vg_} >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Could not create swap volume `$BASENAME ${_swap_vol_name_}`"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		else
			log_msg -s "Creating fileSystem `$BASENAME ${_swap_vol_name_}`" -l ${LOGFILE}
			$LVCREATE -y -L ${_swap_vol_size_}G -n ${_lv_} ${_vg_} >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Could not create swap volume `$BASENAME ${_swap_vol_name_}`"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		fi
		
		$UMOUNT -l /dev/mapper/${_swap_vol_name_} >> /dev/null 2>&1

		# Add the volume to swap
		log_msg -s "Adding Logical Volume ${_swap_vol_name_} to swap" -l ${LOGFILE}
		$MKSWAP /dev/mapper/${_swap_vol_name_} >> ${LOGFILE}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not add Logical Volume `$BASENAME ${_swap_vol_name_}` to swap"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		else
			log_msg -s "Successfully added ${_swap_vol_name_} to swap" -l ${LOGFILE}
		fi

		$SWAPON /dev/mapper/${_swap_vol_name_} >> /dev/null 2>&1
		if [ $? -ne 0 ]; then
			_err_msg_="Could not activate swap volume ${_swap_vol_name_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		log_msg -s "Adding entry of ${_swap_vol_name_} in fstab" -l ${LOGFILE}
		$ECHO "/dev/mapper/${_swap_vol_name_} swap					swap	defaults		0 0" >> ${FSTAB}
	fi
fi

insert_header_footer foot "Successfully created FS filesystems" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}


### Function: create_volume_group ###
#
# Destroys any existing volume groups and creates
# the new ones
#
# Arguments:
#   none
# Return Values:
#   none
create_volume_group()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type
if [ $? -ne 0 ]; then
	_err_msg_="Could not get the value of storage type"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
if [ "${STORAGE_TYPE}" == "raw" ]; then
	# Make a backup of fstab file
	if [ -f "${FSTAB}" ]; then
		log_msg -s "Backing up original ${FSTAB} file to ${FSTAB}_orig" -l ${LOGFILE}
		$CP -p ${FSTAB} ${FSTAB}_orig
		if [ $? -ne 0 ]; then
			_err_msg_="Could not copy ${FSTAB} to ${FSTAB}_orig"
			abort_script "${_err_msg_}"
		fi
	else
		_err_msg_="Unable to find ${FSTAB} file"
		abort_script "${_err_msg_}"
	fi

	###if Stats
	if [ "${INSTALL_TYPE}" == "stats" ]; then
		#Removing swap filesystem if already exist
		remove_swap_fs
	fi

	#Destroy volume group other than vg_root
	$VGIMPORT --all >>/dev/null 2>&1  #Import volume group if any

	_vg_list_=`$VGS --no-headings -o vg_name | $GREP -v vg_root`

	for _vg_ in ${_vg_list_}; do
		_lv_list_=`$LVS --no-headings -o lv_name ${_vg_}` >> /dev/null 2>&1
		for _lv_ in ${_lv_list_}; do
			#Unmount the LV
			$UMOUNT -f /dev/mapper/${_vg_}-${_lv_} >>/dev/null 2>&1
			#Remove LV
			$LVREMOVE -f /dev/mapper/${_vg_}-${_lv_} >>/dev/null 2>&1 
		done
		log_msg -s "Destroying ${_vg_}" -l ${LOGFILE}
		$VGREMOVE -f ${_vg_} >>/dev/null 2>&1
	done

	log_msg -s "Creating volume group from ${ENIQ_CONF_DIR}/${SUNOS_INI}\n" -l ${LOGFILE}
	_pool_list_=`iniget SunOS_FS_POOL -f ${ENIQ_CONF_DIR}/${SUNOS_INI}`
	if [ ! "${_pool_list_}" ]; then
		_err_msg_="Could not get FS pool list"
		abort_script "${_err_msg_}" 
	fi

	for _pool_ in ${_pool_list_}; do
		_pool_name_=`iniget ${_pool_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v name`
		if [ ! "${_pool_name_}" ]; then
			_err_msg_="Could not get FS pool name"
			abort_script "${_err_msg_}" 
		fi
		_pool_disk_layout_=`iniget ${_pool_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v disk_layout`
		if [ ! "${_pool_disk_layout_}" ]; then
			_err_msg_="Could not get FS pool disk layout"
			abort_script "${_err_msg_}" 
		fi

		if [ "${_san_device_}" == "local" ]; then
			#Check whether disk partition is created or not
			$PARTED /dev/${_pool_disk_layout_} -s  print | $AWK '$1+0'  | $GREP 1  >>/dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Disk partition /dev/${_pool_disk_layout_}${PARTITION_NUM} is not present"
				abort_script "${_err_msg_}" 
			fi

			log_msg -s "Creating Physical Volume /dev/${_pool_disk_layout_}${PARTITION_NUM}" -l ${LOGFILE}
			$PVCREATE /dev/${_pool_disk_layout_}${PARTITION_NUM} >>/dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Could not create Physical Volume /dev/${_pool_disk_layout_}${PARTITION_NUM}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			else
				log_msg -s "Physical Volume /dev/${_pool_disk_layout_}${PARTITION_NUM} created\n" -l ${LOGFILE}
			fi

			log_msg -s "Creating volume group ${_pool_name_}" -l ${LOGFILE}
			log_msg -s "$VGCREATE ${_pool_name_} /dev/${_pool_disk_layout_}1" -l ${LOGFILE}
			$VGCREATE ${_pool_name_} /dev/${_pool_disk_layout_}${PARTITION_NUM} | $TEE -a ${LOGFILE} >>/dev/null 2>&1
			_rc_vgcreate_=`$ECHO ${PIPESTATUS[0]}`
			if [ ${_rc_vgcreate_} -ne 0 ]; then
				abort_script "Failed to create volume group ${_pool_name_}\nExiting...." "${EXEC_SHELL_CMD}"
			else
				log_msg -s "volume group ${_pool_name_} created\n" -l ${LOGFILE}
			fi
	
		else
			#Check whether disk partition is created or not
			$PARTED /dev/mapper/${_pool_disk_layout_} -s  print | $AWK '$1+0' | $GREP 1 >>/dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Disk partition /dev/mapper/${_pool_disk_layout_}${PARTITION_NUM} is not present"
				abort_script "${_err_msg_}" 
			fi

			log_msg -s "Creating Physical Volume /dev/mapper/${_pool_disk_layout_}${PARTITION_NUM}" -l ${LOGFILE}
			$PVCREATE /dev/mapper/${_pool_disk_layout_}${PARTITION_NUM} >>/dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Could not create Physical Volume /dev/mapper/${_pool_disk_layout_}${PARTITION_NUM}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			else
				log_msg -s "Physical Volume /dev/mapper/${_pool_disk_layout_}${PARTITION_NUM} created\n" -l ${LOGFILE}
			fi

			log_msg -s "Creating volume group ${_pool_name_}" -l ${LOGFILE}
			log_msg -s "$VGCREATE ${_pool_name_} /dev/mapper/${_pool_disk_layout_}1" -l ${LOGFILE}
			$VGCREATE ${_pool_name_} /dev/mapper/${_pool_disk_layout_}${PARTITION_NUM} | $TEE -a ${LOGFILE} >>/dev/null 2>&1
			_rc_vgcreate_=`$ECHO ${PIPESTATUS[0]}`
			if [ ${_rc_vgcreate_} -ne 0 ]; then
				abort_script "Failed to create volume group ${_pool_name_}\nExiting...." "${EXEC_SHELL_CMD}"
			else
				log_msg -s "volume group ${_pool_name_} created\n" -l ${LOGFILE}
			fi
		fi
	done

else 
	
	# Make a backup of fstab file
	if [ -f "${FSTAB}" ]; then
		log_msg -s "Backing up original ${FSTAB} file to ${FSTAB}_orig" -l ${LOGFILE}
		$CP -p ${FSTAB} ${FSTAB}_orig
		if [ $? -ne 0 ]; then
			_err_msg_="Could not copy ${FSTAB} to ${FSTAB}_orig"
			abort_script "${_err_msg_}"
		fi
	else
		_err_msg_="Unable to find ${FSTAB} file"
		abort_script "${_err_msg_}"
	fi

	###if Stats
	if [ "${INSTALL_TYPE}" == "stats" ]; then
	   #Removing swap filesystem if already exist
	   remove_swap_fs
	fi

	#Destroy volume group other than vg_root
	$VGIMPORT --all >>/dev/null 2>&1  #Import volume group if any

	_vg_list_=`$VGS --no-headings -o vg_name | $GREP -v vg_root`

	for _vg_ in ${_vg_list_}; do
		_lv_list_=`$LVS --no-headings -o lv_name ${_vg_}` >> /dev/null 2>&1
		for _lv_ in ${_lv_list_}; do
			#Unmount the LV
			$UMOUNT -f /dev/map${_vg_}-${_lv_} >>/dev/null 2>&1
			#Remove LV
			$LVREMOVE -f /dev/${_vg_}-${_lv_} >>/dev/null 2>&1 
		done
		log_msg -s "Destroying ${_vg_}" -l ${LOGFILE}
		$VGREMOVE -f ${_vg_} >>/dev/null 2>&1
	done

	log_msg -s "Creating volume group from ${ENIQ_CONF_DIR}/${SUNOS_INI}\n" -l ${LOGFILE}
	_pool_list_=`iniget SunOS_FS_POOL -f ${ENIQ_CONF_DIR}/${SUNOS_INI}`
	if [ ! "${_pool_list_}" ]; then
		_err_msg_="Could not get FS pool list"
		abort_script "${_err_msg_}" 
	fi

	for _pool_ in ${_pool_list_}; do
		_pool_name_=`iniget ${_pool_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v name`
		if [ ! "${_pool_name_}" ]; then
			_err_msg_="Could not get FS pool name"
			abort_script "${_err_msg_}" 
		fi
		_pool_disk_layout_=`iniget ${_pool_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v disk_layout`
		if [ ! "${_pool_disk_layout_}" ]; then
			_err_msg_="Could not get FS pool disk layout"
			abort_script "${_err_msg_}" 
		fi

		for _disk_ in ${_pool_disk_layout_}; do
			#Check whether disk partition is created or not
			$PARTED /dev/${_disk_} -s  print | $AWK '$1+0'  | $GREP 1  >>/dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Disk partition /dev/${_disk_}${PARTITION_NUM} is not present"
				abort_script "${_err_msg_}" 
			fi
			$ECHO ${_disk_} | $SED "s/${_disk_}/\/dev\/"${_disk_}""${PARTITION_NUM}"/g" >> ${TEM_DIR}/disk.txt			
		done
		
		if [ -s ${TEM_DIR}/disk.txt ]; then
			_pool_disk_layout_=`$SED ':a;N;$!ba;s/\n/ /g' ${TEM_DIR}/disk.txt`
		else
			_err_msg_="${TEM_DIR}/disk.txt is not present"
			abort_script "${_err_msg_}"
		fi
		
		log_msg -s "Creating Physical Volume of disks ${_pool_disk_layout_}" -l ${LOGFILE}
		$PVCREATE ${_pool_disk_layout_} >>/dev/null 2>&1
		if [ $? -ne 0 ]; then
			 _err_msg_="Could not create Physical Volume of disks ${_pool_disk_layout_}"
			 abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		else
		log_msg -s "Physical Volume ${_pool_disk_layout_} created\n" -l ${LOGFILE}
		fi

		log_msg -s "Creating volume group ${_pool_name_}" -l ${LOGFILE}
		log_msg -s "$VGCREATE ${_pool_name_} ${_pool_disk_layout_}" -l ${LOGFILE}
		$VGCREATE ${_pool_name_} ${_pool_disk_layout_} | $TEE -a ${LOGFILE} >>/dev/null 2>&1
		_rc_vgcreate_=`$ECHO ${PIPESTATUS[0]}`
		if [ ${_rc_vgcreate_} -ne 0 ]; then
			 abort_script "Failed to create volume group ${_pool_name_}\nExiting...." "${EXEC_SHELL_CMD}"
		else
			 log_msg -s "volume group ${_pool_name_} created\n" -l ${LOGFILE}
		fi
	
	done
fi

insert_header_footer foot "Successfully created volume group" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: delete_nas_filesystems ###
#
# Delete filesystems on NAS
#
# Arguments:
#   none
# Return Values:
#   none
delete_nas_filesystems()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" == "fs" ]; then
	insert_header_footer foot "FS Install - Skipping core install stage - ${NEXT_STAGE} " ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

_nas_sysid_=`iniget Storage_NAS_GENERAL -f ${ENIQ_CONF_DIR}/${STORAGE_INI} -v SYS_ID`
if [ ! "${_nas_sysid_}" ]; then
	_err_msg_="Could not get NAS sysid value from ${ENIQ_CONF_DIR}/${STORAGE_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_nas_sw_target_dir_=`iniget NAS_STORAGE_API -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v NAS_API_TARGET_DIR`
if [ ! "${_nas_sw_target_dir_}" ]; then
	_err_msg_="Failed to get NAS API target dir information from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_nascli_=${_nas_sw_target_dir_}/bin/nascli
if [ ! -s ${_nascli_} ]; then
	_err_msg_="${_nascli_} not found"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$ECHO "Deleting any existing NAS filesystems with '${_nas_sysid_}' as the identifier" | $TEE -a ${LOGFILE}
${_nascli_} delete_fs ${_nas_sysid_}
if [ $? -ne 0 ]; then
	_err_msg_="Could not delete filesystems with '${_nas_sysid_}' as the identifier"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

insert_header_footer foot "Successfully deleted filesystems on NAS" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: enable_mpxio ###
#
# Enable mpxio on Solaris X86 box
#
# Arguments:
#	   none
# Return Values:
#	   none
enable_mpxio()
{
_mounted_root_=${1}
if [ ! -d /kernel ]; then
	_err_msg_="Cannot locate directory /kernel"
	abort_script "${_err_msg_}"
fi

# Turn off MPXIO
if [ -s /kernel/drv/fp.conf ]; then
	if [ ! -s /kernel/drv/fp.conf.orig ]; then
		$CP /kernel/drv/fp.conf /kernel/drv/fp.conf.orig
	fi
	$SED -e 's|^[	   ]*mpxio-disable=.*|mpxio-disable="no";|' /kernel/drv/fp.conf > ${TEM_DIR}/fp.conf
	$CP ${TEM_DIR}/fp.conf /kernel/drv/fp.conf
fi

# Update MPXIO settings if not Solaris 10
if [ ! "${SOLARIS_10}" ];then
	_file_time_=`$DATE '+%Y%m%d_%H%M%S'`
	_fp_conf_=/etc/driver/drv/fp.conf
	if [ -s ${_fp_conf_} ]; then
		$CP ${_fp_conf_} ${_fp_conf_}.${_file_time_}
		$SED -e 's|^[	   ]*mpxio-disable=.*|mpxio-disable="no";|' ${_fp_conf_} > ${TEM_DIR}/fp.conf
		if [ ! -s ${TEM_DIR}/fp.conf ];then
			_err_msg_="Could not update ${_fp_conf_} file."
			abort_script ${_err_msg_}
		fi
		$CP ${TEM_DIR}/fp.conf ${_fp_conf_}
		if [ $? -ne 0 ];then
			_err_msg_="Unable to save updated ${_fp_conf_} file."
			abort_script ${_err_msg_}
		fi
	fi
fi
}

### Function: generate_keys ###
#
# Generate ssh keys for root
#
# Arguments:
#	none
# Return Values:
#	none
generate_keys()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

if [ "${SERVER_TYPE}" != "CO" ]; then
	insert_header_footer foot "Non-coordinator install - skipping core install stage - ${NEXT_STAGE} " ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

if [ ! -s ${ENIQ_COMMON_SW_DIR}/connectd/bin/generate_ssh_key.bsh ]; then
	_err_msg_="Could not find ${ENIQ_COMMON_SW_DIR}/connectd/bin/generate_ssh_key.bsh script"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Set an upgrade flag if required
_upg_flag_=""
if [ "${UPGRADE}" ]; then
	_upg_flag_="-U"
fi

# Generate the ssh keys
$ECHO "\nCreating ssh keys for \"root\"" | $TEE -a ${LOGFILE}
/usr/bin/bash ${ENIQ_COMMON_SW_DIR}/connectd/bin/generate_ssh_key.bsh -u root ${_upg_flag_} -l ${LOGFILE}
if [ $? -ne 0 ]; then
	_err_msg_="Could not generate ssh keys for \"root\""
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Extra check to ensure the public key is there
if [ ! -s ${ROOT_HOME}/.ssh/id_rsa.pub ]; then
	_err_msg_="${ROOT_HOME}/.ssh/id_rsa.pub does not exist after key generation"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Copy the public key to the NAS
if [ -d ${ENIQ_ADMIN_DIR}/etc ]; then
	$ECHO "Copying ${ROOT_HOME}/.ssh/id_rsa.pub shared area" >> ${LOGFILE}
	$CP ${ROOT_HOME}/.ssh/id_rsa.pub ${ENIQ_ADMIN_DIR}/etc/
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy /.ssh/id_rsa.pub to shared area"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
else
	_err_msg_="${ENIQ_ADMIN_DIR}/etc does not exist, or is not a directory"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

insert_header_footer foot "Successfully completed core install stage - ${NEXT_STAGE}" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: get_all_services ###
#
# Create a list of all ENIQ services from contract file
#
# Arguments:
#	  None
# Return Values:
#	  Service list
get_all_services()
{
$RM -rf ${TEM_DIR}/eniq_service_list $TEM_DIR/server_type_contracts

# Get the services tagged as "ENIQ" in the contracts file
$CAT ${SVC_CONTRACT_INFO} | $EGREP ${CURR_SERVER_TYPE} | $EGREP "${MANAGED_STR}" > $TEM_DIR/server_type_contracts
if [ ! -s $TEM_DIR/server_type_contracts ]; then
	_err_msg_="Could not parse services for ${CURR_SERVER_TYPE} server from ${SVC_CONTRACT_INFO}"
	abort_script "${_err_msg_}"
fi

unset _service_list_

# Create a list of servers for this server type
while read _line_; do
	_service_name_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
	_service_opt_=`$ECHO ${_line_} | $AWK -F"::" '{print $4}'`
	if [ "${_service_opt_}" == "Y" ]; then
		if [ "${_service_name_}" == "fls" ]; then
			if [ ! -s ${ENIQ_CONF_DIR}/fls_conf ]; then
				# Checking if FLS is configured or not
				continue
			fi
		fi
		if [ ! "${_service_list_}" ]; then
			_service_list_=${_service_name_}
		else
			_service_list_="${_service_list_} ${_service_name_}"
		fi
	fi
done < $TEM_DIR/server_type_contracts
}

### Function: get_absolute_path ###
#
# Determine absolute path to software
#
# Arguments:
#   none
# Return Values:
#   none
get_absolute_path()
{
_dir_=`$DIRNAME $0`
SCRIPTHOME=`cd $_dir_ 2>/dev/null && pwd || $ECHO $_dir_`
}

### Function: get_array_element ###
#
# Get the current array element number
#
# Arguments:
#   none
# Return Values:
#   none
get_array_element()
{
_num_elements_=${#ENIQ_CORE_STAGES[*]}
_array_length_=`${EXPR} ${_num_elements_} - 1`

for (( _elem_=0; _elem_<=${_array_length_}; _elem_++ )); do
	$ECHO ${ENIQ_CORE_STAGES[${_elem_}]} | $GREP -w ${NEXT_STAGE} >> /dev/null 2>&1
	if [ $? -eq 0 ]; then
		ARRAY_ELEM=${_elem_}
		break
	fi
done
}

### Function: get_feature_dir ###
#
# Get the feature software path 
#
# Arguments:
#   none
# Return Values:
#   none
get_feature_dir()
{
#Set up Variable to hold feature path
if [ -s ${ENIQ_CONF_DIR}/eniq_feature_locate ]; then
	FEATURE_SW_LOCATE=${ENIQ_CONF_DIR}/eniq_feature_locate
else
	_err_msg_="Could not set up variable to hold feature path"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

FEATURE_SW_DIR=`$CAT ${FEATURE_SW_LOCATE}`
if [ "${FEATURE_SW_DIR}" ]; then
	SW_DIR=${FEATURE_SW_DIR}
else
	_err_msg_="Could not determine path to feature SW"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
}

### Function: get_san_agent_inter_ip ###
#
# Read the name of the IP address of interface that the
# Storage Agent will listen on
#
# Arguments:
#	$1 : San type
#	$2 : First Time indicator
# Return Values:
#	none
get_san_agent_inter_ip()
{
local _ip_list_arr_

_deployment_=`$CAT ${ENIQ_CONF_DIR}/extra_params/deployment`

if [ "${_deployment_}" == "ft" ]; then
	_ip_list_arr_=`iniget IPMP_INTF_1 -f ${ENIQ_CONF_DIR}/${IPMP_INI} -v IPMP_Group_IP`
else
	_ip_list_arr_=`iniget IPMP_INTF_2 -f ${ENIQ_CONF_DIR}/${IPMP_INI} -v IPMP_Group_IP`
fi

if [ ${#_ip_list_arr_[@]} -eq 0 ]; then
	_err_msg_="No suitable interfaces found for accessing storage devices"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_disp_file_=${TEM_DIR}/disp_file
$RM -f ${_disp_file_}

if [ -s ${ENIQ_CONF_DIR}/${BLK_STOR_INI} ]; then
	# Figure out default IP address (if set)
	_def_ip_=`iniget BLK_STORAGE_INTERF -f ${ENIQ_CONF_DIR}/${BLK_STOR_INI} -v BLK_STORAGE_INTERF_IP`
fi

$ECHO "\n Host Agent IP Address(s)" >> ${_disp_file_}
$ECHO "-------------------------------" >> ${_disp_file_}
_cnt_=${#_ip_list_arr_[@]}
_menu_opt_=0
unset _def_menu_opt_

for (( i=0; i<${_cnt_}; i++)); do
	let _menu_opt_=_menu_opt_+1
	$ECHO "[${_menu_opt_}]  ${_ip_list_arr_[${i}]}" >> ${_disp_file_}
	if [ "${_def_ip_}" == "${_ip_list_arr_[${i}]}" ]; then
		_def_menu_opt_=${_menu_opt_}
	fi
done

while :; do
	clear
	$CAT ${_disp_file_}

	$ECHO "\n\nSelect the IP Address you wish the Storage Agent"
	$ECHO "to listen on"
	read _opt_

	# If the User hit nothing
	if [ ! "${_opt_}" ]; then
		continue
	fi

	$ECHO ${_opt_} | $EGREP '[^0-9]' >> /dev/null 2>&1
	if [ $? -eq 0 ]; then
		continue
	fi

	if [ ${_opt_} -lt 1 -o ${_opt_} -gt ${_menu_opt_} ]; then
		continue
	fi

	break
done

# Set up file if required
if [ ! -s ${ENIQ_CONF_DIR}/${BLK_STOR_INI} ]; then
	$ECHO "[BLK_STORAGE_INTERF]" >> ${ENIQ_CONF_DIR}/${BLK_STOR_INI}
	$ECHO "BLK_STORAGE_INTERF_IP=" >> ${ENIQ_CONF_DIR}/${BLK_STOR_INI}
	$ECHO "\n\n[BLK_STORAGE_DEV_DETAILS]\n" >> ${ENIQ_CONF_DIR}/${BLK_STOR_INI}
fi

# Make a working copy of file
$CP ${ENIQ_CONF_DIR}/${BLK_STOR_INI} ${TEM_DIR}/${BLK_STOR_INI}
if [ $? -ne 0 ]; then
	_err_msg_="Could not copy ${ENIQ_CONF_DIR}/${BLK_STOR_INI} to ${TEM_DIR}/${BLK_STOR_INI}"
	abort_script "${_err_msg_}"
fi

# Set the pointer
_array_pnt_=`$EXPR ${_opt_} - 1`

# Store the value
SAN_AGENT_IP_ADDR="${_ip_list_arr_[${_array_pnt_}]}"

# Update the temp ini file
iniset BLK_STORAGE_INTERF -f ${TEM_DIR}/${BLK_STOR_INI} BLK_STORAGE_INTERF_IP="${_ip_list_arr_[${_array_pnt_}]}"
if [ $? -ne 0 ]; then
	_err_msg_="Error adding BLK_STORAGE_INTERF_IP to ${ENIQ_CONF_DIR}/${BLK_STOR_INI}"
	abort_script "${_err_msg_}"
fi

$CP ${TEM_DIR}/${BLK_STOR_INI} ${ENIQ_CONF_DIR}/${BLK_STOR_INI}
if [ $? -ne 0 ]; then
	_err_msg_="Could not copy ${ENIQ_CONF_DIR}/${BLK_STOR_INI} to ${TEM_DIR}/${BLK_STOR_INI}"
	abort_script "${_err_msg_}"
fi
}

### Function: get_SAN_details ###
#
# Configure storage API
#
# Arguments:
#	$1 : San type
# Return Values:
#	none
get_SAN_details()
{
while :; do
	clear
	unset SAN_NUM_SRVRS

	$ECHO "\nHow many SANs are in the deployment?"
	read SAN_NUM_SRVRS

	#if user enter nothing loop
	if [ ! "${SAN_NUM_SRVRS}" ]; then
		continue
	fi

	#must enter a number if not loop
	$ECHO "${SAN_NUM_SRVRS}" | $EGREP '[^0-9]' >> /dev/null 2>&1
	if [ $? -eq 0 ]; then
		continue
	fi
	#if they enter 0 no SAN servers to install so break out and set SAN_USR_CHOICE to No for ini file
	#else they've entered a num greater than 1 so set SAN_USR_CHOICE to Yes for ini file
	if [ ${SAN_NUM_SRVRS} -le 0 ]; then

		continue

	fi

	break
done
}

### Function: get_san_device_name ###
#
# Read the name of the SAN Storage Device
#
# Arguments:
#	$1 : San num
#	global variable ${SAN_NUM_SRVRS}
# Return Values:
#	none
get_san_device_name()
{
local _user_input_ _blk_stor_det_ _err_
local _new_dev_cnt_ _old_dev_cnt_ _dev_name_

clear
while :; do
	$ECHO "\n\nEnter name of SAN ${_san_num_} ( ${_san_num_} of ${SAN_NUM_SRVRS})"

	read _user_input_

	# Did user enter anything
	if [ ! "${_user_input_}" ]; then
		continue
	fi

	# Is user allowed enter quit
	if [ "${_user_input_}" == "quit" ] ; then
		if [ ${_first_time_} -eq 0 ]; then
			continue
		fi
		SAN_DEV_NAME="${_user_input_}"
		return 0
	fi

	# Is it already specified in ${TEM_DIR}/${BLK_STOR_INI}
	_err_=0
	for  _blk_stor_det_ in `iniget BLK_STORAGE_DEV_DETAILS -f ${TEM_DIR}/${BLK_STOR_INI}`; do
		_dev_name_=`iniget ${_blk_stor_det_} -f ${TEM_DIR}/${BLK_STOR_INI} -v BLK_STORAGE_NAME`
		if [ "${_dev_name_}" == "${_user_input_}" ]; then
			_err_=1
			break
		fi
	done

	# Was it already found
	if [ ${_err_} -eq 1 ]; then
		$ECHO "\n${_user_input_} is already used in\n${ENIQ_CONF_DIR}/${BLK_STOR_INI}"
		continue
	fi

	break
done

# Get the next Device number
_old_dev_cnt_=`iniget BLK_STORAGE_DEV_DETAILS -f ${TEM_DIR}/${BLK_STOR_INI}\
				   |$AWK -F\_ '{print $NF}'|$SORT -n |$TAIL -1`
if [ ! "${_old_dev_cnt_}" ]; then
	_new_dev_cnt_=1
else
	_new_dev_cnt_=`$EXPR ${_old_dev_cnt_} + 1`
fi

$ECHO "[BLK_STORAGE_DEV_DETAILS_${_new_dev_cnt_}]" >> ${TEM_DIR}/stor_dev_details

SAN_DEV_NAME="${_user_input_}"
$ECHO "BLK_STORAGE_NAME=${SAN_DEV_NAME}" >> ${TEM_DIR}/stor_dev_details
}

### Function: get_san_device_user_pass ###
#
# Read the username & password of the storeage administrator account
#
# Arguments:
#	$1 : san number
#	global variable ${SAN_NUM_SRVRS}
# Return Values:
#	none
get_san_device_user_pass()
{
local _user_input_
local _san_number_=$1

clear
while :; do
	$ECHO "\n\nEnter username of SAN storage admin account for SAN ${_san_number_} ( ${_san_number_} of ${SAN_NUM_SRVRS})"
	read _user_input_

	# Did user enter anything
	if [ ! "${_user_input_}" ]; then
		continue
	fi

	break
done

# Store the value
SAN_STORAGE_USERNAME="${_user_input_}"

# Update the details file for adding to ini file later
$ECHO "BLK_STORAGE_USERNAME=${_user_input_}" >> ${TEM_DIR}/stor_dev_details

while :; do
	$ECHO "\n\nEnter password of SAN storage admin account for SAN ${_san_number_} ( ${_san_number_} of ${SAN_NUM_SRVRS})"
	read _user_input_

	# Did user enter anything
	if [ ! "${_user_input_}" ]; then
		continue
	fi

	break
done

# Store the value
SAN_STORAGE_PASS="${_user_input_}"

# Update the details file for adding to ini file later
$ECHO "BLK_STORAGE_PASS=${_user_input_}" >> ${TEM_DIR}/stor_dev_details
}

### Function: get_san_sp_addr ###
#
# Read the SAN SPA & SPB IP Addresses
#
# Arguments:
#	$1 : san number
#	global variable ${SAN_NUM_SRVRS}
# Return Values:
#	none
get_san_sp_addr()
{
local _user_input_ _ip_spa_ _ip_spb_
local _san_number_=$1

clear
get_storage_ip_add "Enter IP address of SAN storage processor (A) for SAN ${_san_number_} ( ${_san_number_} of ${SAN_NUM_SRVRS})"
_ip_spa_=${_user_input_}

if [ "${SAN_DEVICE}" != "unity" ]; then
	get_storage_ip_add "Enter IP address of SAN storage processor (B) for SAN ${_san_number_} ( ${_san_number_} of ${SAN_NUM_SRVRS})"
	_ip_spb_=${_user_input_}

	# Store the values
	SAN_STORAGE_SPA="${_ip_spa_}"
	SAN_STORAGE_SPB="${_ip_spb_}"

	# Update the details file for adding to ini file later
	$ECHO "BLK_STORAGE_IP_SPA=${_ip_spa_}" >> ${TEM_DIR}/stor_dev_details
	$ECHO "BLK_STORAGE_IP_SPB=${_ip_spb_}" >> ${TEM_DIR}/stor_dev_details
else
	# Store the values
	SAN_STORAGE_SPA="${_ip_spa_}"

	# Update the details file for adding to ini file later
	$ECHO "BLK_STORAGE_IP_SPA=${_ip_spa_}" >> ${TEM_DIR}/stor_dev_details
fi
}

### Function: get_san_storage_disks ###
#
# Read the SAN Storage Disks
#
# Arguments:
#	$1 : san number
#	global variable ${SAN_NUM_SRVRS}
# Return Values:
#	none
get_san_storage_disks()
{
local _user_input_
local _san_number_=$1

clear

while :; do
	$ECHO "\n\nEnter LUN IDs for SAN ${_san_number_} ( ${_san_number_} of ${SAN_NUM_SRVRS}) separated by comma(Example :sv_1,sv_2)"
	read _user_input_

	# Did user enter anything
	if [ ! "${_user_input_}" ]; then
		continue
	fi
	_user_input_=`$ECHO ${_user_input_} | $SED 's| ||g'`
	break
done

# Store the values
SAN_STORAGE_DISKS="${_user_input_}"

# Update the details file for adding to ini file later
$ECHO "BLK_STORAGE_DISKS=${_user_input_}" >> ${TEM_DIR}/stor_dev_details
}

### Function: get_san_storage_group ###
#
# Read the SAN Storage Group Name
#
# Arguments:
#	$1 : san number
#	global variable ${SAN_NUM_SRVRS}
# Return Values:
#	none
get_san_storage_group()
{
local _user_input_
local _san_number_=$1

clear
if [ "${SAN_DEVICE}" != "unity" ]; then
	while :; do
		$ECHO "\n\nEnter SAN storage group name for SAN ${_san_number_} ( ${_san_number_} of ${SAN_NUM_SRVRS})"
		read _user_input_

		# Did user enter anything
		if [ ! "${_user_input_}" ]; then
			continue
		fi

		break
	done

	# Store the values
	SAN_STORAGE_GROUP_NAME="${_user_input_}"

	# Update the details file for adding to ini file later
	$ECHO "BLK_STORAGE_GROUP_NAME=${_user_input_}" >> ${TEM_DIR}/stor_dev_details
else
	while :; do
		$ECHO "\n\nEnter Consistency group ID for SAN ${_san_number_} ( ${_san_number_} of ${SAN_NUM_SRVRS})"
		read _user_input_

		# Did user enter anything
		if [ ! "${_user_input_}" ]; then
			continue
		fi

		break
	done

	# Store the values
	CONSISTENCY_GROUP_ID="${_user_input_}"

	# Update the details file for adding to ini file later
	$ECHO "BLK_CONSISTENCY_GROUP_ID=${_user_input_}" >> ${TEM_DIR}/stor_dev_details
fi
}

### Function: get_next_stage ###
#
# Get the stage to be run
#
# Arguments:
#   $1 : Stage to be set to. Either numeric value or 'done'
# Return Values:
#   none
get_next_stage()
{
ARRAY_ELEM=0

if [ -s $STAGEFILE ]; then
	NEXT_STAGE=`$CAT $STAGEFILE | $EGREP -v '^[[:blank:]]*#' | $SED -e 's| ||g'`
	if [ ! "$NEXT_STAGE" ]; then
		_err_msg_="Failed to read stage from ${STAGEFILE}, exiting."
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	if [ "$NEXT_STAGE" == "cleanup" ]; then
		return 0
	else
		$ECHO ${ENIQ_CORE_STAGES[*]} | $GREP -w ${NEXT_STAGE} >> /dev/null 2>&1
		if [ $? -ne 0 ]; then
			_err_msg_="Specified stage ${NEXT_STAGE} is not a valid installation stage"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi

	# Get the element number so we can move along the array
	get_array_element
else
	$MKDIR -p `$DIRNAME $STAGEFILE`
	if [ $? -ne 0 ]; then
		_err_msg_="Failed to create directory `$DIRNAME ${STAGEFILE}`, exiting."
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	NEXT_STAGE=${ENIQ_CORE_STAGES[${ARRAY_ELEM}]}
fi
}

### Function: get_ipmp_info ###
#
# Get the stage to be run
#
# Arguments:
#   none
# Return Values:
#   none
get_ipmp_info()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

$RM -rf ${TEM_DIR}/${IPMP_INI} ${TEM_DIR}/interface_list ${TEM_DIR}/unplumb_interface_list

#copy the ipmp.ini file from templates
if [ -s ${ENIQ_TEMPL_DIR}/${IPMP_INI} ]; then
	$CP ${ENIQ_TEMPL_DIR}/${IPMP_INI} ${TEM_DIR}/${IPMP_INI}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy ${ENIQ_TEMPL_DIR}/${IPMP_INI} to ${TEM_DIR}/${IPMP_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
else
	_err_msg_="${ENIQ_TEMPL_DIR}/${IPMP_INI} does not exist, or is empty"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" != "raw" ]; then
	insert_header_footer foot "FS install - Skipping bond information stage" ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

if [ ! -s ${ENIQ_CONF_DIR}/extra_params/deployment ]; then
	_err_msg_="${ENIQ_CONF_DIR}/extra_params/deployment does not exist, or is empty"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

#read the deployment type
_deployment_=`$CAT ${ENIQ_CONF_DIR}/extra_params/deployment`
if [ ! "${_deployment_}" ]; then
	_err_msg_="Could determine the deployment type from ${ENIQ_CONF_DIR}/extra_params/deployment"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Set IPV6 Flag if IPMP Probe is enabled
if [ "${_ipmp_enabled_}" == "Y" ];then
	IPV6_UPGRADE="YES"
fi

#lets check for ipv6
IPv6address_def=$($GREP addif /etc/hostname6* 2> /dev/null | $AWK '{print $2}' | cut -d/ -f1)

if [ "${IPV6_UPGRADE}" ];then

	if [ ! -s ${ENIQ_CONF_DIR}/${IPMP_INI} ]; then
		_err_msg_="${ENIQ_CONF_DIR}/${IPMP_INI} does not exist, or is empty"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	$CP ${ENIQ_CONF_DIR}/${IPMP_INI} ${TEM_DIR}/${IPMP_INI}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy  ${ENIQ_CONF_DIR}/${IPMP_INI} to ${TEM_DIR}/${IPMP_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	_ipv6_enabled_=Y

elif [ -z "$IPv6address_def" ];then
	if [ "${UPGRADE}" ];then
		# # lets ask if they want IPv6
		while :; do
			clear

			$ECHO "\nDo you want to Configure an IPv6 Address (Y|N)?"
			read _ans_

			if [ ! "${_ans_}" ]; then
				continue
			fi

			if [ "${_ans_}" == "Y" -o "${_ans_}" == "N" ]; then
				_ipv6_enabled_=${_ans_}
				if [ ${_ans_} == N ]; then
					$RM -rf ${TEM_DIR}
					exit 0
				fi
				break
			else
				continue
			fi
		done
	else
		_ipv6_enabled_=N
	fi
else
	_ipv6_enabled_=Y
fi

# a list of interfaces
$ECHO "Building list of interfaces, please wait..."

#find the list of interfaces
$NMCLI device | $AWK '{print $1}' | $EGREP -v '*bond*|DEVICE|lo' > ${TEM_DIR}/interface_list

if [ ! -s ${TEM_DIR}/interface_list ]; then
	_err_msg_="Could not build a list of interfaces"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# configure services, storage and backup vlans
_ipmp_config_list_=`iniget IPMP -f ${TEM_DIR}/${IPMP_INI}`
if [ ! "${_ipmp_config_list_}" ]; then
	_err_msg_="Could not build a list of VLAN blocks from ${TEM_DIR}/${IPMP_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

while :; do
	$RM -rf $TEM_DIR/ipmp_information

	$CP ${ENIQ_TEMPL_DIR}/${IPMP_INI} ${TEM_DIR}/${IPMP_INI}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy ${ENIQ_TEMPL_DIR}/${IPMP_INI} to ${TEM_DIR}/${IPMP_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	$PRINTF '\33[H\33[2J'
	$ECHO "\nInterface Information" >> $TEM_DIR/ipmp_information
	$ECHO "----------------" >> $TEM_DIR/ipmp_information
	
	# Setting IPv6_Enable for PM Services Group
	iniset IPMP_INTF_1 -f ${TEM_DIR}/${IPMP_INI} IPv6_Enable=${_ipv6_enabled_}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not update ${TEM_DIR}/${IPMP_INI} with IPv6_Enable=${_ans_}"
		abort_script "${_err_msg_}"
	fi

	for _ipmp_det_ in ${_ipmp_config_list_}; do
		$PRINTF '\33[H\33[2J'

		$RM -rf ${_disp_file_}

		_ipmp_group_name_=`iniget ${_ipmp_det_} -f ${TEM_DIR}/${IPMP_INI} -v IPMP_VLAN_Group_Name`
		if [ ! "${_ipmp_group_name_}" ]; then
			_err_msg_="Could not read VLAN_Group_Name in ${TEM_DIR}/${IPMP_INI}"
			abort_script "${_err_msg_}"
		fi
		#backup vlan configuration
		if [ "${_ipmp_group_name_}" == "Backup Group" ]; then
			while :; do
				$PRINTF '\33[H\33[2J'

				$ECHO "\nDo you want to configure Backup Group (Y|N)?"
				read _ans_

				if [ ! "${_ans_}" ]; then
					continue
				fi

			if [ "${_ans_}" == "Y" -o "${_ans_}" == "N" ]; then
				iniset ${_ipmp_det_} -f ${TEM_DIR}/${IPMP_INI} BONDING_ENABLE=${_ans_}
				if [ $? -ne 0 ]; then
					_err_msg_="Could not update ${TEM_DIR}/${IPMP_INI} with ENABLE=${_ans_}"
					abort_script "${_err_msg_}"
				fi
				if [ "${_ans_}" == "Y" ]; then
					iniset ${_ipmp_det_} -f ${TEM_DIR}/${IPMP_INI} IPv6_Enable=${_ipv6_enabled_}
					if [ $? -ne 0 ]; then
						_err_msg_="Could not update ${TEM_DIR}/${IPMP_INI} with IPv6_Enable=${_ipv6_enabled_}"
						abort_script "${_err_msg_}"
					fi
				fi
				break
			else
				continue
			fi
			done
		elif [ "${_ipmp_group_name_}" == "Storage Group" -a "${_deployment_}" != "ft" ]; then
			iniset ${_ipmp_det_} -f ${TEM_DIR}/${IPMP_INI} BONDING_ENABLE="Y"
			if [ $? -ne 0 ]; then
				_err_msg_="Could not update ${TEM_DIR}/${IPMP_INI} with BONDING_ENABLE=Y"
				abort_script "${_err_msg_}"
			fi
			iniset ${_ipmp_det_} -f ${TEM_DIR}/${IPMP_INI} IPv6_Enable=${_ipv6_enabled_}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not update ${TEM_DIR}/${IPMP_INI} with IPv6_Enable=${_ans_}"
				abort_script "${_err_msg_}"
			fi
		fi

		_bond_enabled_=`iniget ${_ipmp_det_} -f ${TEM_DIR}/${IPMP_INI} -v BONDING_ENABLE`
		if [ ! "${_bond_enabled_}" ]; then
			_err_msg_="Could not read ${_ipmp_det_} BONDING_ENABLE Y/N in ${TEM_DIR}/${IPMP_INI}"
			abort_script "${_err_msg_}"
		fi

		# calling common_get_ipmp_info function for Service , Storage and backup Vlan details
		if [ "${_bond_enabled_}" == "Y" ]; then
				common_get_intf_names "${_ipmp_group_name_}" ${TEM_DIR} ${TEM_DIR}/interface_list
				IPMP_INTERFACE_VALUES=`$ECHO ${IPMP_INTERFACE_VALUES} | tr '\n' ' '`
				iniset ${_ipmp_det_} -f ${TEM_DIR}/${IPMP_INI} IPMP_Group_Intf="${IPMP_INTERFACE_VALUES}"
				if [ $? -ne 0 ]; then
					_err_msg_="Could not update ${TEM_DIR}/${IPMP_INI} with IPMP_Group_Intf=${IPMP_INTERFACE_VALUES}"
					abort_script "${_err_msg_}"
				else
					$ECHO "\n${_ipmp_group_name_} Interface:\t${IPMP_INTERFACE_VALUES}" >> $TEM_DIR/ipmp_information
				fi
				if [ "${_ipv6_enabled_}" == "N" ]; then
					common_get_ipmp_info
				fi
		fi

		_ipv6_enabled_=`iniget ${_ipmp_det_} -f ${TEM_DIR}/${IPMP_INI} -v IPv6_Enable`
		if [ ! "${_ipv6_enabled_}" ]; then
			_err_msg_="Could not read IPv6 ENABLE Y/N from ${TEM_DIR}/${IPMP_INI}"
			abort_script "${_err_msg_}"
		fi

		if [ "${_ipv6_enabled_}" == "Y" ]; then
			common_get_vlan_ipmp_ip "${_ipmp_group_name_} for IPv6" 
			_group_ipv6_=${IPMP_IPS}
			iniset ${_ipmp_det_} -f ${TEM_DIR}/${IPMP_INI} IPMP_Group_IPv6_VIP=${IPMP_IPS}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not update ${TEM_DIR}/${IPMP_INI} with IPMP_Group_IPv6_VIP=${IPMP_IPS} for ${_ipmp_det_}"
				abort_script "${_err_msg_}"
			fi

			common_get_vlan_ipv6_netmask "${_ipmp_group_name_} for IPv6"
			_ipv6_netmask_=${IPv6_NETMASKS}
			iniset ${_ipmp_det_} -f ${TEM_DIR}/${IPMP_INI} IPMP_Group_IPv6_Netmask=${IPv6_NETMASKS}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not update ${TEM_DIR}/${IPMP_INI} with IPMP_Group_IPv6_Netmask=${IPMP_NETMASKS} for ${_ipmp_det_}"
				abort_script "${_err_msg_}"
			fi
			
			common_get_vlan_ipv6_gateway "${_ipmp_group_name_} for IPv6" 
			_ipv6_gateway_=${IPv6_GATEWAYS}
			iniset ${_ipmp_det_} -f ${TEM_DIR}/${IPMP_INI} IPMP_Group_IPv6_Gateway=${IPv6_GATEWAYS}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not update ${TEM_DIR}/${IPMP_INI} with IPMP_Group_IPv6_Gateway=${IPv6_GATEWAYS} for ${_ipmp_det_}"
				abort_script "${_err_msg_}"
			fi
			
			common_get_vlan_ipv6_arp_target "${_ipmp_group_name_} for IPv6" 
			_ipv6_arp_target_=${IPv6_ARP_TARGETS}
			iniset ${_ipmp_det_} -f ${TEM_DIR}/${IPMP_INI} ARP_IP_TARGET_IPv6=${IPv6_ARP_TARGETS}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not update ${TEM_DIR}/${IPMP_INI} with ARP_IP_TARGET_IPv6=${IPv6_ARP_TARGETS} for ${_ipmp_det_}"
				abort_script "${_err_msg_}"
			fi
		fi
		
		if [ "${_ipv6_enabled_}" == "Y" ]; then
			$ECHO "${_ipmp_group_name_} IPv6:\t${_group_ipv6_}" >> $TEM_DIR/ipmp_information
			$ECHO "${_ipmp_group_name_} IPv6 netmask:\t${_ipv6_netmask_}" >> $TEM_DIR/ipmp_information
			$ECHO "${_ipmp_group_name_} IPv6 gateway:\t${_ipv6_gateway_}" >> $TEM_DIR/ipmp_information
			$ECHO "${_ipmp_group_name_} IPv6 arp_target:\t${_ipv6_arp_target_}" >> $TEM_DIR/ipmp_information
		fi
	done

	# Final confirmation for user input
	while :; do
		$PRINTF '\33[H\33[2J'

		$CAT $TEM_DIR/ipmp_information
		$ECHO "\nIs the information above correct (Yes|No)"
		read _ans_

		if [ ! "${_ans_}" ]; then
			continue
		fi

		if [ "${_ans_}" == "Yes" -o "${_ans_}" == "No" ]; then
			break
		else
			continue
		fi
	done

	if [ "${_ans_}" == "Yes" ]; then
		break
	else
		unset IPMP_INTERFACE_VALUES
		$RM -rf ${TEM_DIR}/${IPMP_INI}
		$RM -rf ${TEM_DIR}/usd_intf_list
		continue
	fi
done

$CP ${TEM_DIR}/${IPMP_INI} ${ENIQ_CONF_DIR}/${IPMP_INI}
if [ $? -ne 0 ]; then
	_err_msg_="Could not copy ${TEM_DIR}/${IPMP_INI} to ${ENIQ_CONF_DIR}/${IPMP_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

insert_header_footer foot "Successfully gathered bond information" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: get_storage_ip_add ###
#
# Get the IPs of storage we are connecting to
#
# Arguments:
#	$1 : message
# Return Values:
#
get_storage_ip_add()
{
while :; do
	$ECHO "\n\n${1}"
	read _user_input_

	# Did user enter anything
	if [ ! "${_user_input_}" ]; then
		continue
	fi

	validate_ip ${_user_input_}
	if [ $? -ne 0 ]; then
		continue
	fi

	break
done
}

### Function: get_storage_type ###
#
# Get the type of storage we are connecting to
#
# Arguments:
#   none
# Return Values:
#   none
get_storage_type()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

local _storage_type_ _san_type_
local _def_san_type_="unity"
local _storage_type_file_=${ENIQ_CORE_INST_DIR}/etc/storage_options

unset STORAGE_TYPE SAN_TYPE

# Storage type choice
$RM -f ${TEM_DIR}/storage_choice

# Get the options that can be installed
if [ -f ${_storage_type_file_} ]; then
	$CAT ${_storage_type_file_} | $EGREP -v '^[[:blank:]]*#' > ${TEM_DIR}/storage_choice
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy storage choice options to ${TEM_DIR}/storage_choice"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
else
	_err_msg_="Failed to find ${_storage_type_file_} file, or it is empty"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Build an array to store the names of the available storage choices
_cnt_=1
while read _storage_detail_; do
	# Store the details in the array
	_str_array_[${_cnt_}]=${_storage_detail_}
	let _cnt_=_cnt_+1
done < ${TEM_DIR}/storage_choice

_cnt_=${#_str_array_[@]}

# Create the Display file
_disp_file_=${TEM_DIR}/disp_file
$RM -f ${_disp_file_}

$ECHO -e "\n\nAvailable storage options:" >> ${_disp_file_}
for (( i=1; i<=${_cnt_}; i++ )); do
	$ECHO "[${i}]  ${_str_array_[${i}]}" >> ${_disp_file_}
done

$ECHO -e "\nSelect the storage that the ENIQ system will be installed on" >> ${_disp_file_}

while :; do
	clear

	unset STORAGE_TYPE SAN_TYPE _num_ _san_type_

	$CAT ${_disp_file_}
	  read _num_

	if [ ! "${_num_}" ]; then
		continue
	fi

	_numerror_=0

	# Check that the user value is numeric
	$ECHO ${_num_} | $EGREP '[^0-9]' >> /dev/null 2>&1
	if [ $? -eq 0 ]; then
		continue
	fi

	# Check the user entered a value in the range (1-2)
	if [ ${_num_} -lt 1 -o ${_num_} -gt ${_cnt_} ]; then
		continue
	fi

	STORAGE_TYPE=${_str_array_[${_num_}]}

	if [ "${CURR_SERVER_TYPE}" == "eniq_iqr" ]; then
		if [ "${STORAGE_TYPE}" != "raw" ]; then
			$ECHO "ENIQ Events reader server must use raw storage\nPress enter to continue"
			read _any_
			continue
		fi
	fi

	if [ "${STORAGE_TYPE}" != "fs" ]; then
		while :; do
			$ECHO -e "\nEnter type of SAN storage device connected to this ENIQ deployment (e.g. vnx, unity)"
			$ECHO "Hit enter for (${_def_san_type_})"
			read _san_type_

			if [ ! "${_san_type_}" ]; then
				_san_type_=${_def_san_type_}
			fi

			if [ "${_san_type_}" == "clariion" -o "${_san_type_}" == "vnx" -o "${_san_type_}" == "unity" -o "${_san_type_}" == "local" ]; then
				SAN_TYPE=${_san_type_}
				break
			else
				$ECHO -e "\nPlease enter valid SAN storage device"
				continue
			fi
		done
	fi
	break
done

if [ -s ${ENIQ_CONF_DIR}/${SUNOS_INI} ]; then
	iniset STOR_TYPE -f ${ENIQ_CONF_DIR}/${SUNOS_INI} STORAGE_TYPE="${STORAGE_TYPE}"
	if [ $? -ne 0 ]; then
		_err_msg_="Could not set STORAGE_TYPE to ${STORAGE_TYPE} in ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	iniset SAN_DEV -f ${ENIQ_CONF_DIR}/${SUNOS_INI} SAN_DEVICE="${SAN_TYPE}"
	if [ $? -ne 0 ]; then
		_err_msg_="Could not set SAN_DEVICE to ${SAN_TYPE} in ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
else
	$RM -f ${ENIQ_CONF_DIR}/san_details
	$ECHO "STORAGE_TYPE=${STORAGE_TYPE}" >> ${ENIQ_CONF_DIR}/san_details
	$ECHO "SAN_DEVICE=${SAN_TYPE}" >> ${ENIQ_CONF_DIR}/san_details
fi

insert_header_footer foot "Successfully set storage type" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: get_sw_dir ###
#
# Get the stage to be run
#
# Arguments:
#   $1 : Stage to be set to. Either numeric value or 'done'
# Return Values:
#   none
get_sw_dir()
{
unset _res_code_

if [ "${BASE_SW_DIR}" ]; then
	SW_DIR=${BASE_SW_DIR}
	_res_code_=0
else
	if [ "${ENIQ_SW_PATH_FILE}" ]; then
		insert_media -l ${ENIQ_BASE_SW} -f ${ENIQ_BASE_SW_FILE_ID} -s ${ENIQ_SW_PATH_FILE} -n 5 "ENIQ SW Distribution"
		_res_code_=$?
	else
		  insert_media -l ${ENIQ_BASE_SW} -f ${ENIQ_BASE_SW_FILE_ID} -n 5 "ENIQ SW Distribution"
		  _res_code_=$?
	fi
fi

if [ ${_res_code_} -ne 0 ]; then
	_err_msg_="Could not determine path to SW"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ! "$SW_DIR" ]; then
	_err_msg_="Failed to locate ENIQ SW Distribution... exiting!"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
}

### Function: get_update_server_netmask ###
#
# Get the server netmask info and update if necessary
#
# Arguments:
#   none
# Return Values:
#   none
get_update_server_netmask()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

# Get domain name
if [ -s /etc/resolv.conf ]; then
    _domain_name_=`$CAT /etc/resolv.conf | $EGREP 'search|domain' | $AWK '{print $2}'`
    if [ ! "${_domain_name_}" ]; then
        _err_msg_="Could not get the domain name from resolv.conf file"
        abort_script "${_err_msg_}"
    fi
else
    _err_msg_="Could not get the resolv.conf file"
    abort_script "${_err_msg_}"
fi

# Get active default interface
_active_interface_=`$NETSTAT -nr | $GREP "UG" | $AWK '{print $NF}'`
if [ ! "${_active_interface_}" ]; then
    _err_msg_="Could not get the active_interface file"
    abort_script "${_err_msg_}"
fi

#Get the default interface file
_intf_file_=`$LS ${INTF_DIR}/*${_active_interface_}* 2> /dev/null`

if [ "${_intf_file_}" ]; then
    $GREP -i "${_domain_name_}" ${_intf_file_} > /dev/null
    if [ $? -ne 0 ]; then
       $ECHO "DOMAIN=\""${_domain_name_}"\"" >> ${_intf_file_}
    fi
else
    _err_msg_="Could not get the default interface file from ${INTF_DIR} directory"
    abort_script "${_err_msg_}"
fi


#Start NetworkManager Service
$ECHO -e "Starting NetworkManager Service"

$SYSTEMCTL enable NetworkManager >> /dev/null 2>&1
if [ $? -ne 0 ]; then
	_err_msg_="Failed to enable NetworkManager Service"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$SYSTEMCTL start NetworkManager
if [ $? -ne 0 ]; then
	_err_msg_="Failed to start NetworkManager Service"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ "${_san_device_}" == "local" ]; then
	 _client_netmask_=`$IFCONFIG | $GREP ${HOST_IP} | $AWK '{ print $2 }'`
else
   _client_netmask_=`$CAT ${ENIQ_CONF_DIR}/${HNAME}/${HNAME}_ks_cfg.txt | $GREP CLIENT_NETMASK | $AWK -F"=" '{ print $2 }'`
fi
	 
if [ ! "${_client_netmask_}" ]; then
	_err_msg_="Failed to get client netmask"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_network_address_=`get_network_addr "${_client_netmask_}" "${HOST_IP}"`
if [ ! "${_network_address_}" ]; then
	_err_msg_="Failed to get network address"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"   
fi

if [ -s /etc/inet ]; then
	 $RM -rf /etc/inet
	 if [ $? -ne 0 ]; then
		  _err_msg_="Could not remove /etc/inet directory"
		  abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}" 
	 fi
fi

#Creating /etc/inet directory
$MKDIR -p /etc/inet
if [ $? -ne 0 ]; then
	_err_msg_="Could not create directory /etc/inet"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$TOUCH /etc/inet/netmasks
if [ $? -ne 0 ]; then
	_err_msg_="Could not create file /etc/inet/netmasks"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

#Create symbolic link to /etc/inet/netmasks
if [ -L /etc/netmasks ]; then
	 $RM -rf /etc/netmasks
	 if [ $? -ne 0 ]; then
		  _err_msg_="Could not remove /etc/netmasks Symbolic link"
		  abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	 fi
fi

$LN -s /etc/inet/netmasks /etc/netmasks
if [ $? -ne 0 ]; then
	_err_msg_="Failed to create symbolic link to /etc/inet/netmasks"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$ECHO -e "${_network_address_}\t${_client_netmask_}" > /etc/inet/netmasks
if [ $? -ne 0 ]; then
	_err_msg_="Could not copy network number and netmask to /etc/inet/netmasks"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi


if [ -s /etc/netmasks ]; then
	_net_=`$CAT /etc/netmasks | $SED '/^$/d' | $EGREP -v '^[	 ]*#' | $AWK '{print $1}'`
	_mask_=`$CAT /etc/netmasks | $SED '/^$/d' | $EGREP -v '^[	 ]*#' | $AWK '{print $2}'`
	_default_netmask_="${_net_}:${_mask_}"
else
	_default_netmask_=""
fi

_out_msg_="Enter the server network-number:netmask details"
common_get_netmask_info "${_out_msg_}" "${_default_netmask_}"
if [ $? -ne 0 ]; then
	_err_msg_=""
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ! "${NETMASK_INFO}" ]; then
	_err_msg_="Could not determine server network-number:netmask details"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Set up the netmask if necessary
_net_num_=`$ECHO ${NETMASK_INFO}|$AWK -F\: '{print $1}'`
_mask_=`$ECHO ${NETMASK_INFO}|$AWK -F\: '{print $2}'`

$CAT /etc/inet/netmasks|$EGREP "^[[:blank:]]*${_net_num_}[[:blank:]]+${_mask_}[[:blank:]]*$" >> /dev/null 2>&1
if [ $? -ne 0 ]; then
	if [ ! -f /etc/inet/netmasks.orig ]; then
		$CP -p /etc/inet/netmasks /etc/inet/netmasks.orig >> /dev/null 2>&1
		if [ $? -ne 0 ]; then
			_err_msg_="Could not make backup of /etc/inet/netmasks"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi
	$ECHO -e "Updating /etc/inet/netmasks with ${_net_num_}\t${_mask_}"
	$ECHO -e "${_net_num_}\t${_mask_}" >> /etc/inet/netmasks
	insert_header_footer foot "Successfully updated /etc/inet/netmasks file" ${LOGFILE}
	REBOOT_FLAG=1
else
	insert_header_footer foot "Successfully completed core install stage - ${NEXT_STAGE}" ${LOGFILE}
fi
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}


### Function: install_backup_sw ###
#
# Installs scripts into /eniq/bkup_sw
#
# Arguments:
#   none
# Return Values:
#   none
install_backup_sw()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

local _dir_name_="bkup_sw"

if [ ! -d ${ENIQ_BASE_DIR}/${_dir_name_} ]; then
	$MKDIR ${ENIQ_BASE_DIR}/${_dir_name_}
	if [ $? -ne 0 ]; then
		_err_msg_="Failed to create ${ENIQ_BASE_DIR}/${_dir_name_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

$RM -rf ${TEM_DIR}/${_dir_name_}
$MKDIR -p ${TEM_DIR}/${_dir_name_}
$CP -rp ${ENIQ_COMMON_SW_DIR}/${_dir_name_}/* ${TEM_DIR}/${_dir_name_}
if [ $? -ne 0 ]; then
	_err_msg_="Could not copy ${ENIQ_COMMON_SW_DIR}/${_dir_name_}/* to ${TEM_DIR}/${_dir_name_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$ECHO "Updating values in files in ${ENIQ_COMMON_SW_DIR}/${_dir_name_}" | $TEE -a ${LOGFILE}
core_install_change_base_info ${LOGFILE} ${TEM_DIR} ${ENIQ_BASE_DIR} "${_dir_name_}"
if [ $? -ne 0 ]; then
	_err_msg_="Could not substitute values in ${ENIQ_COMMON_SW_DIR}/${_dir_name_} files"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

cd ${TEM_DIR}/${_dir_name_}
$ECHO "Copying ${_dir_name_} scripts from ${TEM_DIR}/${_dir_name_} to ${ENIQ_BASE_DIR}/${_dir_name_}\n" | $TEE -a ${LOGFILE}
$FIND . -depth -print | $CPIO -pdmu ${ENIQ_BASE_DIR}/${_dir_name_}
if [ $? -ne 0 ]; then
	_err_msg_="Failed to copy contents of ${TEM_DIR}/${_dir_name_} to ${ENIQ_BASE_DIR}/${_dir_name_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Change ROLL_SNAP_ID_STR and BKUP_SNAP_ID_STR in eniq_backup.conf  based on the INSTALL_TYPE to make this unique for any particular install type.

if [ "${INSTALL_TYPE}" == "stats" ]; then
	ROLL_SNAP_ID_STR_temp=snss1::snss2
	BKUP_SNAP_ID_STR_temp=omss
	BKUP_SNAP_ID_STR_SAN_temp=omss_${HNAME}

else
	 _err_msg_=" INSTALL_TYPE is not set to stats "
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
$CP ${ENIQ_BASE_DIR}/bkup_sw/etc/eniq_backup.conf	${TEM_DIR}/eniq_backup.conf

$ECHO "# String that all snapshots will be identified by" >> ${TEM_DIR}/eniq_backup.conf
$ECHO "ROLL_SNAP_ID_STR=${ROLL_SNAP_ID_STR_temp}" >> ${TEM_DIR}/eniq_backup.conf
#$SED   -e 's|^[	   ]*ROLL_SNAP_ID_STR=.*|ROLL_SNAP_ID_STR='"$ROLL_SNAP_ID_STR_temp"'|'  ${ENIQ_BASE_DIR}/bkup_sw/etc/eniq_backup.conf >   ${TEM_DIR}/eniq_backup.conf
if [ $? -ne 0 ]; then
	_err_msg_="Failed to put ROLL_SNAP_ID_STR in ${TEM_DIR}/eniq_backup.conf"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
$ECHO "BKUP_SNAP_ID_STR=${BKUP_SNAP_ID_STR_temp}" >> ${TEM_DIR}/eniq_backup.conf
if [ "${INSTALL_TYPE}" == "stats" ]; then
	  $ECHO "BKUP_SNAP_ID_STR_SAN=${BKUP_SNAP_ID_STR_SAN_temp}" >> ${TEM_DIR}/eniq_backup.conf
fi

#$SED -e 's|^[	   ]*BKUP_SNAP_ID_STR=.*|BKUP_SNAP_ID_STR='"$BKUP_SNAP_ID_STR_temp"'|'  ${TEM_DIR}/eniq_backup.conf >   ${TEM_DIR}/eniq_backup.conf1
if [ $? -ne 0 ]; then
	_err_msg_="Failed to put BKUP_SNAP_ID_STR in ${TEM_DIR}/eniq_backup.conf1 "
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$CP ${TEM_DIR}/eniq_backup.conf /${ENIQ_BASE_DIR}/bkup_sw/etc/eniq_backup.conf
if [ $? -ne 0 ]; then
	_err_msg_="Failed to copy ${TEM_DIR}/eniq_backup.conf to /${ENIQ_BASE_DIR}/bkup_sw/etc/eniq_backup.conf "
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

cd /

insert_header_footer foot "Successfully installed SW to /eniq/${_dir_name_}" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: install_connectd_sw ###
#
# Installs scripts into /eniq/connectd
#
# Arguments:
#   none
# Return Values:
#   none
install_connectd_sw()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

local _dir_name_="connectd"

if [ ! -d ${ENIQ_BASE_DIR}/${_dir_name_} ]; then
	$MKDIR ${ENIQ_BASE_DIR}/${_dir_name_}
	if [ $? -ne 0 ]; then
		_err_msg_="Failed to create ${ENIQ_BASE_DIR}/${_dir_name_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

$RM -rf ${TEM_DIR}/${_dir_name_}
$MKDIR -p ${TEM_DIR}/${_dir_name_}
$CP -rp ${ENIQ_COMMON_SW_DIR}/${_dir_name_}/* ${TEM_DIR}/${_dir_name_}
if [ $? -ne 0 ]; then
	_err_msg_="Could not copy ${ENIQ_COMMON_SW_DIR}/${_dir_name_}/* to ${TEM_DIR}/${_dir_name_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$ECHO "Updating values in files in ${ENIQ_COMMON_SW_DIR}/${_dir_name_}" | $TEE -a ${LOGFILE}
core_install_change_base_info ${LOGFILE} ${TEM_DIR} ${ENIQ_BASE_DIR} "${_dir_name_}"
if [ $? -ne 0 ]; then
	_err_msg_="Could not substitute values in ${ENIQ_COMMON_SW_DIR}/${_dir_name_} files"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

cd ${TEM_DIR}/${_dir_name_}
$ECHO "Copying ${_dir_name_} scripts from ${TEM_DIR}/${_dir_name_} to ${ENIQ_BASE_DIR}/${_dir_name_}\n" | $TEE -a ${LOGFILE}
$FIND . -depth -print | $CPIO -pdmu ${ENIQ_BASE_DIR}/${_dir_name_}
if [ $? -ne 0 ]; then
	_err_msg_="Failed to copy contents of ${TEM_DIR}/${_dir_name_} to ${ENIQ_BASE_DIR}/${_dir_name_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
cd /

insert_header_footer foot "Successfully installed SW to /eniq/${_dir_name_}" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: install_ddc ###
#
# Install the DDC package
#
# Arguments:
#   none
# Return Values:
#   none
install_ddc()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Set the OM dir value
if [ "${UPGRADE}" -a "${OM_SW_DIR}" ]; then
	SW_DIR=${OM_SW_DIR}
else
	if [ -d ${DEF_CACHE_DIR}/ddc ]; then
		SW_DIR=${DEF_CACHE_DIR}
	else
		if [ "${OM_SW_PATH_FILE}" ]; then
			insert_media -l om -f ".om" -s ${OM_SW_PATH_FILE} -n 5 "Operation and Maintenance DVD"
		else
			insert_media -l om -f ".om" -n 5 "Operation and Maintenance DVD"
		fi
	fi
fi

if [ ! "$SW_DIR" ]; then
	_err_msg_="Failed to locate cached O&M Media!"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_ddc_pkg_loc_=${SW_DIR}/ddc
$ECHO "\nDDC will be searched for in ${_ddc_pkg_loc_}" >> ${LOGFILE}

if [ -d ${_ddc_pkg_loc_} ]; then
	_ddc_pkg_file_=`iniget DDC -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v DDC_PKG_FILE`
	_ddc_pkg_=`iniget DDC -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v DDC_PKG_NAME`

	_ddc_full_pkg_loc_="${_ddc_pkg_loc_}/${_ddc_pkg_file_}"
	if [ -e "${_ddc_full_pkg_loc_}" ]; then
		$GZIP -dc ${_ddc_full_pkg_loc_} > $TEM_DIR/${_ddc_pkg_}
		if [ $? -ne 0 ]; then
			_err_msg_="Failed to unzip ${_ddc_full_pkg_loc_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi

	_ddc_full_pkg_=$TEM_DIR/${_ddc_pkg_}
	if [ -e "${_ddc_full_pkg_}" ]; then
		_ddc_pkg_name_=`$BASENAME ${_ddc_full_pkg_} | $AWK -F\. '{print $1}'`

		# Create an adm file if one doesn't exist
		$RM -f $TEM_DIR/sw.adm
		if [ -s ${_ddc_pkg_loc_}/${_ddc_pkg_name_}.adm ]; then
			$CP ${_ddc_pkg_loc_}/${_ddc_pkg_name_}.adm $TEM_DIR/sw.adm
		else
			core_install_create_adm_file ${LOGFILE} ${TEM_DIR}
		fi

		# Create a rsp file if one doesn't exist
		$RM -f $TEM_DIR/sw.rsp
		if [ -s ${_ddc_pkg_loc_}/${_ddc_pkg_name_}.rsp ]; then
			$CP ${_ddc_pkg_loc_}/${_ddc_pkg_name_}.rsp $TEM_DIR/sw.rsp
		else
			$ECHO "RESTORE_CFG=false" > $TEM_DIR/sw.rsp
		fi

		# Is the package already installed? If so remove it
		$PKGINFO -q ${_ddc_pkg_name_}
		if [ $? -eq 0 ]; then
			$ECHO "Removing current instance of ${_ddc_pkg_name_}"
			$PKGRM -n -a ${TEM_DIR}/sw.adm ${_ddc_pkg_name_}
			if [ $? -ne 0 ]; then
				_err_msg_="Failed to remove ${_ddc_pkg_name_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		fi

		$ECHO "Adding ${_ddc_full_pkg_}" | $TEE -a ${LOGFILE}
		$PKGADD -n -d ${_ddc_full_pkg_} -r ${TEM_DIR}/sw.rsp -a ${TEM_DIR}/sw.adm all
		if [ $? -ne 0 ]; then
			_err_msg_="Failed to add ${_ddc_full_pkg_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		$ECHO "Successfully installed DDC" >> ${LOGFILE}
	else
		$ECHO "${_ddc_full_pkg_} does not exist - skipping DDC installation" >> ${LOGFILE}
	fi
else
	$ECHO "${_ddc_pkg_loc_} is not a directory - skipping DDC installation" >> ${LOGFILE}
fi

insert_header_footer foot "Successfully completed stage - $NEXT_STAGE" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: install_ENIQ_features ###
#
# Call script to install features
#
# Arguments:
#   none
# Return Values:
#   none
install_ENIQ_features()
{

if [ -f ${ENIQ_CONF_DIR}/no_feature -a "${INSTALL_TYPE}" == "stats" ]; then
	$ECHO "Skipping core install stage - ${NEXT_STAGE}." | $TEE -a ${LOGFILE}
	$ECHO "This installation is without feature selection. Only PF and Standard TPs will be available." | $TEE -a ${LOGFILE}
else
	insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

	# Set the SW_DIR variable
	get_feature_dir
	if [ "${INSTALL_TYPE}" == "events" ]; then
		FEAT_SW_DIR=${SW_DIR}
		get_sw_dir
	fi

	# Get the System User.
	_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
	if [ ! "${_sysuser_}" ]; then
		_err_msg_="Could not read parameter ENIQ_SYSUSER from ${ENIQ_CONF_DIR}/${SUNOS_INI} file"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	
	# Get Directory where the list of managed features will be stored
	_feature_list_dir_=`iniget FEATURE_INFO -f ${ENIQ_CONF_DIR}/${ENIQ_INI} -v Feature_Interface_Dir`
	if [ ! "${_feature_list_dir_}" ]; then
		_err_msg_="Failed to read Parameter Feature_Interface_Dir from ${ENIQ_CONF_DIR}/${ENIQ_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	# Does the directory exist
	if [ ! -d "${_feature_list_dir_}" ]; then
		_err_msg_="Directory ${_feature_list_dir_} does not exist"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	# Set correct values for stats/events
	if [ "${INSTALL_TYPE}" == "stats" ]; then
		# This is the OSS HNAME for first OSS
		_oss_ref_name_="${OSS_REF_STR}1"

		# The interfaces file for this oss should be this path
		_eniq_oss_feat_list_=${_feature_list_dir_}/feature_info/${_oss_ref_name_}/feature_install_list
		if [ ! -s ${_eniq_oss_feat_list_} ]; then
			_err_msg_="${_eniq_oss_feat_list_} not found or empty"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	else
		# Get Directory where the list of managed features will be stored
		_eniq_oss_feat_list_=`iniget FEATURE_INFO -f ${ENIQ_CONF_DIR}/${ENIQ_INI} -v Feature_Output_File`
		if [ ! "${_eniq_oss_feat_list_}" ]; then
			_err_msg_="Failed to read Feature_Output_File parameter from ${ENIQ_CONF_DIR}/${ENIQ_INI}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi

	if [ ! -s ${ENIQ_ADMIN_BIN_DIR}/manage_features.bsh ]; then
		_err_msg_="Failed to locate ENIQ Feature installer script - ${ENIQ_ADMIN_BIN_DIR}/manage_features.bsh"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	if [ ! -s ${_eniq_oss_feat_list_} ]; then
		_err_msg_="${_eniq_oss_feat_list_} not found or empty"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	# Start all the services. I will 'su' to the sysuser as SMF is not in control at this stage
	$RM -f ${TEM_DIR}/service_list.$$
	for _srv_ in ${ENIQ_START_SERVICES}; do
		$RM -f ${TEM_DIR}/.error_file.$$.$$.$$
		if [ ! -x ${ENIQ_ADMIN_BIN_DIR}/${_srv_} ]; then
			continue
		fi
		$ECHO "${ENIQ_ADMIN_BIN_DIR}/${_srv_} start" >> ${TEM_DIR}/service_list.$$
		$ECHO "if [ $? -ne 0 ]; then" >> ${TEM_DIR}/service_list.$$
		$ECHO "/usr/bin/touch ${TEM_DIR}/.error_file.$$.$$.$$" >> ${TEM_DIR}/service_list.$$
		$ECHO "exit 1" >> ${TEM_DIR}/service_list.$$
		$ECHO "fi" >> ${TEM_DIR}/service_list.$$
	done

	if [ -s ${TEM_DIR}/service_list.$$ ]; then
		$SU - ${_sysuser_} -c "${BASH} ${TEM_DIR}/service_list.$$"
		if [ -f ${TEM_DIR}/.error_file.$$.$$.$$ ]; then
			abort_script "Exiting...." "${EXEC_SHELL_CMD}"
		fi
	fi

	# Only start the databases on Stats or Events systems
	if [ "${INSTALL_TYPE}" != "es" ]; then
		$ECHO "Starting repository database..." | $TEE -a ${LOGFILE}
		$SU - ${_sysuser_} -c "${ENIQ_ADMIN_BIN_DIR}/repdb start"
		if [ $? -ne 0 ] ; then
			_err_msg_="Repository database failed to start"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		$ECHO "Starting dwhdb..." | $TEE -a ${LOGFILE}
		$SU - ${_sysuser_} -c "${ENIQ_ADMIN_BIN_DIR}/dwhdb start"
		if [ $? -ne 0 ] ; then
			_err_msg_="dwhdb database failed to start"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi
	## This was specific to Stats now it is required for Stats and events
	MANAGE_FEATURE_OPTS="-X"

	# Run the feature manager script
	$ECHO "\nInstalling features using command" >> ${LOGFILE}
	if [ "${INSTALL_TYPE}" == "events" ]; then
		$ECHO "${BASH} ${ENIQ_ADMIN_BIN_DIR}/manage_features.bsh -d ${FEAT_SW_DIR} -m ${SW_DIR} -a add -F ${_eniq_oss_feat_list_} -l ${LOGFILE} -I ${MANAGE_FEATURE_OPTS}" >> ${LOGFILE}
		${BASH} ${ENIQ_ADMIN_BIN_DIR}/manage_features.bsh -d ${FEAT_SW_DIR} -m ${SW_DIR} -a add -F ${_eniq_oss_feat_list_} -l ${LOGFILE} -I ${MANAGE_FEATURE_OPTS}
	else
		$ECHO "${BASH} ${ENIQ_ADMIN_BIN_DIR}/manage_features.bsh -d ${SW_DIR} -a add -F ${_eniq_oss_feat_list_} -l ${LOGFILE} -I ${MANAGE_FEATURE_OPTS} -s" >> ${LOGFILE}
		${BASH} ${ENIQ_ADMIN_BIN_DIR}/manage_features.bsh -d ${SW_DIR} -a add -F ${_eniq_oss_feat_list_} -l ${LOGFILE} -I ${MANAGE_FEATURE_OPTS} -s
	fi
	_res_code_=$?
	if [ ${_res_code_} -ne 0 ]; then
		_err_msg_="Failure trying to add features"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	insert_header_footer foot "Successfully installed Features" ${LOGFILE}
fi

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: install_ENIQ_platform ###
#
# RUN ENIQ CLI PROGRAM
#
# Arguments:
#   none
# Return Values:
#   none
install_ENIQ_platform()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Set the SW_DIR variable
get_sw_dir
# Read the storage type
read_storage_type

_eniq_sw_src_dir_=`iniget ENIQ_CLI -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SW_DIR`
_eniq_sw_inst_prog_=`iniget ENIQ_CLI -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_CLI_PROG`

# Get the System User.
_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file\n${CLI_CONF_DIR}/${ENIQ_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysgrp_=`$ID ${_sysuser_}|$AWK '{print $2}'|$AWK -F\( '{print $2}'|$AWK -F\) '{print $1}'`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not determine group ID of ${_sysuser_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ! -d "$SW_DIR/${_eniq_sw_src_dir_}" ]; then
	_err_msg_="Failed to locate ENIQ SW Directory - $SW_DIR/${_eniq_sw_src_dir_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ! -x "$SW_DIR/${_eniq_sw_src_dir_}/${_eniq_sw_inst_prog_}" ]; then
	_err_msg_="Failed to locate $SW_DIR/${_eniq_sw_src_dir_}/${_eniq_sw_inst_prog_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi


  $ECHO "Starting repository database..." | $TEE -a ${LOGFILE}
  $SU - ${_sysuser_} -c "${ENIQ_ADMIN_BIN_DIR}/repdb start"
  if [ $? -ne 0 ] ; then
	_err_msg_="Repository database failed to start"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
  fi

  $ECHO "Starting dwhdb..." | $TEE -a ${LOGFILE}
  $SU - ${_sysuser_} -c "${ENIQ_ADMIN_BIN_DIR}/dwhdb start"
  if [ $? -ne 0 ] ; then
	_err_msg_="dwhdb database failed to start"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
  fi


if [ "${STORAGE_TYPE}" == "raw" ]; then
	# Check mountpoints and mount if not there
	mount_req_dirs
	if [ $? -ne 0 ]; then
		_err_msg_="Could not mount required directories for $NEXT_STAGE"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi


  # Get the partition plan
  _eniq_partition_plan_=`iniget PARTITION_PLAN -f ${ENIQ_CONF_DIR}/${ENIQ_INI} -v Partition_Plan`
  if [ ! "${_eniq_partition_plan_}" ]; then
	_err_msg_="Could not read parameter PARTITION_PLAN from ${ENIQ_CONF_DIR}/${ENIQ_INI} file"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
  fi


if [ ! -d ${ENIQ_LOG_DIR}/sw_log/iq ]; then
  $MKDIR -p ${ENIQ_LOG_DIR}/sw_log/iq
fi
$CHOWN -R ${_sysuser_}:${_sysgrp_} ${ENIQ_LOG_DIR}/sw_log
if [ $? -ne 0 ]; then
	_err_msg_="Could not change ownership of ${ENIQ_LOG_DIR}/sw_log to ${_sysuser_}:${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sentinel_smf_str_=`iniget SENTINEL -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v SENTINEL_SYSTEMD_STR`
if [ ! "${_sentinel_smf_str_}" ]; then
	_err_msg_="Could not get Sentinel SMF string from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$ECHO "Starting Sentinel..." >> ${LOGFILE}
$SYSTEMCTL reset-failed ${_sentinel_smf_str_} >> /dev/null 2>&1

$SYSTEMCTL enable ${_sentinel_smf_str_}
if [ $? -ne 0 ]; then
	_err_msg_="Could not enable Sentinel"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$SYSTEMCTL start ${_sentinel_smf_str_}
if [ $? -ne 0 ]; then
	_err_msg_="Could not start Sentinel"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_platform_service_list_=`$ECHO $STATS_PLATFORM_SERVICE_NAME_LIST | $SED 's| |,|g'`

$ECHO "Platform service list for install type ${INSTALL_TYPE} is : ${_platform_service_list_}" >> ${LOGFILE}

# Adding platform services to service_names file
add_platform_services 

$RM -rf /tmp/eniq

# Executing PF script updateVersionDB.bsh
if [ "${UPGRADE}" ]; then
	log_msg -q -s "\nStarting to run $SU - ${_sysuser_} -c \"$BASH ${ENIQ_CORE_BIN_DIR}/updateVersionDB.bsh -l ${LOGFILE}" -l ${LOGFILE}
	$SU - ${_sysuser_} -c "$BASH ${ENIQ_CORE_BIN_DIR}/updateVersionDB.bsh" -l ${LOGFILE} >> /dev/null 2>&1
	if [ $? -ne 0 ]; then
		_err_msg_="Error running script ${ENIQ_CORE_BIN_DIR}/updateVersionDB.bsh . Please refer logs \n"
		abort_script "${_err_msg_}"
	fi
fi

$ECHO "\nStarting to install platform modules with command" >> ${LOGFILE}
$ECHO "$SU - ${_sysuser_} -c \"$SW_DIR/${_eniq_sw_src_dir_}/${_eniq_sw_inst_prog_} $SW_DIR/${_eniq_sw_src_dir_} ${_eniq_partition_plan_} $CURR_SERVER_TYPE" >> ${LOGFILE}
$SU - ${_sysuser_} -c "$SW_DIR/${_eniq_sw_src_dir_}/${_eniq_sw_inst_prog_} $SW_DIR/${_eniq_sw_src_dir_} ${_eniq_partition_plan_} $CURR_SERVER_TYPE" >> ${LOGFILE}

_res_code_=$?
if [ ${_res_code_} -ne 0 ]; then
	_err_msg_="Failure in $SW_DIR/${_eniq_sw_src_dir_}/${_eniq_sw_inst_prog_} (code: ${_res_code_})"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

insert_header_footer foot "Successfully installed ENIQ Platform" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: install_extra_fs ###
#
# Installs extra file systems if required
#
# Arguments:
#   none
# Return Values:
#   none
install_extra_fs()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}
if [ ! "$ZONE" ]; then
	# Need to stop hostsync from logging during this
	_hostsync_smf_str_=`iniget HOST_SYNC_DAEMON -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v HOST_SYNC_SERVICE_STR`
	if [ ! "${_hostsync_smf_str_}" ]; then
		_err_msg_="Could not read host_syncd SMF string from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	log_msg -s  "Disabling ${_hostsync_smf_str_}" -l ${LOGFILE}
	$SYSTEMCTL disable ${_hostsync_smf_str_}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not disable ${_hostsync_smf_str_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	
	log_msg -s  "Stopping ${_hostsync_smf_str_}" -l ${LOGFILE}
	$SYSTEMCTL stop ${_hostsync_smf_str_}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not stop ${_hostsync_smf_str_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

# Read the storage type
read_storage_type

EXTRA_FS_LIST="installation local_logs smf"

if [ ! -s ${SCRIPTHOME}/update_sunos_ini.bsh ]; then
	_err_msg_="Could not find ${SCRIPTHOME}/update_sunos_ini.bsh script"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Update the ini files if required
log_msg -s "\nUpdating SunOs.ini file with new file system information using command" -l ${LOGFILE}
log_msg -s "${BASH} ${SCRIPTHOME}/update_sunos_ini.bsh -s ${STORAGE_TYPE}" -l ${LOGFILE}
${BASH} ${SCRIPTHOME}/update_sunos_ini.bsh -s ${STORAGE_TYPE} -l ${LOGFILE}
if [ $? -ne 0 ]; then
	_err_msg_="Error attempting to update ini file(s)"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# List of FS filesystems to create and mount at the end of installation
#####this needs to be looked at for upgrades what file systems need to be added for the upgrade paths
if [ "$INSTALL_TYPE" == "stats" -a "${STORAGE_TYPE}" == "fs" ]; then
	EXTRA_FS_LIST="${EXTRA_FS_LIST} log sentinel"
fi

# Get the System User/Group. All directories are owned by this
_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file\n${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysgrp_=`$ID ${_sysuser_}|$AWK '{print $2}'|$AWK -F\( '{print $2}'|$AWK -F\) '{print $1}'`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not determine group ID of ${_sysuser_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_bin_dir_=`$CAT ${ENIQ_CONF_DIR}/${ENIQ_ENV} | $EGREP '^[[:blank:]]*BIN_DIR=' | $AWK -F\= '{print $2}'`
if [ ! "${_bin_dir_}" ]; then
	_err_msg_="Could not read BIN_DIR parameter from ${ENIQ_CONF_DIR}/${ENIQ_ENV}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ "${SERVER_TYPE}" == "CO" -a "${CURR_SERVER_TYPE}" != "eniq_es" ]; then
	$RM -f ${TEM_DIR}/service_list.$$
	$RM -f ${TEM_DIR}/.error_file.$$.$$.$$
	for _srv_ in ${ENIQ_STOP_SERVICES}; do
		if [ ! -x ${_bin_dir_}/${_srv_} ]; then
			continue
		fi
		$ECHO "${_bin_dir_}/${_srv_} stop" >> ${TEM_DIR}/service_list.$$
		$ECHO "if [ $? -ne 0 ]; then" >> ${TEM_DIR}/service_list.$$
		$ECHO "exit 1" >> ${TEM_DIR}/service_list.$$
		$ECHO "fi" >> ${TEM_DIR}/service_list.$$
	done

	if [ -f ${TEM_DIR}/service_list.$$ ]; then
		$CHOWN ${_sysuser_}:${_sysgrp_} ${TEM_DIR}/service_list.$$
		if [ $? -ne 0 ]; then
			_err_msg_="Error setting ownership of ${TEM_DIR}/service_list.$$ to ${_sysuser_}:${_sysgrp_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		$SU - ${_sysuser_} -c "${BASH} ${TEM_DIR}/service_list.$$" 2>/dev/null
		if [ -f ${TEM_DIR}/.error_file.$$.$$.$$ ]; then
			  abort_script "Could not stop ENIQ service(s)" "${EXEC_SHELL_CMD}"
		fi
	fi
fi

if [ "${STORAGE_TYPE}" == "raw" ]; then
	log_msg -s "Creating a list of volume groups from ${ENIQ_CONF_DIR}/${SUNOS_INI}\n" -l ${LOGFILE}
	_pool_list_=`iniget SunOS_FS_POOL -f ${ENIQ_CONF_DIR}/${SUNOS_INI}`
	for _pool_ in ${_pool_list_}; do
		_pool_disk_layout_=`iniget ${_pool_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v disk_layout`
		if [ ! "${_pool_disk_layout_}" ]; then
			_err_msg_="Could not determine disk ${_pool_disk_layout_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	done

	# Getting the size of Volume Group
	if [ -f ${ENIQ_CONF_DIR}/lun_map.ini ]; then

		_disk_label_list_=`iniget LUN_MAP_DETAILS -f ${ENIQ_CONF_DIR}/lun_map.ini`
		if [ ! "${_disk_label_list_}" ]; then
			_err_msg_="Could not determine value of _disk_label_list_"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		for _tag_ in ${_disk_label_list_}; do
	
			_disk_id_=`iniget ${_tag_} -f ${ENIQ_CONF_DIR}/lun_map.ini -v DISK_ID`
			if [ ! "${_disk_id_}" ]; then
				_err_msg_="Could not determine _disk_id_ for ${_tag_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		
			if [ "${_disk_id_}" == "${_pool_disk_layout_}" ]; then
				_disk_tag_=${_tag_}
				break
			fi	
	
		done

		if [ ! "${_disk_tag_}" ]; then
			_err_msg_="Could not find the block for ${_pool_disk_layout_} in ${ENIQ_CONF_DIR}/lun_map.ini"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	
		_disk_size_=`iniget ${_disk_tag_} -f ${ENIQ_CONF_DIR}/lun_map.ini -v SIZE`
		if [ ! "${_disk_size_}" ]; then
			_err_msg_="Could not determine disk size of ${_pool_disk_layout_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

	else
		_err_msg_="Could not locate lun_map.ini file"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	_pool_info_=`iniget SunOS_FS_POOL -f ${ENIQ_CONF_DIR}/${SUNOS_INI} | $HEAD -1`
	if [ ! "${_pool_info_}" ]; then
		_err_msg_="Could not read parameter SunOS_ZFS_POOL from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	_pool_name_=`iniget ${_pool_info_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v name`
	if [ ! "${_pool_name_}" ]; then
		_err_msg_="Could not read parameter name from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	if [  "${CURR_SERVER_TYPE}" == "stats_coordinator" -o "${CURR_SERVER_TYPE}" == "eniq_stats" ]; then
		_avail_disk_size_=`$EXPR ${_disk_size_} - ${MAX_16G_SWAP}`
		if [ ! "${_avail_disk_size_}"  ]; then
		  _err_msg_="Could not determine avaialable disk size ${_pool_disk_layout_}"
		  abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	else
		_avail_disk_size_=`$EXPR ${_disk_size_} - ${MAX_8G_SWAP}`
		if [ ! "${_avail_disk_size_}"  ]; then
		  _err_msg_="Could not determine disk size available space of ${_pool_disk_layout_}"
		  abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi

	# Getting the tag for FS size based on server type
	get_fs_size_tag

	# Take bakup of /etc/fstab file 
	$CP ${FSTAB} ${TEM_DIR}/fstab
	if [ $? -ne 0 ]; then
		_err_msg_="Could not backup ${FSTAB} file "
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	for _fs_ in ${EXTRA_FS_LIST}; do
		$LVS --no-headings -o lv_name ${_pool_name_} | $EGREP -w "${_fs_}">> /dev/null 2>&1
		if [ $? -ne 0 ]; then
			_inst_fs_name_="${_pool_name_}-${_fs_}"
			_inst_fs_mount_pt_="${ENIQ_BASE_DIR}/${_fs_}"
			_fs_perms_=755
			_percent_size_=`iniget ${_fs_size_tag_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v "${_fs_}" | $AWK -F ":" '{print $1}'`
			if [ ! "${_percent_size_}"  ]; then
				_err_msg_="Could not determine _percent_size_ of ${_inst_fs_name_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
	
			_final_percent_size_=`$ECHO "scale=6; ${_percent_size_}/100" | $BC`
			if [ ! "${_final_percent_size_}"  ]; then
				_err_msg_="Could not determine value of _final_percent_size_"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			_size_fs_=`$AWK -v _disk_size_=${_avail_disk_size_} -v _final_size_=${_final_percent_size_} 'BEGIN {print _disk_size_ * _final_size_}'`
			if [ ! "${_size_fs_}"  ]; then
				_err_msg_="Could not determine size of ${_inst_fs_name_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			 _fs_overhead_=`iniget ${_fs_size_tag_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v "${_fs_}" | $AWK -F ":" '{print $3}'`
			if [ ! "${_fs_overhead_}"  ]; then
				 _err_msg_="Could not determine FS Overhead of ${_inst_fs_name_}"
				 abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

	
			$VGDISPLAY ${_pool_name_} >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Could not locate volume group - ${_pool_name_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			# Unmounting FS if exists 
			$UMOUNT -l ${_inst_fs_mount_pt_} >> /dev/null 2>&1

			# Removing mountpoint of FS after taking its backup
			_dir_size_=`$LS ${_inst_fs_mount_pt_}/`
			if [ -d ${_inst_fs_mount_pt_} ]; then
				# If dir_size is empty
				if [ -z "${_dir_size_}" ]; then
					$TOUCH ${_inst_fs_mount_pt_}/lost+found
				fi

				# Copying the content of FS mount point to /var/tmp before making FS
				cd ${_inst_fs_mount_pt_}  
				$FIND . -depth -print | $CPIO -pdmu ${VAR_TMP_DIR}/${_fs_}/ >> /dev/null 2>&1
				if [ $? -ne 0 ]; then
					_err_msg_="Error copying ${_inst_fs_mount_pt_} to ${VAR_TMP_DIR}"
					abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				fi
				cd /
			fi
			# Removing FS if exists before creating it again   
			$LVREMOVE -y /dev/${_pool_name_}/${_fs_} >> /dev/null 2>&1

			# Removing the entry in /etc/fstab file if exists
			$CAT ${TEM_DIR}/fstab | $GREP ${_pool_name_}-${_fs_} >> /dev/null 2>&1
			_ret_status_=`$ECHO ${PIPESTATUS[1]}`
			if [ ${_ret_status_} -eq 0 ]; then
				$SED -i "/${_inst_fs_name_}/d" ${TEM_DIR}/fstab >> /dev/null 2>&1
				if [ $? -ne 0 ]; then
					_err_msg_="Could not remove ${_inst_fs_name_} entry from ${TEM_DIR}/fstab file"
					abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				fi
			fi

			log_msg -s "\nCreating file system /dev/${_pool_name_}/${_fs_}" -l ${LOGFILE}
			$LVCREATE -y -L ${_size_fs_}G -n ${_fs_} ${_pool_name_}  >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Could not create file system /dev/${_pool_name_}/${_fs_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			# Unmounting FS if it gets mounted before formatting		
			$UMOUNT -l ${_inst_fs_mount_pt_} >> /dev/null 2>&1
		
			log_msg -s "Formatting file system /dev/${_pool_name_}/${_fs_} ${FS_TYPE} file system" -l ${LOGFILE}
			${MKFS_EXT4} -m ${_fs_overhead_} /dev/${_pool_name_}/${_fs_} >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Could not format file system `$BASENAME ${_fs_name_}` with ${FS_TYPE} "
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			# Destroy the FS mountpoint if it exists
			$RM -rf ${_inst_fs_mount_pt_}/* >> /dev/null 2>&1

			# Re-creating FS mount point
			$MKDIR -p ${_inst_fs_mount_pt_}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not create Mount Point"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			# Mounting the newly created FS
			$MOUNT /dev/mapper/${_inst_fs_name_} ${_inst_fs_mount_pt_}
			if [ $? -ne 0 ]; then
				_err_msg_="Could note mount /dev/mapper/${_inst_fs_name_} on ${_inst_fs_mount_pt_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			# Updating the FSTAB file with newly created FS   
			$ECHO "/dev/mapper/${_inst_fs_name_} ${_inst_fs_mount_pt_}				   ${FS_TYPE}	auto,rw		0 2" >> ${TEM_DIR}/fstab 
			 

			# Copying back directory from /var/tmp to /eniq
			cd ${VAR_TMP_DIR}/${_fs_}/
			$FIND . -depth -print | $CPIO -pdmu ${_inst_fs_mount_pt_}/ >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
			   _err_msg_="Could not revert back ${VAR_TMP_DIR}/${_fs_} to ${_inst_fs_mount_pt_}/ directory"
			   abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
			cd /
			if [ "${_fs_}" == "smf" -o "${_fs_}" == "installation" ]; then
				log_msg -s "Successfully created /dev/mapper/${_inst_fs_name_} filesystem\n" -l ${LOGFILE}
				continue
			else
				log_msg -s "Changing ownership of ${ENIQ_BASE_DIR}/${_fs_} to ${_sysuser_}:${_sysgrp_}" -l ${LOGFILE}
				$CHOWN ${_sysuser_}:${_sysgrp_} ${ENIQ_BASE_DIR}/${_fs_}
				if [ $? -ne 0 ]; then
					_err_msg_="Error setting ownership of ${ENIQ_BASE_DIR}/${_fs_} to ${_sysuser_}:${_sysgrp_}"
					abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				fi
			fi

			# Removing the directory created under /var/tmp
			$RM -rf ${VAR_TMP_DIR}/${_fs_}/
			if [ $? -ne 0 ]; then
				_err_msg_="Could not remove ${VAR_TMP_DIR}/${_fs_}/ directory"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			log_msg -s "Successfully created /dev/mapper/${_inst_fs_name_} file system\n" -l ${LOGFILE}
		fi
	done
else

	if [ -s ${ENIQ_CONF_DIR}/extra_params/deployment ]; then
		_deployment_=`$CAT ${ENIQ_CONF_DIR}/extra_params/deployment`
	else
		_err_msg_="Parameter \"deployment\" incorrectly specified, or is missing from boot command"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	log_msg -s "Creating a list of volume groups from ${ENIQ_CONF_DIR}/${SUNOS_INI}\n" -l ${LOGFILE}
	_pool_info_=`iniget SunOS_FS_POOL -f ${ENIQ_CONF_DIR}/${SUNOS_INI} | $HEAD -1`
	if [ ! "${_pool_info_}" ]; then
		_err_msg_="Could not read parameter SunOS_ZFS_POOL from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	_pool_name_=`iniget ${_pool_info_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v name`
	if [ ! "${_pool_name_}" ]; then
		_err_msg_="Could not read parameter name from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
   
	# Getting the size of Volume Group
	_vg_size_=`$VGS ${_pool_name_} --noheadings -o vg_size | $SED -e 's/[^0-9.]//g'`
	if [ ! "${_vg_size_}" ]; then
		  _err_msg_="Could not determine Volume Group size"
		  abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	 _vg_size_unit_=`$VGS ${_pool_name_} --noheadings -o vg_size | $SED -e 's/[^a-z]//g'`
	if [ ! "${_vg_size_unit_}" ]; then
		  _err_msg_="Could not determine Volume Group size unit"
		  abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
   
	if [ "${_vg_size_unit_}" == "t" ]; then
		 _vg_size_=`$ECHO " scale=4; ${_vg_size_}*1024" | $BC`
	fi

	#Getting Volume Group size excluding swap volume
	if [ "${_deployment_}" == "small" -o "${_deployment_}" == "ft" ]; then
		_avail_pool_size_=`$ECHO " scale=4; ${_vg_size_} - ${MAX_16G_SWAP} - ${MAX_16G_SWAP}" | $BC`
		if [ ! "${_avail_pool_size_}"  ]; then
			_err_msg_="Could not determine avaialable pool size in ${_pool_name_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
		#Making available pool size to half for Comapct deployments
		_avail_pool_size_=`$ECHO " scale=4; ${_avail_pool_size_}/2" | $BC`
		 if [ ! "${_avail_pool_size_}"  ]; then
			_err_msg_="Could not determine avaialable pool size in ${_pool_name_} for Comapct deployment"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

	else
		_avail_pool_size_=`$ECHO " scale=4; ${_vg_size_} - ${MAX_16G_SWAP} "| $BC`
		if [ ! "${_avail_pool_size_}"  ]; then
			_err_msg_="Could not determine avaialable pool size in ${_pool_name_} "
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi

 
	# Getting the tag for FS size based on server type
	get_fs_size_tag

	# Getting current hardware generation
	_hard_gen_=`$DMIDECODE -s system-product-name | $AWK -F " " '{print $2}'`
	if [ ! "${_hard_gen_}" ]; then
		 _err_msg_="Could not determine current hardware generation"
		 abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	_fs_size_tag_=${_hard_gen_}_${_fs_size_tag_}


	# Take bakup of /etc/fstab file 
	$CP ${FSTAB} ${TEM_DIR}/fstab
	if [ $? -ne 0 ]; then
		_err_msg_="Could not backup ${FSTAB} file"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	for _fs_ in ${EXTRA_FS_LIST}; do
		$LVS --no-headings -o lv_name ${_pool_name_} | $EGREP -w "${_fs_}">> /dev/null 2>&1
		if [ $? -ne 0 ]; then
			_inst_fs_name_="${_pool_name_}-${_fs_}"
			_inst_fs_mount_pt_="${ENIQ_BASE_DIR}/${_fs_}"
			_fs_perms_=755
			_percent_size_=`iniget ${_fs_size_tag_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v "${_fs_}" | $AWK -F ":" '{print $1}'`
			if [ ! "${_percent_size_}"  ]; then
				_err_msg_="Could not determine _percent_size_ of ${_inst_fs_name_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
	
			_final_percent_size_=`$ECHO "scale=6; ${_percent_size_}/100" | $BC`
			if [ ! "${_final_percent_size_}"  ]; then
				_err_msg_="Could not determine value of _final_percent_size_"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			_size_fs_=`$ECHO " scale=4; ${_avail_pool_size_}*${_final_percent_size_}" | $BC`
			if [ ! "${_size_fs_}"  ]; then
				_err_msg_="Could not determine size of ${_inst_fs_name_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			_size_fs_min_=`iniget FS_MIN_SIZE -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ${_fs_}`
			if [  "${_size_fs_min_}"  ]; then
				  if [ "$($ECHO "${_size_fs_} < ${_size_fs_min_}" | bc)" -eq 1 ]; then
						_size_fs_="${_size_fs_min_}"
				  fi
			fi

			_fs_overhead_=`iniget ${_fs_size_tag_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v "${_fs_}" | $AWK -F ":" '{print $3}'`
			if [ ! "${_fs_overhead_}"  ]; then
				 _err_msg_="Could not determine FS Overhead of ${_inst_fs_name_}"
				 abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

	
			$VGDISPLAY ${_pool_name_} >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Could not locate volume group - ${_pool_name_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			# Unmounting FS if exists 
			$UMOUNT -l ${_inst_fs_mount_pt_} >> /dev/null 2>&1

			# Removing mountpoint of FS after taking its backup
			_dir_size_=`$LS ${_inst_fs_mount_pt_}/`
			if [ -d ${_inst_fs_mount_pt_} ]; then
				# If dir_size is empty
				if [ -z "${_dir_size_}" ]; then
					$TOUCH ${_inst_fs_mount_pt_}/lost+found
				fi

				# Copying the content of FS mount point to /var/tmp before making FS
				cd ${_inst_fs_mount_pt_}  
				$FIND . -depth -print | $CPIO -pdmu ${VAR_TMP_DIR}/${_fs_}/ >> /dev/null 2>&1
				if [ $? -ne 0 ]; then
					_err_msg_="Error copying ${_inst_fs_mount_pt_} to ${VAR_TMP_DIR}"
					abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				fi
				cd /
			fi
			# Removing FS if exists before creating it again   
			$LVREMOVE -y /dev/${_pool_name_}/${_fs_} >> /dev/null 2>&1

			# Removing the entry in /etc/fstab file if exists
			$CAT ${TEM_DIR}/fstab | $GREP ${_pool_name_}-${_fs_} >> /dev/null 2>&1
			_ret_status_=`$ECHO ${PIPESTATUS[1]}`
			if [ ${_ret_status_} -eq 0 ]; then
				$SED -i "/${_inst_fs_name_}/d" ${TEM_DIR}/fstab >> /dev/null 2>&1
				if [ $? -ne 0 ]; then
					_err_msg_="Could not remove ${_inst_fs_name_} entry from ${TEM_DIR}/fstab file"
					abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				fi
			fi
			if  [ "${_deployment_}" == "small" -o "${_deployment_}" == "ft" ]; then
				log_msg -s "\nCreating file system /dev/${_pool_name_}/${_fs_}" -l ${LOGFILE}
				$LVCREATE -y --type mirror -L ${_size_fs_}G -m1 -n ${_fs_} ${_pool_name_}  >> /dev/null 2>&1
				if [ $? -ne 0 ]; then
					_err_msg_="Could not create file system /dev/${_pool_name_}/${_fs_}"
					abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				fi
			else  
				log_msg -s "\nCreating file system /dev/${_pool_name_}/${_fs_}" -l ${LOGFILE}
				$LVCREATE -y -L ${_size_fs_}G -n ${_fs_} ${_pool_name_}  >> /dev/null 2>&1
				if [ $? -ne 0 ]; then
					_err_msg_="Could not create file system /dev/${_pool_name_}/${_fs_}"
					abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				fi
			fi
			# Unmounting FS if it gets mounted before formatting		
			$UMOUNT -l ${_inst_fs_mount_pt_} >> /dev/null 2>&1
		
			log_msg -s "Formatting file system /dev/${_pool_name_}/${_fs_} ${FS_TYPE} file system" -l ${LOGFILE}
			${MKFS_EXT4} -m ${_fs_overhead_} /dev/${_pool_name_}/${_fs_} >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Could not format file system `$BASENAME ${_fs_name_}` with ${FS_TYPE} "
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			# Destroy the FS mountpoint if it exists
			$RM -rf ${_inst_fs_mount_pt_}/* >> /dev/null 2>&1

			# Re-creating FS mount point
			$MKDIR -p ${_inst_fs_mount_pt_}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not create Mount Point"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			# Mounting the newly created FS
			$MOUNT /dev/mapper/${_inst_fs_name_} ${_inst_fs_mount_pt_}
			if [ $? -ne 0 ]; then
				_err_msg_="Could note mount /dev/mapper/${_inst_fs_name_} on ${_inst_fs_mount_pt_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			# Updating the FSTAB file with newly created FS   
			$ECHO "/dev/mapper/${_inst_fs_name_} ${_inst_fs_mount_pt_}				   ${FS_TYPE}	defaults		0 2" >> ${TEM_DIR}/fstab 

			# Copying back directory from /var/tmp to /eniq
			cd ${VAR_TMP_DIR}/${_fs_}/
			$FIND . -depth -print | $CPIO -pdmu ${_inst_fs_mount_pt_}/ >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Could not revert back ${VAR_TMP_DIR}/${_fs_} to ${_inst_fs_mount_pt_}/ directory"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
			cd /
			if [ "${_fs_}" == "smf" -o "${_fs_}" == "installation" ]; then
				log_msg -s "Successfully created /dev/mapper/${_inst_fs_name_} filesystem\n" -l ${LOGFILE}
				continue
			else
				log_msg -s "Changing ownership of ${ENIQ_BASE_DIR}/${_fs_} to ${_sysuser_}:${_sysgrp_}" -l ${LOGFILE}
				$CHOWN ${_sysuser_}:${_sysgrp_} ${ENIQ_BASE_DIR}/${_fs_}
				if [ $? -ne 0 ]; then
					_err_msg_="Error setting ownership of ${ENIQ_BASE_DIR}/${_fs_} to ${_sysuser_}:${_sysgrp_}"
					abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				fi
			fi

			# Removing the directory created under /var/tmp
			$RM -rf ${VAR_TMP_DIR}/${_fs_}/
			if [ $? -ne 0 ]; then
				_err_msg_="Could not remove ${VAR_TMP_DIR}/${_fs_}/ directory"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			log_msg -s "Successfully created /dev/mapper/${_inst_fs_name_} file system\n" -l ${LOGFILE}
		fi
	done
fi
# Copying the temp fstab file to /etc/fstab
log_msg -s "Updating the ${FSTAB} file with newly created file system\n" -l ${LOGFILE}
$CP ${TEM_DIR}/fstab ${FSTAB}
if [ $? -ne 0 ]; then
	_err_msg_="Failed to update ${FSTAB} file"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Checking the consistency of /etc/fstab
log_msg -s "Checking consistency of ${FSTAB} file" -l ${LOGFILE}
$MOUNT -a >> /dev/null 2>&1
if [ $? -ne 0 ]; then
    $CAT ${FSTAB} | $GREP ${BIS_MOUNT_PT} > /dev/null
    if [ $? -eq 0 ]; then
    $UMOUNT -l ${BIS_MOUNT_PT} > /dev/null
        if [ $? -ne 0 ]; then
        _err_msg_="Error while unmounting ${BIS_MOUNT_PT}"
        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"	
        fi     
    $MOUNT -a >> /dev/null 2>&1
        if [ $? -ne 0 ]; then
        _err_msg_="Error while mounting ${BIS_MOUNT_PT}"
        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"	
        fi     
    fi
	_err_msg_="Error while mounting entries in ${FSTAB} file"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

insert_header_footer foot "Successfully completed core install stage - ${NEXT_STAGE}" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: install_freeware ###
#
# Install Freeware SW
#
# Arguments:
#   none
# Return Values:
#   none
install_freeware()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

if [ -s ${ENIQ_CONF_DIR}/${SUNOS_INI} ]; then
	_ini_src_dir_=${ENIQ_CONF_DIR}
	_ini_file_=${SUNOS_INI}
else
	_ini_src_dir_=${ENIQ_TEMPL_DIR}
	_ini_file_="${SUNOS_INI}_${SAN_DEVICE}"
fi

_freeware_sw_source_dir_=`iniget FREEWARE_SW -f ${_ini_src_dir_}/${_ini_file_} -v FREEWARE_SW_SOURCE_DIR`
if [ ! "${_freeware_sw_source_dir_}" ]; then
	_err_msg_="Could not read FREEWARE_SW_SOURCE_DIR param from ${_ini_src_dir_}/${_ini_file_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_freeware_sw_inst_prog_=`iniget FREEWARE_SW -f ${_ini_src_dir_}/${_ini_file_} -v FREEWARE_SW_INST_PROG`
if [ ! "${_freeware_sw_inst_prog_}" ]; then
	_err_msg_="Could not read FREEWARE_SW_INST_PROG param from ${_ini_src_dir_}/${_ini_file_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_freeware_sw_pkgs_to_inst_=`iniget FREEWARE_SW -f ${_ini_src_dir_}/${_ini_file_} -v FREEWARE_SW_PKGS_TO_INST`
if [ ! "${_freeware_sw_pkgs_to_inst_}" ]; then
	_err_msg_="Could not read FREEWARE_SW_PKGS_TO_INST param from ${_ini_src_dir_}/${_ini_file_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_freeware_sw_pkgs_to_inst_=`$ECHO ${_freeware_sw_pkgs_to_inst_} \
					   | $SED -e 's| |,|g' -e 's|\,[\,]*|\,|g' -e 's|[\,]*$||g'`

# Set the OM dir value
if [ "${UPGRADE}" -a "${OM_SW_DIR}" ]; then
	SW_DIR=${OM_SW_DIR}
else
	if [ -d ${DEF_CACHE_DIR}/${_freeware_sw_source_dir_}/${_freeware_sw_pkg_name_} ]; then
		SW_DIR=${DEF_CACHE_DIR}
	else
		if [ "${OM_SW_PATH_FILE}" ]; then
			insert_media -l om -f ".om" -s ${OM_SW_PATH_FILE} -n 5 "Operation and Maintenance DVD"
		else
			insert_media -l om -f ".om" -n 5 "Operation and Maintenance DVD"
		fi
	fi
fi

if [ ! "$SW_DIR" ]; then
	_err_msg_="Failed to locate cached O&M Media!"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Set script location
_inst_script_=${SW_DIR}/${_freeware_sw_source_dir_}/${_freeware_sw_inst_prog_}
if [ -s ${_inst_script_} ]; then
	# Run the add SAN SW script
	/usr/bin/bash ${_inst_script_} -l ${_freeware_sw_pkgs_to_inst_} | $TEE -a ${LOGFILE}
	if [ $? -ne 0 ]; then
		abort_script "Exiting...." "${EXEC_SHELL_CMD}"
	fi
fi

insert_header_footer foot "Successfully installed Freeware SW" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: insert_header_footer ###
#
#   Insert a stage header/footer message
#
# Arguments:
#   $1 : head/foot
#   $2 : Message
#   $3 : Logfile
# Return Values:
#   none
insert_header_footer()
{
if [ $# -ne 3 ]; then
	_err_msg_="3 Parameters must be passed to header/footer function"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ "$1" != "head" -a "$1" != "foot" ]; then
	_err_msg_="Only Param of head/foot is allowed...exiting!"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
_type_=$1

_msg_=$2

_logfile_=$3
$MKDIR -p `$DIRNAME ${_logfile_}`
if [ $? -ne 0 ]; then
	_err_msg_="Could not create directory `$DIRNAME ${_logfile_}`"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$TOUCH -a ${_logfile_}
if [ $? -ne 0 ]; then
	_err_msg_="Could not write to file ${_logfile_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_time_=`$DATE '+%Y-%b-%d_%H.%M.%S'`
if [ "$_type_" == "head" ]; then
	$ECHO -e "\n-----------------------------------------------------" | $TEE -a ${_logfile_}
	$ECHO "-----------------------------------------------------" | $TEE -a ${_logfile_}
	$ECHO "$_time_ : $_msg_" | $TEE -a ${_logfile_}
	$ECHO "-----------------------------------------------------" | $TEE -a ${_logfile_}
fi

if [ "$_type_" == "foot" ]; then
	$ECHO -e "\n-----------------------------------------------------" | $TEE -a ${_logfile_}
	$ECHO "$_time_ : $_msg_" | $TEE -a ${_logfile_}
	$ECHO "-----------------------------------------------------" | $TEE -a ${_logfile_}
	$ECHO -e "-----------------------------------------------------\n" | $TEE -a ${_logfile_}
fi
}

### Function: install_host_syncd ###
#
# Install the service and daemon to sync hosts file
#
# Arguments:
#   none
# Return Values:
#   none
#
install_host_syncd()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

if [ ! "$ZONE" ]; then
	# Read the storage type
	read_storage_type

	if [ "${UPGRADE}" ]; then
		_sunos_file_=${ENIQ_TEMPL_DIR}/${SUNOS_INI}_${SAN_DEVICE}
	else
		_sunos_file_=${ENIQ_CONF_DIR}/${SUNOS_INI}
	fi

	# Create the ini_config_file.cfg from the relevant template directory
	# check template cfg file exists
	if [ ! -s ${ENIQ_TEMPL_DIR}/ini_config_file.cfg ]; then
		_err_msg_="Failed to locate hostsync config file - ${ENIQ_TEMPL_DIR}/ini_config_file.cfg"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	# Make the smf/etc directory if required
	if [ ! -d ${ENIQ_BASE_DIR}/smf/etc ]; then
		log_msg -s "Creating ${ENIQ_BASE_DIR}/smf/etc" -q -l ${LOGFILE}
		$MKDIR -p ${ENIQ_BASE_DIR}/smf/etc
		if [ $? -ne 0 ]; then
			_err_msg_="Could not create ${ENIQ_BASE_DIR}/smf/etc"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi

	log_msg -s "Creating ${ENIQ_BASE_DIR}/smf/etc/ini_config_file.cfg" -q -l ${LOGFILE}
	# Copy from template directory to /eniq/smf/etc
	$CAT ${ENIQ_TEMPL_DIR}/ini_config_file.cfg | $SED -e "s|<CHANGE><ENIQ_BASE_DIR>|${ENIQ_BASE_DIR}|g" > ${ENIQ_BASE_DIR}/smf/etc/ini_config_file.cfg
	if [ ! -s ${ENIQ_BASE_DIR}/smf/etc/ini_config_file.cfg ]; then
		_err_msg_="Failed to create hostsync config file - ${ENIQ_BASE_DIR}/smf/etc/ini_config_file.cfg"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	# Get hostsyncd info from ini file
	_src_dir_=`iniget HOST_SYNC_DAEMON -f ${_sunos_file_} -v HOST_SYNC_DAEMON_SOURCE_DIR`
	_inst_prog_=`iniget HOST_SYNC_DAEMON -f ${_sunos_file_} -v HOST_SYNC_DAEMON_INST_PROG`
	if [ ! "${_src_dir_}" -o ! "${_inst_prog_}" ]; then
		_err_msg_="Could not read all required host_syncd info from ${_sunos_file_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	# Check that the bundle exists
	_host_syncd_sw_loc_="${ENIQ_COMMON_SW_DIR}/${_src_dir_}"
	if [ ! -s ${_host_syncd_sw_loc_} ]; then
		_err_msg_="Failed to find host_syncd SW bundle - ${_host_syncd_sw_loc_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	# Check that the hostsyncd install script exists
	if [ ! -s ${SCRIPTHOME}/${_inst_prog_} ]; then
		_err_msg_="Failed to locate hostsyncd installation script - ${SCRIPTHOME}/${_inst_prog_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	# Call the hostsyncd install script
	log_msg -s "Installing hostsyncd using command" -q -l ${LOGFILE}
	log_msg -s "${BASH} ${SCRIPTHOME}/${_inst_prog_} -d ${_host_syncd_sw_loc_} -l ${LOGFILE}" -q -l ${LOGFILE}
	${BASH} ${SCRIPTHOME}/${_inst_prog_} -d ${_host_syncd_sw_loc_} -l ${LOGFILE}
	if [ $? -ne 0 ]; then
		_err_msg_="Error when running ${SCRIPTHOME}/${_inst_prog_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
else
	log_msg -s "\nAs this is ZONE server just adding the services to the hosts file" -l ${LOGFILE}
	_hosts_file_="/etc/hosts"
	$CP ${_hosts_file_} ${_hosts_file_}.$$
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy ${_hosts_file_} to ${_hosts_file_}.$$"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	_alias_list_="dwhdb engine licenceservice repdb webserver"
	$CAT ${_hosts_file_} > ${TEM_DIR}/hosts
	for _alias_ in ${_alias_list_}; do
		$ECHO "${HOST_IP} ${HNAME} ${_alias_}" >> ${TEM_DIR}/hosts
	done

	$CP ${TEM_DIR}/hosts ${_hosts_file_}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not update ${_hosts_file_} with alias information for ZONE"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

insert_header_footer foot "Successfully installed hostsyncd" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: install_nasd ###
#
# Install the nas daemon
#
# Arguments:
#   none
# Return Values:
#   none
#
install_nasd()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" != "raw" ]; then
	insert_header_footer foot "FS install - Skipping NASd Software Installation" ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

# Get the SW_DIR
get_sw_dir

# Get NASd info from ini file
_src_dir_=`iniget NAS_DAEMON -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v NAS_DAEMON_SOURCE_DIR`
_sw_bndl_=`iniget NAS_DAEMON -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v NAS_DAEMON_SW_BUNDLE`
_inst_prog_=`iniget NAS_DAEMON -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v NAS_DAEMON_INST_PROG`
_nas_smf_str_=`iniget NAS_DAEMON -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v NAS_SERVICE_STR`
if [ ! "${_src_dir_=}" -o ! "${_sw_bndl_}" -o ! "${_inst_prog_}" -o ! "${_nas_smf_str_}" ]; then
	_err_msg_="Could not read all required NASd info from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Check that the bundle exists
_nasd_sw_bundle_="$SW_DIR/${_src_dir_}/${_sw_bndl_}"
if [ ! -s ${_nasd_sw_bundle_} ]; then
	_err_msg_="Failed to find NASd SW bundle - ${_nasd_sw_bundle_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Check that the NASd install script exists
if [ ! -s ${SCRIPTHOME}/${_inst_prog_} ]; then
	_err_msg_="Failed to locate NASd installation script - ${SCRIPTHOME}/${_inst_prog_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Call the NASd install script
$ECHO "Installing NASd using command:" >> ${LOGFILE}
$ECHO "${BASH} ${SCRIPTHOME}/${_inst_prog_} -s ${_nasd_sw_bundle_} -l ${LOGFILE}\n" >> ${LOGFILE}
${BASH} ${SCRIPTHOME}/${_inst_prog_} -s ${_nasd_sw_bundle_} -l ${LOGFILE}
if [ $? -ne 0 ]; then
	_err_msg_="Error when running ${SCRIPTHOME}/${_inst_prog_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi


# Switch off the NASd service until the next reboot
# Only do this if I'm an install only
if [ ! "${UPGRADE}" ]; then
	$ECHO "Stopping ${_nas_smf_str_} after service installation" | $TEE -a $LOGFILE
	${SYSTEMCTL} stop ${_nas_smf_str_} >> /dev/null 2>&1
else
	
	local _service_state=`${SYSTEMCTL} show -p LoadState ${_nas_smf_str_} | $AWK -F= '{print $2}'`
	if [ "${_service_state}" == "not-found" ];  then
		_err_msg_="${_nas_smf_str_} service does not exist"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	 
	local _service_state=`${SYSTEMCTL} show ${_nas_smf_str_} -p ActiveState | $AWK -F= '{print $2}'`
	if [ "${_service_state}" == "inactive" ]; then
		$ECHO "${_nas_smf_str_} service already in inactive state, continuing..." | $TEE -a $LOGFILE
	else
		$ECHO "Stopping ${_nas_smf_str_} service" | $TEE -a $LOGFILE
		${SYSTEMCTL} reset-failed ${_nas_smf_str_} >> /dev/null 2>&1
		${SYSTEMCTL} stop ${_nas_smf_str_}
		local _service_state=`$SYSTEMCTL show ${_nas_smf_str_} -p ActiveState | $AWK -F= '{print $2}'`
		if [ "${_service_state}" != "inactive" ] ; then
			$ECHO "WARNING ${_nas_smf_str_} " | $TEE -a $LOGFILE
		fi
	fi
	# Give NAS 1 minute to go change stage
	local _count_time=0
	while [ $_count_time -lt 2 ] ; do
		$SLEEP 60
		local _service_state=`${SYSTEMCTL} show ${_nas_smf_str_} -p ActiveState | $AWK -F= '{print $2}'`
		if [ "${_service_state}" == "inactive" ]; then
			$ECHO -e "Starting ${_nas_smf_str_} service" | $TEE -a $LOGFILE
			${SYSTEMCTL} start ${_nas_smf_str_} 
			local _service_state=`$SYSTEMCTL show ${_nas_smf_str_} -p ActiveState | $AWK -F= '{print $2}'`
			if [ "${_service_state}" == "active" ] ; then
				$ECHO -e "${_nas_smf_str_} Started successfully"
			   break
			fi			
		else
			continue
		fi
		let _count_time=_count_time+1
	done
	
	local _service_state=`$SYSTEMCTL show ${_nas_smf_str_} -p ActiveState | $AWK -F= '{print $2}'`
	if [ "${_service_state}" != "active" ] ; then
		_err_msg_="Could not Start ${_nas_smf_str_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	local _service_state=`${SYSTEMCTL} is-enabled ${_nas_smf_str_} | $AWK '{print $1}'`
	if [ "${_service_state}" != "enabled" ] ; then
		  ${SYSTEMCTL} enable ${_nas_smf_str_}
	fi
		   
	# Give NAS 1 minute to go change stage
	$SLEEP 60

	# Check that NASD milestone is online
	check_nasd_milestone_online ${ENIQ_CONF_DIR} ${SUNOS_INI} ${ENIQ_BASE_DIR}
	if [ $? -ne 0 ]; then
		_err_msg_="NASd not in a correct state to continue"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

insert_header_footer foot "Successfully installed NASd" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: install_nas_sw ###
#
# Set up the stage to be run
#
# Arguments:
#   none
# Return Values:
#   none
install_nas_sw()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" == "fs" ]; then
	insert_header_footer foot "FS Install - Skipping core install stage - ${NEXT_STAGE} " ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

if [ -s ${ENIQ_CONF_DIR}/${SUNOS_INI} ]; then
	_ini_src_dir_=${ENIQ_CONF_DIR}
	_ini_file_=${SUNOS_INI}
else
	_ini_src_dir_=${ENIQ_TEMPL_DIR}
	_ini_file_="${SUNOS_INI}_${SAN_DEVICE}"
fi

# Set the OM dir value
if [ "${UPGRADE}" -a "${OM_SW_DIR}" ]; then
	SW_DIR=${OM_SW_DIR}
else
	if [ -d ${DEF_CACHE_DIR}/storage ]; then
		SW_DIR=${DEF_CACHE_DIR}
	else
		if [ "${OM_SW_PATH_FILE}" ]; then
			insert_media -l om_linux -f ".om_linux" -s ${OM_SW_PATH_FILE} -n 5 "Operation and Maintenance DVD"
		else
			insert_media -l om_linux -f ".om_linux" -n 5 "Operation and Maintenance DVD"
		fi
	fi
fi

if [ ! "$SW_DIR" ]; then
	_err_msg_="Failed to locate cached O&M Media!"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Install the NAS API
core_install_nas_api ${LOGFILE} ${TEM_DIR} "${_ini_src_dir_}/${_ini_file_}" ${SW_DIR}
if [ $? -ne 0 ]; then
	_err_msg_="Could not install NAS API packages"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

insert_header_footer foot "Successfully installed NAS API" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: install_new_ecs ###
#
# Install ECs to controlzone, but skip EC_1 as
# thats done on the CO. Also update the service_names
# file with the new EC aliases
#
# Arguments:
#   none
# Return Values:
#   none
install_new_ecs()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

if [ "${CURR_SERVER_TYPE}" != "eniq_mz" -a "${CURR_SERVER_TYPE}" != "eniq_es" ]; then
	insert_header_footer foot "Non MZ server install - Skipping core install stage - ${NEXT_STAGE} " ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

if [ ! -s ${ENIQ_BASE_DIR}/mediation_inter/MULTI_EC/bin/manageec.sh ]; then
	_err_msg_="${ENIQ_BASE_DIR}/mediation_inter/MULTI_EC/bin/manageec.sh not found"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

local ec_mem_script="${ENIQ_BASE_DIR}/mediation_inter/bin/ec_mem.pl"
if [ ! -s ${ec_mem_script} ]; then
	_err_msg_="${ec_mem_script} not found"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Get the System User
_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$ECHO "Setting up system for MZ" | $TEE -a ${LOGFILE}
$ECHO "The following command will be used to update the system:" >> ${LOGFILE}
$ECHO "$SU - ${_sysuser_} -c \"${ENIQ_BASE_DIR}/mediation_inter/MULTI_EC/bin/manageec.sh -a mzready\"" >> ${LOGFILE}
$SU - ${_sysuser_} -c "${ENIQ_BASE_DIR}/mediation_inter/MULTI_EC/bin/manageec.sh -a mzready"
if [ $? -ne 0 ]; then
	_err_msg_="Could not update the system for MZ"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Get the current EC number
_ec_name_=`$CAT ${CLI_CONF_DIR}/service_names | $EGREP "${HOST_IP}" | $EGREP "ec_[0-9]+" | $AWK -F"::" '{print $3}'`
if [ ! "${_ec_name_}" ]; then
	_err_msg_="Could not determine which EC is to be run on this server"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ "${_ec_name_}" == "ec_1" ]; then
	log_msg -s "Starting to run ${ec_mem_script}" -l $LOGFILE
	log_msg -s "$SU - ${_sysuser_} -c \"${PERL} ${ec_mem_script}\"" -l $LOGFILE
	$SU - ${_sysuser_} -c "${PERL} ${ec_mem_script}" 2 >&1 >> ${LOGFILE}
	if [ $? -ne 0 ]; then
		log_msg -s "Could not update the memory settings while running ${ec_mem_script}" -l $LOGFILE
	fi
	$ECHO "Skipping EC addition as this server is running ${_ec_name_}" | $TEE -a ${LOGFILE}
	_msg_str_="Successfully completed ${NEXT_STAGE} stage"
else
	if [ ! -s ${ENIQ_BASE_DIR}/mediation_inter/bin/addec.sh ]; then
		_err_msg_="${ENIQ_BASE_DIR}/mediation_inter/bin/addec.sh not found"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	$ECHO "Adding ${_ec_name_} to system" | $TEE -a ${LOGFILE}
	$ECHO "The following command will be used to add ${_ec_name_} to the system:" >> ${LOGFILE}
	$ECHO "$SU - ${_sysuser_} -c \"${ENIQ_BASE_DIR}/mediation_inter/bin/addec.sh\"" >> ${LOGFILE}
	$SU - ${_sysuser_} -c "${ENIQ_BASE_DIR}/mediation_inter/bin/addec.sh"
	if [ $? -ne 0 ]; then
		_err_msg_="Could not add ${_ec_name_} to system"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	_msg_str_="Successfully added ${_ec_name_} to system"
fi

insert_header_footer foot "${_msg_str_}" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: install_es_mediationzone ###
#
# Install Mediation Zone on ENIQ Event Statistics Coordinator
#
# Arguments:
#   none
# Return Values:
#   none
install_es_mediation()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

if [ "${INSTALL_TYPE}" == "stats" -o "${SERVER_TYPE}" != "CO" ] ; then
	insert_header_footer foot "Non Co-ordinator install - Skipping core install stage - ${NEXT_STAGE} " ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

get_sw_dir

local _block_="ES_MEDIATION"
local _param_="ESMEDIATION_SOURCE_DIR"
$ECHO "Gathering ES MediationZone information from ${ENIQ_CONF_DIR}/${SUNOS_INI}" >> ${LOGFILE}
local _mz_pkg_dir_=`iniget ${_block_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ${_param_}`
if [ ! "${_mz_pkg_dir_}" ]; then
	local _err_msg_="Could not read ${_block_}:${_param_} param from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

local _param_="ESMEDIATION_CMD"
local _inst_cmd_=`iniget ${_block_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ${_param_}`
if [ ! "${_inst_cmd_}" ]; then
	local _err_msg_="Could not read ${_block_}:${_param_} param from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Set an upgrade flag if required
local _inst_flag_="-i"
local _inst_type_="Install"
if [ "${UPGRADE}" ]; then
	local _inst_flag_="-u"
	local _inst_type_="Upgrade"
fi

local _extract_path_=$TEM_DIR/esmz
local _inst_cmd_=`eval $ECHO "${_inst_cmd_}" | $SED -e "s|@_inst_type_@|$_inst_flag_|g;s|@_extract_dir_@|$_extract_path_|g"`
local _esmz_pkg_loc_="$SW_DIR/${_mz_pkg_dir_}"
local _esmz_pkg_file_=`$LS -1 ${_esmz_pkg_loc_}/*.zip`
if [ $? -ne 0 ] ; then
	local _err_msg_="Could not locate a file with the extension .zip in ${_esmz_pkg_loc_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

local _esmz_pkg_file_=`$BASENAME ${_esmz_pkg_file_}`
local _esmz_pkg_path_=${_esmz_pkg_loc_}/${_esmz_pkg_file_}

$RM -rf ${_extract_path_} > /dev/null 2>&1
$UNZIP ${_esmz_pkg_path_} -d ${_extract_path_} >> ${LOGFILE} 2>&1
if [ $? -ne 0 ] ; then
	local _err_msg_="Could not extract ${_esmz_pkg_path_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file\n${ENIQ_CONF_DIR}/${ENIQ_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# dcuser will be logging into ${_extract_path_}
$CHOWN -R ${_sysuser_} ${_extract_path_}
$ECHO "Starting ES MZ ${_inst_type_}" | $TEE -a ${LOGFILE}
$ECHO "ES MedtionZone ${_inst_type_} command: $SU - ${_sysuser_} -c \"${_inst_cmd_}\"" >> ${LOGFILE}
$SU - ${_sysuser_} -c "${_inst_cmd_}" 2>&1 | $TEE -a ${LOGFILE}
local _rc_=${PIPESTATUS[0]}
if [ $_rc_ -ne 0 ] ; then
	local _err_msg_="Failed to ${_inst_type_} ES MeditionZone"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

local _conf_msg_="Successfully completed ES MediationZone ${_inst_type_}"
insert_header_footer foot "${_conf_msg_}" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: backup_geoserver_war_file ###
#
# Back up geoserver.war file
#
# Arguments:
#	   none
#
# Return Values:
#   none
backup_geoserver_war_file() {

# Back up from this directory:
_gfish_autodp_=${ENIQ_BASE_DIR}/glassfish/glassfishv3/glassfish/domains/domain1/autodeploy
# Back up to this directory:
_war_backup_directory_name=eniq-events-applications-backup
_events_apps_backup_directory=${ENIQ_BASE_DIR}/glassfish/glassfish3/glassfish/domains/domain1/$_war_backup_directory_name

# Back up the geoserver.war file:
if [ -f ${_gfish_autodp_}/geoserver.war ]; then
		log_msg -s "Backing up existing geoserver.war file to ${_events_apps_backup_directory}" -l $LOGFILE -t

		# Check that the eniq-events-applications-backup directory exists:
		if [ ! -d ${_events_apps_backup_directory} ]; then
				log_msg -s "Backup directory does not exist, creating ${_events_apps_backup_directory}..." -l $LOGFILE -t
				$MKDIR -p ${_events_apps_backup_directory}
				if [ $? -eq 0 ]; then
						log_msg -s "Created back up directory: ${_events_apps_backup_directory}" -l $LOGFILE -t
				else
						_err_msg_="Failed to create backup directory: ${_events_apps_backup_directory}"
						log_msg -s "${_err_msg_}" -l $LOGFILE -t
						abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				fi
		fi
		log_msg -q -s "Changing ownership of ${_events_apps_backup_directory} to ${_sysuser_}:${_sysgrp_}." -l $LOGFILE -t
		$CHOWN ${_sysuser_}:${_sysgrp_} ${_events_apps_backup_directory} >> /dev/null 2>&1
		if [ $? -ne 0 ]; then
			log_msg -s "Warning: Failed to change ownership of ${_events_apps_backup_directory} to ${_sysuser_}:${_sysgrp_}." -l $LOGFILE -t
		fi

		# Copy geoserver.war to eniq-events-applications-backup directory:
		$CP ${_gfish_autodp_}/geoserver.war ${_events_apps_backup_directory}/geoserver.war
		if [ $? -eq 0 ]; then
				log_msg -s "Backed up geoserver.war to ${_events_apps_backup_directory}/geoserver.war" -l $LOGFILE -t
		else
				_err_msg_="Failed to back up geoserver.war to ${_events_apps_backup_directory}/geoserver.war"
				log_msg -s "${_err_msg_}" -l $LOGFILE -t
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		# Remove geoserver directory in glassfish before upgrading.
		# This will be recreated by the when the geoserver.war file redeploys after upgrade:
		if [ -d ${ENIQ_BASE_DIR}/glassfish/glassfishv3/glassfish/domains/domain1/applications/geoserver ]; then
				log_msg -s "Removing existing geoserver directory" -l $LOGFILE -t
				$RM -rf ${ENIQ_BASE_DIR}/glassfish/glassfishv3/glassfish/domains/domain1/applications/geoserver
				if [ $? -ne 0 ]; then
						_err_msg_="Failed to remove ${ENIQ_BASE_DIR}/glassfish/glassfishv3/glassfish/domains/domain1/applications/geoserver"
						log_msg -s "${_err_msg_}" -l $LOGFILE -t
						abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				fi
		else
				log_msg -s "Directory ${ENIQ_BASE_DIR}/glassfish/glassfishv3/glassfish/domains/domain1/applications/geoserver does not exist, skipping delete" -l $LOGFILE -t
		fi
else
		log_msg -s "geoserver.war file does not exist in ${_gfish_autodp_}, skipping backup" -l $LOGFILE -t
fi
}

### Function: install_assuremonitoring ###
#
# Installation of assuremonitoring package.
#
# Arguments:
#   none
# Return Values:
#   none
install_assuremonitoring()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

if [ "${INSTALL_TYPE}" != "events" ] && [ "${INSTALL_TYPE}" != "stats" ]; then
	insert_header_footer foot "Non Events/Stats Install - Skipping core install stage - ${NEXT_STAGE} " ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
else
   # Get the SW_DIR variable
   get_sw_dir

   local _ini_src_dir_=${ENIQ_CONF_DIR}
   local _ini_file_=${SUNOS_INI}

   if [ "${UPGRADE}" ]; then
	  _ini_src_dir_=${ENIQ_TEMPL_DIR}
	  _ini_file_=${SUNOS_INI}_${SAN_DEVICE}
	  $ECHO "Upgrading assuremonitoring package on ${CURR_SERVER_TYPE}." >> ${LOGFILE}
   else
	  $ECHO "Installing the assuremonitoring package on ${CURR_SERVER_TYPE}." >> ${LOGFILE}
   fi

   local _sunos_ini_file_=${_ini_src_dir_}/${_ini_file_}

   local _assuremonitoring_source_dir_=`iniget ASSUREMONITORING -f ${_sunos_ini_file_} -v ASSUREMONITORING_SOURCE_DIR`
   if [ ! "${_assuremonitoring_source_dir_}" ]; then
	  local _err_msg_="Unable to find the source directory location for assuremonitoring package from ${_sunos_ini_file_}."
	  abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
   fi

   local _assuremonitoring_sw_dir_=${SW_DIR}/${_assuremonitoring_source_dir_}

   local _assuremonitoring_install_script_=`iniget ASSUREMONITORING -f ${_sunos_ini_file_} -v ASSUREMONITORING_INSTALL_SCRIPT`
   if [ ! "${_assuremonitoring_install_script_}" ]; then
	  local _err_msg_="Unable to find the script name for assuremonitoring package installation from ${_sunos_ini_file_}."
	  abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
   fi

   local _install_script_=${_assuremonitoring_sw_dir_}/${_assuremonitoring_install_script_}

   if [ -f "${_install_script_}" ]; then
	  $ECHO "Executing the command ${_install_script_} -d ${_assuremonitoring_sw_dir_} -l ${LOGFILE}"  >> ${LOGFILE}
	  $BASH ${_install_script_} -d ${_assuremonitoring_sw_dir_} -l ${LOGFILE}
	  if [ $? -ne 0 ]; then
		 local _err_msg_="Failed to successfully execute the script ${_install_script_}."
		 abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	  fi
   else
	  local _err_msg_="Unable to find the script ${_install_script_}."
	  abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
   fi
fi

insert_header_footer foot "Successfully executed the stage ${NEXT_STAGE}." ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: install_opengeo ###
#
#	Installs Opengeo sw
#
#	Arguments:
#	   none
#	 Return Values:
#	   none
install_opengeo()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

if [ "${CURR_SERVER_TYPE}" == "eniq_ui" -o "${CURR_SERVER_TYPE}" == "eniq_events" -o "${CURR_SERVER_TYPE}" == "son_coordinator" ]; then
	_arch_=`$UNAME -p`
	_set_upgrade_=YES

	$ECHO "Gathering Opengeo information from ${ENIQ_CONF_DIR}/${SUNOS_INI}" >> ${LOGFILE}
	_src_dir_=`iniget OPENGEO -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v OPENGEO_SOURCE_DIR`
	if [ ! "${_src_dir_}" ]; then
		_err_msg_="Could not read OPENGEO_SOURCE_DIR param from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	_sw_bndl_=`iniget OPENGEO -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v OPENGEO_SW_BUNDLE`
	if [ ! "${_sw_bndl_}" ]; then
		_err_msg_="Could not read OPENGEO_SW_BUNDLE param from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	_inst_script_=`iniget OPENGEO -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v OPENGEO_INST_SCRIPT`
	if [ ! "${_inst_script_}" ]; then
		_err_msg_="Could not read OPENGEO_INST_SCRIPT param from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	_tgt_dir_=`iniget OPENGEO -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v OPENGEO_TARGET_DIR`
	if [ ! "${_tgt_dir_}" ]; then
		_err_msg_="Could not read OPENGEO_TARGET_DIR param from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	_tgt_data_dir_=`iniget OPENGEO -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v OPENGEO_TARGET_DATA_DIR`
	if [ ! "${_tgt_data_dir_}" ]; then
		_err_msg_="Could not read OPENGEO_TARGET_DATA_DIR param from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	if [ "${_tgt_data_dir_}" == "/" -o "${_tgt_dir_}" == "/" ]; then
		_err_msg_="Invalid opengeo target directories read from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	_smf_uri_=`iniget OPENGEO -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v POSTGRES_SERVICE_STR`
	if [ ! "${_smf_uri_}" ]; then
		_err_msg_="Could not read POSTGRES_SERVICE_STR param from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	# Get the System User/Group. All directories are owned by this
	_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
	if [ ! "${_sysuser_}" ]; then
		_err_msg_="Could not read parameter ENIQ_SYSUSER from file\n${ENIQ_CONF_DIR}/${SUNOS_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	_sysgrp_=`$ID ${_sysuser_}|$AWK '{print $2}'|$AWK -F\( '{print $2}'|$AWK -F\) '{print $1}'`
	if [ ! "${_sysuser_}" ]; then
		_err_msg_="Could not determine group ID of ${_sysuser_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	get_sw_dir

	_opengeo_sw_bundle_="$SW_DIR/${_src_dir_}/${INSTALL_TYPE}/sw/${_arch_}/${_sw_bndl_}"
	if [ ! -s ${_opengeo_sw_bundle_} ]; then
		_err_msg_="OPENGEO SW bundle could not be found in $SW_DIR/${_src_dir_}/${INSTALL_TYPE}/sw/${_arch_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	# for the upgrade scenario:
	# check for AUTO in UPGRADE_TYPE in cxp_info, then if not AUTO check the SCHEMA=YYYY-MM-DD
	if [ "${UPGRADE}" ] ; then
		if [ -f $SW_DIR/${_src_dir_}/${INSTALL_TYPE}/sw/${_arch_}/cxp_info ]; then
			if [ "`$AWK -F= '/^UPGRADE_TYPE/{ print $2 }' $SW_DIR/${_src_dir_}/${INSTALL_TYPE}/sw/${_arch_}/cxp_info`" != "auto" ]; then
				# compare SCHEMA fields for manual upgrades, if they are different a manual upgrade is needed
				if [ -f ${_tgt_dir_}/cxp_info ]; then
					if [ "`$AWK -F= '/^SCHEMA/{ print $2 }' ${_tgt_dir_}/cxp_info`" != "`$AWK -F= '/^SCHEMA/{ print $2 }' $SW_DIR/${_src_dir_}/${INSTALL_TYPE}/sw/${_arch_}/cxp_info`" ] ; then
						_set_upgrade_=NO
					fi
				else
					_err_msg_="Can't find information on ${_tgt_dir_}/cxp_info"
					abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				fi
			fi
		else
			_err_msg_="Can't find information on $SW_DIR/${_src_dir_}/${INSTALL_TYPE}/sw/${_arch_}/cxp_info"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi

	if [ "${_set_upgrade_}" == "YES" ] ; then
		$ECHO "\nInstalling Opengeo SW" | $TEE -a ${LOGFILE}

		# Back up the geoserver.war file:
		backup_geoserver_war_file

		$ECHO "Using Opengeo source from ${_opengeo_sw_bundle_}" >> ${LOGFILE}
		cd ${TEM_DIR}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not change directory to ${TEM_DIR}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		$ECHO "Extracting opengeo SW bundle - ${_opengeo_sw_bundle_}" >> ${LOGFILE}
		$GTAR -zxf ${_opengeo_sw_bundle_}
		if [ $? -ne 0 ]; then
			_err_msg_="Failed to unpack ${_sw_bndl_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		# in case re-install is run - service has to be stopped
		$SVCS -a | $GREP "${_smf_uri_}" > /dev/null
		if [ $? -eq 0 ]; then
			if [ "`$SVCS -H -o sta ${_smf_uri_}`" != "DIS" ]; then
				$ECHO "Found ${_smf_uri_} in state `$SVCS -H -o sta ${_smf_uri_}`, disabling it ..." | $TEE -a $LOGFILE
				$SVCADM disable ${_smf_uri_}
				$SLEEP 7
			fi
		fi

		if [ -f ${_inst_script_} ]; then
			$ECHO "Running the following command to install opengeo" >> ${LOGFILE}
			$ECHO "/bin/bash ${_inst_script_} -I ${_tgt_dir_} -D ${_tgt_data_dir_} -C APP" >> ${LOGFILE}
			/bin/bash ${_inst_script_} -I ${_tgt_dir_} -D ${_tgt_data_dir_} -C APP
			if [ $? -ne 0 ]; then
				_err_msg_="Failed to install Opengeo binaries"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		else
			_err_msg_="${_inst_script_} not found, can't install Opengeo binaries"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		_inst_webapp_=install-opengeo-webapps.sh
		_gfish_autodp_=/eniq/glassfish/glassfishv3/glassfish/domains/domain1/autodeploy
		_webapp_log_=/eniq/log/sw_log/glassfish
		_geo_data_dir_=${_tgt_data_dir_}/geoserver_data_dir

		if [ ! -d ${_geo_data_dir_} ]; then
			$ECHO "Creating ${_geo_data_dir_} directory" >> ${LOGFILE}
			$MKDIR -p ${_geo_data_dir_}
			if [ $? -ne 0 ]; then
				_err_msg_="Failed to create ${_geo_data_dir_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
			$ECHO "Changing ownership of ${_geo_data_dir_} directory to ${_sysuser_}:${_sysgrp_}" >> ${LOGFILE}
			$CHOWN -R ${_sysuser_}:${_sysgrp_} ${_geo_data_dir_}
		fi

		if [ -f ${_inst_webapp_} ]; then
			$ECHO "Installing Opengeo Web Apps" | $TEE -a $LOGFILE
			$ECHO "using command:" >> $LOGFILE
			$ECHO "/bin/bash ${_inst_webapp_} -S resources/opengeo-webapps.tar.gz -T ${_gfish_autodp_} -M /tmp/ogeo_suite -G ${_geo_data_dir_} -L ${_webapp_log_} -U ${_sysuser_} -O ${_sysgrp_} -V APP" >> $LOGFILE
			/bin/bash ${_inst_webapp_} -S resources/opengeo-webapps.tar.gz -T ${_gfish_autodp_} -M /tmp/ogeo_suite -G ${_geo_data_dir_} -L ${_webapp_log_} -U ${_sysuser_} -O ${_sysgrp_} -V APP
			if [ $? -ne 0 ]; then
				_err_msg_="Failed to install Opengeo Web Apps"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
			$ECHO "Changing ownership of ${_gfish_autodp_}/geoserver.war to ${_sysuser_}:${_sysgrp_}" >> ${LOGFILE}
			$CHOWN ${_sysuser_}:${_sysgrp_} ${_gfish_autodp_}/geoserver.war
		else
			_err_msg_="${_inst_webapp_} not found, can't install Opengeo Web Applications"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		cd $SCRIPTHOME
		# cp cxp_info file for reference
		if [ -f $SW_DIR/${_src_dir_}/${INSTALL_TYPE}/sw/${_arch_}/cxp_info ]; then
			$ECHO "Copying $SW_DIR/${_src_dir_}/${INSTALL_TYPE}/sw/${_arch_}/cxp_info to ${_tgt_dir_}" >> $LOGFILE
			$CP $SW_DIR/${_src_dir_}/${INSTALL_TYPE}/sw/${_arch_}/cxp_info ${_tgt_dir_}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not copy $SW_DIR/${_src_dir_}/${INSTALL_TYPE}/sw/${_arch_}/cxp_info to ${_tgt_dir_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		fi
		insert_header_footer foot "Successfully installed OPENGEO binaries and WebApps" ${LOGFILE}
	else
		if [ ${_set_upgrade_} == "NO" ]; then
			insert_header_footer foot "No automatic upgrade for opengeo - run opengeo manual upgrade chapter" ${LOGFILE}
		fi
	fi
else
	insert_header_footer foot "${CURR_SERVER_TYPE} server install - skipping this stage" ${LOGFILE}
fi

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: install_patches ###
#
# Patch the System
#
# Arguments:
#   none
# Return Values:
#   none
install_patches()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Skip to next stage if OS version is not 5.10
if [ ! "${SOLARIS_10}" ]; then
	log_msg -s "Solaris Patching is not applicable in OS version ${OS_VERSION}." -l ${LOGFILE}
	insert_header_footer foot "Skipping core install stage - ${NEXT_STAGE}" ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	if [ ${REBOOT_FLAG} -eq 1 ];then
		log_msg -s "Rebooting the server for necessary configuration changes." -l ${LOGFILE}
		$REBOOT
	fi
	return 0
fi

if [ -s ${ENIQ_CONF_DIR}/extra_params/no_sol_patches ]; then
	insert_header_footer foot "Skipping Solaris Patching Stage" ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	$REBOOT
fi

$ECHO "\n-------------------------------------------------------" >> ${PATCH_LOG}
$ECHO "${RUN_TIME} - Beginning to patch Solaris" >> ${PATCH_LOG}
$ECHO "-------------------------------------------------------\n" >> ${PATCH_LOG}

# Set the OM dir value
if [ "${UPGRADE}" -a "${OM_SW_DIR}" ]; then
	SW_DIR=${OM_SW_DIR}
else
	if [ -s ${DEF_CACHE_DIR}/Patches/SUN_INST_PATCH.sh ]; then
		SW_DIR=${DEF_CACHE_DIR}
	else
		if [ "${OM_SW_PATH_FILE}" ]; then
			insert_media -l om -f ".om" -s ${OM_SW_PATH_FILE} -n 5 "Operation and Maintenance DVD"
		else
			insert_media -l om -f ".om" -n 5 "Operation and Maintenance DVD"
		fi
	fi
fi

if [ ! "$SW_DIR" ]; then
	_err_msg_="Failed to locate cached O&M Media!"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Set up a file to determine if I need a reboot or not
REBOOT_FILE=${TEM_DIR}/patch_reboot_file.$$.$$
$RM -f ${REBOOT_FILE}

# Install the patches
core_install_patches ${LOGFILE} ${TEM_DIR} ${SW_DIR} ${PATCH_LOG} ${REBOOT_FILE}

insert_header_footer foot "Successfully completed Solaris patching stage" ${LOGFILE}

if [ "$ZONE" != "yes" ]; then
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
else
	#Need to see what stage we should be moving on to KEN
	set_next_stage `$EXPR ${ARRAY_ELEM}+2`
fi

# Update the boot archive if required
if [ ! "$ZONE" ]; then
	check_update_boot_archive
fi

if [ -f ${REBOOT_FILE} -o ${REBOOT_FLAG} -eq 1 ]; then
	$ECHO "\n\nRebooting server after patch installation or system file updates." | $TEE -a ${LOGFILE}
	$REBOOT
fi
}

### Function: install_rolling_snapshot ###
#
# Create installation filesystem/rolling snapshots
#
# Arguments:
#   none
# Return Values:
#   none
install_rolling_snapshot()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

$RM -rf ${TEM_DIR}/cron.$$

# Read the storage type
read_storage_type

# Update the root crontab with rolling snapshot entry
if [ ! -s ${ENIQ_BASE_DIR}/bkup_sw/etc/${INSTALL_TYPE}_rolling_snap_crontab_template ]; then
	_err_msg_="${ENIQ_BASE_DIR}/bkup_sw/etc/${INSTALL_TYPE}_rolling_snap_crontab_template not found, or is empty"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

log_msg -l ${LOGFILE} -q -s "Updating ${ENIQ_BASE_DIR}/bkup_sw/etc/${INSTALL_TYPE}_rolling_snap_crontab_template"
$CAT ${ENIQ_BASE_DIR}/bkup_sw/etc/${INSTALL_TYPE}_rolling_snap_crontab_template | $SED -e "s|<CHANGE><ENIQ_BASE_DIR>|${ENIQ_BASE_DIR}|g" >> ${TEM_DIR}/cron.$$
if [ "${CURR_SERVER_TYPE}" == "son_coordinator" ]; then
	$CP ${TEM_DIR}/cron.$$ ${TEM_DIR}/cron_update.$$.$$
	if [ $? -ne -0 ]; then
		_err_msg_="Could not copy ${TEM_DIR}/cron.$$ to ${TEM_DIR}/cron_update.$$.$$"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	log_msg -l ${LOGFILE} -q -s "Updating templated crontab for SON"
	$CAT ${TEM_DIR}/cron_update.$$.$$ | $EGREP -v "mg_ecs_batch_cleanup" > ${TEM_DIR}/cron.$$
	if [ $? -ne -0 ]; then
		_err_msg_="Could not update templated crontab file"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

if [ "${STORAGE_TYPE}" == "fs" ]; then
	$CP ${TEM_DIR}/cron.$$ ${TEM_DIR}/cron_update.$$.$$
	if [ $? -ne -0 ]; then
		_err_msg_="Could not copy ${TEM_DIR}/cron.$$ to ${TEM_DIR}/cron_update.$$.$$"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	log_msg -l ${LOGFILE} -q -s "Updating templated crontab for ${STORAGE_TYPE} Install"
	$CAT ${TEM_DIR}/cron_update.$$.$$ | $EGREP -v "manageSanDataCollection.bsh" > ${TEM_DIR}/cron.$$
	if [ $? -ne -0 ]; then
		_err_msg_="Could not update templated crontab file"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

# Update crontab using function in common_functions.lib
log_msg -l ${LOGFILE} -s "Updating crontab..."
insert_roll_snap_crontab ${TEM_DIR}/cron.$$ ${LOGFILE}
log_msg -l ${LOGFILE} -s  "Crontab updated successfully"

insert_header_footer foot "Successfully created rolling snapshots" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: install_san_sw ###
#
# Install EMC SW
#
# Arguments:
#   none
# Return Values:
#   none
install_san_sw()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" == "fs" ]; then
	insert_header_footer foot "FS install - Skipping San Software Installation" ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

if [ -s ${ENIQ_CONF_DIR}/${SUNOS_INI} ]; then
	_ini_src_dir_=${ENIQ_CONF_DIR}
	_ini_file_=${SUNOS_INI}
else
	_ini_src_dir_=${ENIQ_TEMPL_DIR}
	_ini_file_="${SUNOS_INI}_${SAN_DEVICE}"
fi

_san_sw_source_dir_=`iniget SAN_SW -f ${_ini_src_dir_}/${_ini_file_} -v SAN_SW_SOURCE_DIR`
if [ ! "${_san_sw_source_dir_}" ]; then
	_err_msg_="Could not read SAN_SW_SOURCE_DIR param from ${_ini_src_dir_}/${_ini_file_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_san_sw_inst_prog_=`iniget SAN_SW -f ${_ini_src_dir_}/${_ini_file_} -v SAN_SW_INST_PROG`
if [ ! "${_san_sw_inst_prog_}" ]; then
	_err_msg_="Could not read SAN_SW_INST_PROG param from ${_ini_src_dir_}/${_ini_file_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_san_sw_pkgs_to_inst_=`iniget SAN_SW -f ${_ini_src_dir_}/${_ini_file_} -v SAN_SW_PKGS_TO_INST`
if [ ! "${_san_sw_pkgs_to_inst_}" ]; then
	_err_msg_="Could not read SAN_SW_PKGS_TO_INST param from ${_ini_src_dir_}/${_ini_file_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_san_sw_pkgs_to_inst_=`$ECHO ${_san_sw_pkgs_to_inst_} \
					   | $SED -e 's| |,|g' -e 's|\,[\,]*|\,|g' -e 's|[\,]*$||g'`

# Set the OM dir value
if [ "${UPGRADE}" -a "${OM_SW_DIR}" ]; then
	SW_DIR=${OM_SW_DIR}
else
	if [ -d ${DEF_CACHE_DIR}/${_san_sw_source_dir_}/${_san_sw_pkg_name_} ]; then
		SW_DIR=${DEF_CACHE_DIR}
	else
		if [ "${OM_SW_PATH_FILE}" ]; then
			insert_media -l ${OM_DIR} -f "${OM_FILE}" -s ${OM_SW_PATH_FILE} -n 5 "Operation and Maintenance DVD"
		else
			insert_media -l ${OM_DIR} -f "${OM_FILE}" -n 5 "Operation and Maintenance DVD"
		fi
	fi
fi

if [ ! "$SW_DIR" ]; then
	_err_msg_="Failed to locate cached O&M Media!"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Set script location
_inst_script_=${SW_DIR}/${_san_sw_source_dir_}/${_san_sw_inst_prog_}
if [ ! -s ${_inst_script_} ]; then
	_err_msg_="Failed to locate SAN SW install script \n${_inst_script_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Run the add SAN SW script
/usr/bin/bash ${_inst_script_} -l ${_san_sw_pkgs_to_inst_} >> ${LOGFILE}
if [ $? -ne 0 ]; then
	abort_script "Exiting...." "${EXEC_SHELL_CMD}"
fi

insert_header_footer foot "Successfully installed SAN SW" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: install_sentinel ###
#
# Installs sentinel Server
#
# Arguments:
#   none
# Return Values:
#   none
install_sentinel()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

if [ ! -d ${ENIQ_CONF_DIR} ]; then
	$MKDIR -p ${ENIQ_CONF_DIR}
	if [ $? -ne 0 ]; then
		_err_msg_="Failed to create ${ENIQ_CONF_DIR}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

if [ ! -s ${ENIQ_CONF_DIR}/ericsson_use_config ]; then
	_type_=`$CAT ${ENIQ_CONF_DIR}/eniq_install`
	$ECHO "config=${_type_}" > ${ENIQ_CONF_DIR}/ericsson_use_config
fi

if [ ! -s $SCRIPTHOME/manage_eniq_sentinel.bsh ]; then
	_err_msg_="Could not locate file $SCRIPTHOME/manage_eniq_sentinel.bsh"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Get the sw dir
get_sw_dir

# Copy and update the sentinel.ini file to /eniq/installation/config
update_sentinel_ini

# Set a management flag
_mgmt_flag_=""
_sentinel_install_=0

_enable_sentinel_=`$CAT $ENIQ_TEMPL_DIR/admin/etc/smf_contract_config | $EGREP $CURR_SERVER_TYPE | $EGREP "sentinel" | $AWK -F"::" '{print $4}'`
if [ "${_enable_sentinel_}" == "Y" ]; then
	_mgmt_flag_="${_mgmt_flag_} -S"
fi

# Message for successful sentinel installation
 _conf_msg_="Successfully installed ENIQ Sentinel server"

# Figure out if this is an initial installation or is this an upgrade
if [ "${CURR_SERVER_TYPE}" == "stats_coordinator" -o "${CURR_SERVER_TYPE}" == "eniq_stats" -o "${CURR_SERVER_TYPE}" == "eniq_iqr" ]; then
	if [ -f ${ENIQ_BASE_DIR}/sentinel/install.complete ]; then
		log_msg -s "Sentinel installation already complete" -l ${LOGFILE}
	else
		_sentinel_pid_=`$PS -eaf|$GREP lserv|$GREP -v grep|$AWK '{print $2}'`
		if [ ${_sentinel_pid_} ]; then
				$KILL ${_sentinel_pid_}
				if [ $? -eq 0 ]; then
					 log_msg -s "Sentinel shutdown successfully" -l ${LOGFILE}
				fi
		fi
		if [ -d ${ENIQ_BASE_DIR}/sentinel/ ]; then
			log_msg -s "\nENIQ sentinel installation was not completed before. Cleaning up..." -l ${LOGFILE}
			$RM -rf ${ENIQ_BASE_DIR}/sentinel >> /dev/null 2>&1
			$RM -f /etc/systemd/licensing-sentinel.service
				if [ -d /etc/systemd/licensing-sentinel.service ]; then
					log_msg -s "Unable to remove licensing-sentinel.service file" -l ${LOGFILE}
				fi
				if [ ! -d ${ENIQ_BASE_DIR}/sentinel/ ]; then
					log_msg -s "Cleanup complete" -l ${LOGFILE}
				fi
		fi
	fi
	if [ -s ${ENIQ_BASE_DIR}/sentinel/etc/sentinel.env ]; then
		$CAT ${ENIQ_BASE_DIR}/sentinel/etc/sentinel.env | $EGREP "=<CHANGE>" >> /dev/null 2>&1
		if [ $? -eq 0 ]; then
			_mgmt_flag_="-I ${_mgmt_flag_}" 
		else
			_mgmt_flag_="-U ${_mgmt_flag_}"
			_conf_msg_="Successfully updated ENIQ Sentinel server"
		fi
	else
		_mgmt_flag_="-I ${_mgmt_flag_}"
	fi
fi

$ECHO "\nStarting to install Sentinel LM with command" >> ${LOGFILE}
$ECHO "${BASH} $SCRIPTHOME/manage_eniq_sentinel.bsh -d $SW_DIR -f ${ENIQ_CONF_DIR}/${SENTINEL_INI} -l ${LOGFILE} ${_mgmt_flag_} -s ${SUNOS_INI}_${SAN_DEVICE} " >> ${LOGFILE}
${BASH} $SCRIPTHOME/manage_eniq_sentinel.bsh -d $SW_DIR -f ${ENIQ_CONF_DIR}/${SENTINEL_INI} -l ${LOGFILE} ${_mgmt_flag_} -s ${SUNOS_INI}_${SAN_DEVICE}
if [ $? -ne 0 ]; then
	_err_msg_="Failed to install ENIQ Sentinel server...exiting!"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
if [ "${_mgmt_flag_}" == "-I  -S" ]; then
	$TOUCH ${ENIQ_BASE_DIR}/sentinel/install.complete
	if [ $? -ne 0 ]; then
		_err_msg_="Failed to create ${ENIQ_BASE_DIR}/sentinel/install.complete file"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	INSTALL_SENTINEL_DATE=`$DATE '+%y%m%d_%H%M%S'`
	$ECHO ${INSTALL_SENTINEL_DATE} > ${ENIQ_BASE_DIR}/sentinel/install.complete
fi

insert_header_footer foot "${_conf_msg_}" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: install_service_scripts ###
#
# Installs scripts into /eniq/smf
#
# Arguments:
#   none
# Return Values:
#   none
install_service_scripts()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

local _dir_name_="smf"

if [ ! -d ${ENIQ_BASE_DIR}/${_dir_name_} ]; then
	$MKDIR ${ENIQ_BASE_DIR}/${_dir_name_}
	if [ $? -ne 0 ]; then
		_err_msg_="Failed to create ${ENIQ_BASE_DIR}/${_dir_name_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

$RM -rf ${TEM_DIR}/${_dir_name_}
$MKDIR -p ${TEM_DIR}/${_dir_name_}
$CP -rp ${ENIQ_COMMON_SW_DIR}/${_dir_name_}/* ${TEM_DIR}/${_dir_name_}
if [ $? -ne 0 ]; then
	_err_msg_="Could not copy ${ENIQ_COMMON_SW_DIR}/${_dir_name_}/* to ${TEM_DIR}/${_dir_name_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$ECHO -e "Updating values in files in ${ENIQ_COMMON_SW_DIR}/${_dir_name_}" | $TEE -a ${LOGFILE}
core_install_change_base_info ${LOGFILE} ${TEM_DIR} ${ENIQ_BASE_DIR} "${_dir_name_}"
if [ $? -ne 0 ]; then
	_err_msg_="Could not substitute values in ${ENIQ_COMMON_SW_DIR}/${_dir_name_} files"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

cd ${TEM_DIR}/${_dir_name_}
$ECHO -e "Copying ${_dir_name_} scripts from ${TEM_DIR}/${_dir_name_} to ${ENIQ_BASE_DIR}/${_dir_name_}\n" | $TEE -a ${LOGFILE}
$FIND . -depth -print | $CPIO -pdmu ${ENIQ_BASE_DIR}/${_dir_name_}
if [ $? -ne 0 ]; then
	_err_msg_="Failed to copy contents of ${TEM_DIR}/${_dir_name_} to ${ENIQ_BASE_DIR}/${_dir_name_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
cd /

insert_header_footer foot "Successfully installed SW to /eniq/${_dir_name_}" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: install_storage_api ###
#
# Install Storage API
#
# Arguments:
#   none
# Return Values:
#   none
install_storage_api()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" == "fs" ]; then
	insert_header_footer foot "FS Install - Skipping core install stage - ${NEXT_STAGE} " ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

if [ -s ${ENIQ_CONF_DIR}/${SUNOS_INI} ]; then
	_ini_src_dir_=${ENIQ_CONF_DIR}
	_ini_file_=${SUNOS_INI}
else
	_ini_src_dir_=${ENIQ_TEMPL_DIR}
	_ini_file_="${SUNOS_INI}_${SAN_DEVICE}"
fi

_stor_api_source_dir_=`iniget STOR_API -f ${_ini_src_dir_}/${_ini_file_} -v STOR_API_SOURCE_DIR`
if [ ! "${_stor_api_source_dir_}" ]; then
	_err_msg_="Could not read STOR_API_SOURCE_DIR param from ${_ini_src_dir_}/${_ini_file_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_stor_api_pkg_=`iniget STOR_API -f ${_ini_src_dir_}/${_ini_file_} -v STOR_API_PKG`
if [ ! "${_stor_api_pkg_}" ]; then
	_err_msg_="Could not read STOR_API_PKG param from ${_ini_src_dir_}/${_ini_file_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Set the OM dir value
if [ "${UPGRADE}" -a "${OM_SW_DIR}" ]; then
	SW_DIR=${OM_SW_DIR}
else
	if [ -d ${DEF_CACHE_DIR}/${_stor_api_source_dir_}/${_stor_api_pkg_} ]; then
		SW_DIR=${DEF_CACHE_DIR}
	else
		if [ "${OM_SW_PATH_FILE}" ]; then
			insert_media -l ${OM_DIR} -f "${OM_FILE}" -s ${OM_SW_PATH_FILE} -n 5 "Operation and Maintenance DVD"
		else
			insert_media -l ${OM_DIR} -f "${OM_FILE}" -n 5 "Operation and Maintenance DVD"
		fi
	fi
fi

if [ ! "$SW_DIR" ]; then
	_err_msg_="Failed to locate cached O&M Media!"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Set pkg name
_stor_api_pkg_name_=`$LS -t ${SW_DIR}/${_stor_api_source_dir_} | $GREP ${_stor_api_pkg_} | $HEAD -1`
if [ ! -s ${SW_DIR}/${_stor_api_source_dir_}/${_stor_api_pkg_name_} ]; then
	_err_msg_="Failed to locate Storage API pkg \n${SW_DIR}/${_stor_api_source_dir_}/${_stor_api_pkg_name_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Is the package already installed? If so remove it
$RPM -qa | $GREP ${_stor_api_pkg_} 2>/dev/null
if [ $? -eq 0 ]; then
	log_msg -s "Removing current instance of ${_stor_api_pkg_}" | $TEE -a ${LOGFILE}
	$RPM -evh ${_stor_api_pkg_}
	if [ $? -ne 0 ]; then
		_err_msg_="Failed to remove ${_stor_api_pkg_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	_conf_msg_="Successfully updated Storage API SW"
else
	_conf_msg_="Successfully installed Storage API SW"
fi

log_msg -s "Adding ${_stor_api_pkg_}" | $TEE -a ${LOGFILE}
$RPM -ivh ${SW_DIR}/${_stor_api_source_dir_}/${_stor_api_pkg_name_} 2>/dev/null | $TEE -a ${_logfile_}
_pkg_install_status_=`$ECHO ${PIPESTATUS[0]}`
if [ ${_pkg_install_status_} -ne 0 ]; then
	_err_msg_="Failed to add ${_stor_api_pkg_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

insert_header_footer foot "${_conf_msg_}" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: install_sybase_asa ###
#
# Installs Sybase ASA
#
# Arguments:
#   none
# Return Values:
#   none
install_sybase_asa()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

# Set the SW_DIR variable
get_sw_dir

$ECHO "Gathering SybaseASA information from ${ENIQ_CONF_DIR}/${SUNOS_INI}" >> ${LOGFILE}
_src_dir_=`iniget SYBASE_ASA -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v SYBASE_ASA_SOURCE_DIR`
if [ ! "${_src_dir_=}" ]; then
	_err_msg_="Could not read SYBASE_ASA_SOURCE_DIR parameter from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sw_bndl_=`iniget SYBASE_ASA -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v SYBASE_ASA_SW_BUNDLE`
if [ ! "${_sw_bndl_}" ]; then
	_err_msg_="Could not read SYBASE_ASA_SW_BUNDLE parameter from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_tgt_dir_=`iniget SYBASE_ASA -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v SYBASE_ASA_TARGET_DIR`
if [ ! "${_tgt_dir_}" ]; then
	_err_msg_="Could not read SYBASE_ASA_TARGET_DIR parameter from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ "${_tgt_dir_}" == "/" ]; then
	_err_msg_="Invalid SYBASE_ASA_TARGET_DIR directory '${_tgt_dir_}' read from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_arch_=`$UNAME -p`
_sybase_asa_sw_bundle_="$SW_DIR/${_src_dir_}/${INSTALL_TYPE}/sw/${_arch_}/${_sw_bndl_}"

# Check that the bundle exists
if [ ! -s ${_sybase_asa_sw_bundle_} ]; then
	_sybase_asa_sw_bundle_="$SW_DIR/${_src_dir_}/common/sw/${_arch_}/${_sw_bndl_}"
	if [ ! -s ${_sybase_asa_sw_bundle_} ]; then
		_err_msg_="Sybase ASA SW bundle could not be found in $SW_DIR/${_src_dir_}/common/sw/${_arch_} or $SW_DIR/${_src_dir_}/${INSTALL_TYPE}/sw/${_arch_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

$ECHO "Using ASA binaries in ${_sybase_asa_sw_bundle_}" >> ${LOGFILE}

if [ "${STORAGE_TYPE}" == "raw" ]; then
	# Check mountpoints and mount if not there
	mount_req_dirs
	if [ $? -ne 0 ]; then
		_err_msg_="Could not mount required directories for $NEXT_STAGE"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi


cd ${_tgt_dir_}
if [ $? -ne 0 ]; then
	_err_msg_="Could not change directory to ${_tgt_dir_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$ECHO "\nRemoving old SW if required" | $TEE -a ${LOGFILE}
$RM -rf ${_tgt_dir_}/*

$ECHO "\nInstalling Sybase ASA SW" | $TEE -a ${LOGFILE}
$GTAR -zxf ${_sybase_asa_sw_bundle_}
if [ $? -ne 0 ]; then
	_err_msg_="Failed to unpack ${_sybase_asa_sw_bundle_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Okay I need to locate the files that I have to update path in
# I build this SW bundle in a different path than I installed it
if [ ! -s ${_tgt_dir_}/file_change_list.txt ]; then
   $RM -f ${TEM_DIR}/file_change_list.txt
   $ECHO "Determining files that need to be updated...Please Wait" | $TEE -a ${LOGFILE}
   $FIND ${_tgt_dir_} -type f -exec $EGREP -l "<CHANGE><ASA_SYB_DIR>" {} \; >> ${TEM_DIR}/file_change_list.txt
   $CP ${TEM_DIR}/file_change_list.txt ${_tgt_dir_}/file_change_list.txt
fi

# Okay Have I any files to change?
if [ -s ${_tgt_dir_}/file_change_list.txt ]; then
	for _file_ in `$CAT ${_tgt_dir_}/file_change_list.txt`; do
		$RM -f ${TEM_DIR}/file.$$.$$
		if [ -s ${_tgt_dir_}/${_file_} ]; then
			$ECHO "Updating ${_tgt_dir_}/${_file_}" | $TEE -a ${LOGFILE}
			$CAT ${_file_} |$SED -e "s|<CHANGE><ASA_SYB_DIR>|${_tgt_dir_}|g" >  ${TEM_DIR}/file.$$.$$
			if [ $? -ne 0 ]; then
				_err_msg_="Failed to update <CHANGE><ASA_SYB_DIR> in ${_tgt_dir_}/${_file_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			$CP ${TEM_DIR}/file.$$.$$ ${_file_}
			if [ $? -ne 0 ]; then
				_err_msg_="Failed to update file ${_tgt_dir_}/${_file_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		fi
	done
	$RM -f ${_tgt_dir_}/file_change_list.txt
fi

# Okay Have I any files to change?
if [ -s ${_tgt_dir_}/link_change_list.txt ]; then
	$RM -f ${TEM_DIR}/link_change_list.txt
	$CAT ${_tgt_dir_}/link_change_list.txt | $SED -e "s|<CHANGE><ASA_SYB_DIR>|${_tgt_dir_}|g" > ${TEM_DIR}/link_change_list.txt
	/bin/bash ${TEM_DIR}/link_change_list.txt
	if [ $? -ne 0 ]; then
		_err_msg_="Error running commands in ${TEM_DIR}/link_change_list.txt"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	$RM -f ${_tgt_dir_}/link_change_list.txt
fi

# Create the SYBASE IQ interfaces file
#create_asa_interf ${_tgt_dir_}

# Get the System User/Group. All directories are owned by this
_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file\n${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysgrp_=`$ID ${_sysuser_}|$AWK '{print $2}'|$AWK -F\( '{print $2}'|$AWK -F\) '{print $1}'`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not determine group ID of ${_sysuser_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$CHOWN -Rh ${_sysuser_}:${_sysgrp_} ${_tgt_dir_} >> /dev/null 2>&1
if [ $? -ne 0 ]; then
	_err_msg_="Could not change ownership of to ${_tgt_dir_} ${_sysuser_}:${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

insert_header_footer foot "Successfully installed SYBASE ASA" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: install_sybaseiq ###
#
# Installs Sybase IQ
#
# Arguments:
#   none
# Return Values:
#   none
install_sybaseiq()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

# Set the SW_DIR variable
get_sw_dir

log_msg -l ${LOGFILE} -q -s "Gathering SybaseIQ information from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
_src_dir_=`iniget SYBASE_IQ -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v SYBASE_IQ_SOURCE_DIR`
if [ ! "${_src_dir_=}" ]; then
	_err_msg_="Could not read SYBASE_IQ_SOURCE_DIR parameter from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sw_bndl_=`iniget SYBASE_IQ -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v SYBASE_IQ_SW_BUNDLE`
if [ ! "${_sw_bndl_}" ]; then
	_err_msg_="Could not read SYBASE_IQ_SW_BUNDLE parameter from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_tgt_dir_=`iniget SYBASE_IQ -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v SYBASE_IQ_TARGET_DIR`
if [ ! "${_tgt_dir_}" ]; then
	_err_msg_="Could not read SYBASE_IQ_TARGET_DIR parameter from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
if [ "${_tgt_dir_}" == "/" ]; then
	_err_msg_="Invalid SYBASE_IQ_TARGET_DIR directory '${_tgt_dir_}' read from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_arch_=`$UNAME -p`
_sybase_iq_sw_bundle_="$SW_DIR/${_src_dir_}/${INSTALL_TYPE}/sw/${_arch_}/${_sw_bndl_}"

# Check that the bundle exists
if [ ! -s ${_sybase_iq_sw_bundle_} ]; then
	_sybase_iq_sw_bundle_="$SW_DIR/${_src_dir_}/common/sw/${_arch_}/${_sw_bndl_}"
	if [ ! -s ${_sybase_iq_sw_bundle_} ]; then
		_err_msg_="Sybase IQ SW bundle could not be found in $SW_DIR/${_src_dir_}/common/sw/${_arch_} or $SW_DIR/${_src_dir_}/${INSTALL_TYPE}/sw/${_arch_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

log_msg -l ${LOGFILE} -q -s "Using IQ binaries in ${_sybase_iq_sw_bundle_}"

if [ "${STORAGE_TYPE}" == "raw" ]; then
	# Check mountpoints and mount if not there
	mount_req_dirs
	if [ $? -ne 0 ]; then
		_err_msg_="Could not mount required directories for $NEXT_STAGE"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

log_msg -s "\nRemoving old SW if required" -l ${LOGFILE}
$RM -rf ${_tgt_dir_}/*

cd ${_tgt_dir_}
if [ $? -ne 0 ]; then
	_err_msg_="Could not change directory to ${_tgt_dir_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

log_msg -s "\nInstalling Sybase IQ SW" -l ${LOGFILE}

$GTAR -zxf ${_sybase_iq_sw_bundle_}
if [ $? -ne 0 ]; then
	_err_msg_="Failed to unpack ${_sybase_iq_sw_bundle_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Okay I need to locate the files that I have to update path in
# I build this SW bundle in a different path than I installed it
if [ ! -s ${_tgt_dir_}/file_change_list.txt ]; then
   $RM -f ${TEM_DIR}/file_change_list.txt
   log_msg -s "Determining files that need to be updated...Please Wait" -l ${LOGFILE}
   $FIND ${_tgt_dir_} -type f -exec $EGREP -l "<CHANGE><IQ_SYB_DIR>" {} \; >> ${TEM_DIR}/file_change_list.txt
   $CP ${TEM_DIR}/file_change_list.txt ${_tgt_dir_}/file_change_list.txt
fi

# Okay Have I any files to change?
if [ -s ${_tgt_dir_}/file_change_list.txt ]; then
	for _file_ in `$CAT ${_tgt_dir_}/file_change_list.txt`; do
		$RM -f ${TEM_DIR}/file.$$.$$
		if [ -s ${_file_} ]; then
			log_msg -s "Updating ${_file_}" -l ${LOGFILE}
			$CAT ${_file_} |$SED -e "s|<CHANGE><IQ_SYB_DIR>|${_tgt_dir_}/|g" \
		|$SED -e 's/\/[\/]*/\//g' >  ${TEM_DIR}/file.$$.$$
			if [ $? -ne 0 ]; then
				_err_msg_="Failed to update <CHANGE><IQ_SYB_DIR> in ${_tgt_dir_}/${_file_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			$CP ${TEM_DIR}/file.$$.$$ ${_file_}
			if [ $? -ne 0 ]; then
				_err_msg_="Failed to update file ${_tgt_dir_}/${_file_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		fi
	done
	$RM -f ${_tgt_dir_}/file_change_list.txt
fi

# Okay Have I any files to change?
if [ -s ${_tgt_dir_}/link_change_list.txt ]; then
	$RM -f ${TEM_DIR}/link_change_list.txt
	$CAT ${_tgt_dir_}/link_change_list.txt | $SED -e "s|<CHANGE><IQ_SYB_DIR>|${_tgt_dir_}/|g" \
	|$SED -e 's/\/[\/]*/\//g' > ${TEM_DIR}/link_change_list.txt
	/bin/bash ${TEM_DIR}/link_change_list.txt
	if [ $? -ne 0 ]; then
		_err_msg_="Error running commands in ${TEM_DIR}/link_change_list.txt"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	$RM -f ${_tgt_dir_}/link_change_list.txt
fi

# Create the SYBASE IQ interfaces file
create_iq_interf ${_tgt_dir_}

# Get the System User/Group. All directories are owned by this
_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file\n${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysgrp_=`$ID ${_sysuser_}|$AWK '{print $2}'|$AWK -F\( '{print $2}'|$AWK -F\) '{print $1}'`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not determine group ID of ${_sysuser_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$CHOWN -Rh ${_sysuser_}:${_sysgrp_} ${_tgt_dir_} >> /dev/null 2>&1
if [ $? -ne 0 ]; then
	_err_msg_="Could not change ownership of to ${_tgt_dir_} ${_sysuser_}:${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

insert_header_footer foot "Successfully installed SYBASE IQ" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: ip_plumb_bkup_intf ###
#
# Plumb IP with interface for FS
#
# Arguments:
#   none
# Return Values:
#   none
ip_plumb_bkup_intf()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

local IPMP_INI=ipmp.ini_fs
local _group_name_="Backup_Group"

$RM -rf ${TEM_DIR}/interface_list

# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" != "fs" ]; then
    insert_header_footer foot "RAW install - Skipping interface information stage" ${LOGFILE}
    set_next_stage `$EXPR ${ARRAY_ELEM}+1`
    return 0
fi

$NMCLI device | $EGREP -v 'System|DEVICE|lo' | $AWK '{print $1}' > ${TEM_DIR}/interface_list
if [ ! -s ${TEM_DIR}/interface_list ]; then
    _err_msg_="Could not build a list of interfaces"
    abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

while :; do

    $RM -rf $TEM_DIR/ipmp_information ${TEM_DIR}/${IPMP_INI}

    $PRINTF '\33[H\33[2J'
    $ECHO "\nInterface Information" >> $TEM_DIR/ipmp_information
    $ECHO "----------------" >> $TEM_DIR/ipmp_information

    while :; do
        $ECHO "\nDo you want to configure Backup Group (Y|N)?"
        read _ans_

        if [ ! "${_ans_}" ]; then
            continue
        fi

        if [ "${_ans_}" == "Y" -o "${_ans_}" == "N" ]; then
            #copy the ipmp.ini file from templates
            if [ -s ${ENIQ_TEMPL_DIR}/${IPMP_INI} ]; then
                $CP ${ENIQ_TEMPL_DIR}/${IPMP_INI} ${TEM_DIR}/${IPMP_INI}
                if [ $? -ne 0 ]; then
                    _err_msg_="Could not copy ${ENIQ_TEMPL_DIR}/${IPMP_INI} to ${TEM_DIR}/${IPMP_INI}"
                    abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
                fi
            else
                _err_msg_="${ENIQ_TEMPL_DIR}/${IPMP_INI} does not exist, or is empty"
                abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
            fi
            iniset ${_group_name_} -f ${TEM_DIR}/${IPMP_INI} ENABLE=${_ans_}
                if [ $? -ne 0 ]; then
                    _err_msg_="Could not update ${TEM_DIR}/${IPMP_INI} with ENABLE=${_ans_}"
                    abort_script "${_err_msg_}"
                fi
                break
        else
            continue
        fi
    done

    _backup_enabled_=`iniget ${_group_name_} -f ${TEM_DIR}/${IPMP_INI} -v ENABLE`
    if [ ! "${_backup_enabled_}" ]; then
        _err_msg_="Could not read ${_group_name_} ENABLE Y in ${TEM_DIR}/${IPMP_INI}"
        abort_script "${_err_msg_}"
    fi
    if [ "${_backup_enabled_}" == "Y" ]; then
        # User selects the interface name
        $ECHO "\nAvailable Interfaces for ${_group_name_}"
        $ECHO "-------------------------------------------"
        $CAT ${TEM_DIR}/interface_list
        while :; do
            $ECHO "\nSelect interface from the list for Backup VLAN"
            read _bkup_intf_
            if [ -z ${_bkup_intf_} ]; then
                continue
            fi
            if [ ! `$GREP -w ${_bkup_intf_} ${TEM_DIR}/interface_list 2>/dev/null` ]; then
                $ECHO "${_bkup_intf_} not in the list"
                continue
            fi
            iniset ${_group_name_} -f ${TEM_DIR}/${IPMP_INI} Backup_Group_Intf=${_bkup_intf_}
            if [ $? -ne 0 ]; then
                _err_msg_="Could not update ${TEM_DIR}/${IPMP_INI} with Backup_Group_Intf=${_bkup_intf_} for ${_group_name_}"
                abort_script "${_err_msg_}"
            fi
            break
        done

        common_get_vlan_ipmp_ip "${_group_name_}"
            _group_ip_=${IPMP_IPS}
            iniset ${_group_name_} -f ${TEM_DIR}/${IPMP_INI} Backup_Group_IP=${IPMP_IPS}
            if [ $? -ne 0 ]; then
                _err_msg_="Could not update ${TEM_DIR}/${IPMP_INI} with Backup_Group_IP=${IPMP_IPS} for ${_group_name_}"
                abort_script "${_err_msg_}"
            fi

        common_get_vlan_ipmp_netmask "${_group_name_}"
            _ipv4_netmask_=${IPMP_NETMASKS}
            iniset ${_group_name_} -f ${TEM_DIR}/${IPMP_INI} Backup_Group_Netmask=${IPMP_NETMASKS}
            if [ $? -ne 0 ]; then
                _err_msg_="Could not update ${TEM_DIR}/${IPMP_INI} with Backup_Group_Netmask=${IPMP_NETMASKS} for ${_group_name_}"
                abort_script "${_err_msg_}"
            fi

        common_get_vlan_gateway "${_group_name_}"
            _gateway_=${IPMP_GATEWAY}
            iniset ${_group_name_} -f ${TEM_DIR}/${IPMP_INI} Backup_Group_Gateway=${IPMP_GATEWAY}
            if [ $? -ne 0 ]; then
                _err_msg_="Could not update ${TEM_DIR}/${IPMP_INI} with Backup_Group_Gateway=${IPMP_GATEWAY} for ${_group_name_}"
                abort_script "${_err_msg_}"
            fi
        $ECHO "\nGroup name:\t${_group_name_}" >> $TEM_DIR/ipmp_information
        $ECHO "\n${_group_name_} Interface:\t${_bkup_intf_}" >> $TEM_DIR/ipmp_information
        $ECHO "${_group_name_} IP:\t${_group_ip_}" >> $TEM_DIR/ipmp_information
        $ECHO "${_group_name_} netmask:\t${_ipv4_netmask_}" >> $TEM_DIR/ipmp_information
        $ECHO "${_group_name_} Gateway IP:\t${_gateway_}" >> $TEM_DIR/ipmp_information

        # Final confirmation for user input
        while :; do
            $PRINTF '\33[H\33[2J'

            $CAT $TEM_DIR/ipmp_information
            $ECHO "\nIs the information above correct (Yes|No)"
            read _ans_

            if [ ! "${_ans_}" ]; then
                continue
            fi

            if [ "${_ans_}" == "Yes" -o "${_ans_}" == "No" ]; then
                break
            else
                continue
            fi
        done
        if [ "${_ans_}" == "Yes" ]; then
            $CP ${TEM_DIR}/${IPMP_INI} ${ENIQ_CONF_DIR}/${IPMP_INI}
            if [ $? -ne 0 ]; then
                _err_msg_="Could not copy ${TEM_DIR}/${IPMP_INI} to ${ENIQ_CONF_DIR}/${IPMP_INI}"
                abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
            fi
            core_install_ip_assign_intf ${_group_name_} ${ENIQ_CONF_DIR}/${IPMP_INI}
            if [ $? -ne 0 ]; then
                _err_msg_="Failed to setup backup interfaces"
                abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
            fi
            insert_header_footer foot "Successfully setup backup interface information" ${LOGFILE}
            break
        else
            unset _bkup_intf_
            continue
        fi
    else
        insert_header_footer foot "Backup vlan not configured on rack" ${LOGFILE}
        break
    fi
done

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: label_db_disks ####
#
# Label all DB lun disks disks
#
# Arguments:
#	   none
# Return Values:
#	   none
label_db_disks()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" == "fs" ]; then
	insert_header_footer foot "FS Install - Skipping core install stage - ${NEXT_STAGE} " ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

local _db_label_disk_list_ _iq_sys_main_disk_list_
local _main_db_disk_list_ _temp_db_disk_list_

_iq_sys_main_disk_list_=`iniget DB_DISK_ALLOC -f ${ENIQ_CONF_DIR}/${SYM_INI} -v IQ_SYS_MAIN_DISKS`
_main_db_disk_list_=`iniget DB_DISK_ALLOC -f ${ENIQ_CONF_DIR}/${SYM_INI} -v MAINDB_DISKS`
_temp_db_disk_list_=`iniget DB_DISK_ALLOC -f ${ENIQ_CONF_DIR}/${SYM_INI} -v TEMPDB_DISKS`

if [ "${SERVER_TYPE}" == "CO" ]; then
	_db_label_disk_list_="${_iq_sys_main_disk_list_} ${_main_db_disk_list_} ${_temp_db_disk_list_}"
else
	_db_label_disk_list_="${_temp_db_disk_list_}"
fi

# Re-label the disks that will be used for zfs pool(s)
$RM -f ${TEM_DIR}/db_disk_list
for _db_disk_ in ${_db_label_disk_list_}; do
	$ECHO ${_db_disk_} >> ${TEM_DIR}/db_disk_list
done

if [ ! -s ${TEM_DIR}/db_disk_list ]; then
	_err_msg_="Could not read disks for IQ DB Creation"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
label_disk ${TEM_DIR}/db_disk_list

insert_header_footer foot "Successfully Labelled IQ DB disks" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: label_disk ###
#
# Label required disks
#
# Arguments:
#	   $1 : File containing list of disks to be labeled
# Return Values:
#	   none
label_disk()
{
RUN_SHL=/usr/bin/sh
if [ ! "${SOLARIS_10}" ]; then
	RUN_SHL=/usr/bin/bash
fi

local _label_disk_list_file_=${1}
local _disk_

$RM -f ${TEM_DIR}/label_disk_list  ${TEM_DIR}/fmt_disk_list

${SCRIPTHOME}/get_disk_list.sh -r > ${TEM_DIR}/fmt_disk_list 2>/dev/null

for _disk_ in `$CAT ${_label_disk_list_file_}`; do
	if [ -f ${ENIQ_CONF_DIR}/disks_labeled ]; then
		$EGREP -w "${_disk_}" ${ENIQ_CONF_DIR}/disks_labeled >> /dev/null 2>&1
		if [ $? -eq 0 ]; then
			$ECHO "${_disk_} already labeled" >>  ${LOGFILE}
			continue
		fi
	fi
	$EGREP -w "${_disk_}" ${TEM_DIR}/fmt_disk_list >> /dev/null 2>&1
	if [ $? -eq 0 ]; then
		$ECHO ${_disk_} >> ${TEM_DIR}/label_disk_list
	fi
done

if [ -s ${TEM_DIR}/label_disk_list ]; then
	$ECHO "Labelling the following disks:" | $TEE -a ${LOGFILE}
	$CAT ${TEM_DIR}/label_disk_list | $TEE -a ${LOGFILE}
	${RUN_SHL} ${SCRIPTHOME}/label_disks.sh -f ${TEM_DIR}/label_disk_list -N -t EFI
	if [ $? -eq 0 ]; then
		# Record the fact that I labeled the disks
		$CAT ${TEM_DIR}/label_disk_list >> ${ENIQ_CONF_DIR}/disks_labeled
	fi
fi
}

### Function: manage_deployment_type ###
#
# Update the NAS template file depending on
# deployment type
#
# Arguments:
#   none
# Return Values:
#   none
manage_deployment_type()
{
local _storage_ini_templ_=""
local _san_device_=""

# Check the type of SAN Device

_san_device_=`$CAT ${ENIQ_CONF_DIR}/san_details | $EGREP "^SAN_DEVICE=" | $AWK -F\= '{print $2}'`
if [ ! "${_san_device_}" ]; then
			_err_msg_="Could not read SAN_DEVICE value from ${ENIQ_CONF_DIR}/san_details"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Has the user specified deployment=
if [ -s ${ENIQ_CONF_DIR}/extra_params/deployment ]; then
	_deployment_=`$CAT ${ENIQ_CONF_DIR}/extra_params/deployment`

	case ${_deployment_} in
		small)  _storage_ini_templ_="storage_ini.sml"
				;;
		medium)	_storage_ini_templ_="storage_ini.med"
				;;
		large)	_storage_ini_templ_="storage_ini.lrg"
				;;
		ft)	 _storage_ini_templ_="storage_ini.ft"
				;;
		vm)	 _storage_ini_templ_="storage_ini.vm"
				;;
	esac

	if [ ! -s ${ENIQ_TEMPL_DIR}/${_storage_ini_templ_} ]; then
		_err_msg_="${ENIQ_TEMPL_DIR}/${_storage_ini_templ_} not found, or is empty"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	if [ -s ${ENIQ_CORE_INST_DIR}/etc/${INSTALL_TYPE}_${_san_device_}.cfg ]; then
		modify_file_system ${ENIQ_TEMPL_DIR}/${_storage_ini_templ_} ${ENIQ_CORE_INST_DIR}/etc/${INSTALL_TYPE}_${_san_device_}.cfg ${_deployment_}
		if [ $? -ne 0 ]; then
			_err_msg_="${ENIQ_TEMPL_DIR}/${_storage_ini_templ_} is not updated properly"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	else
		log_msg -s "No filesystem configuration required for ${_san_device_} storage in ${INSTALL_TYPE} ${_deployment_} deployments" -l ${LOGFILE}
	fi

	$ECHO "Using values in ${ENIQ_TEMPL_DIR}/${_storage_ini_templ_} for NAS filesystem information" >> ${LOGFILE}
	$CAT ${ENIQ_TEMPL_DIR}/${_storage_ini_templ_} | $SED -e "s|<CHANGE><ENIQ_BASE_DIR>|${ENIQ_BASE_DIR}|g" > ${ENIQ_CONF_DIR}/${STORAGE_INI}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy ${ENIQ_TEMPL_DIR}/${_storage_ini_templ_} to ${ENIQ_CONF_DIR}/${STORAGE_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
else
	_err_msg_="Parameter \"deployment\" incorrectly specified, or is missing from boot command"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

}


### Function: mount_req_dirs ###
#
# Mount required dirs for the stage
#
# Arguments:
#   none
# Return Values:
#   none
mount_req_dirs()
{
# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" == "fs" ]; then
	$ECHO "FS install - Skipping mount_req_dirs function" >> ${LOGFILE}
	return 0
fi

$RM -rf ${TEM_DIR}/nasd_config

if [ "$1" ]; then
	_stage_="$1"
else
	_stage_="$NEXT_STAGE"
fi

if [ ! -s ${ENIQ_CONF_DIR}/${STORAGE_INI} ]; then
	$ECHO "${ENIQ_CONF_DIR}/${STORAGE_INI} not found, or is empty" | $TEE -a ${LOGFILE}
	return 1
fi

# Set a flag to change mount ownership
_change_owner_=0

if [ -s ${ENIQ_CONF_DIR}/${SUNOS_INI} ]; then
	# Get the System User/Group. All directories are owned by this
	_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
	if [ ! "${_sysuser_}" ]; then
		$ECHO -e "Could not read parameter ENIQ_SYSUSER from file\n${ENIQ_CONF_DIR}/${ENIQ_INI}" | $TEE -a ${LOGFILE}
		return 1
	fi

	if [ "${_sysuser_}" ]; then
	$CAT /etc/passwd | $EGREP "^${_sysuser_}" >> /dev/null 2>&1
		if [ $? -eq 0 ]; then
			_sysgrp_=`$ID ${_sysuser_} | $AWK '{print $2}' | $AWK -F\( '{print $2}' | $AWK -F\) '{print $1}'`
			if [ ! "${_sysgrp_}" ]; then
				$ECHO "Could not determine group ID of ${_sysuser_}" | $TEE -a ${LOGFILE}
				return 1
			fi
			_change_owner_=1
		fi
	fi
fi

_fs_list_=`iniget Storage_NAS_FS_LIST -f ${ENIQ_CONF_DIR}/${STORAGE_INI}`
if [ ! "${_fs_list_}" ]; then
	$ECHO "Could not read NAS information from ${ENIQ_CONF_DIR}/${STORAGE_INI}" | $TEE -a ${LOGFILE}
	return 1
fi

for _fs_ in ${_fs_list_}; do
	_nas_alias_=`iniget ${_fs_} -f ${ENIQ_CONF_DIR}/${STORAGE_INI} -v NFS_HOST`
	_nas_dir_=`iniget ${_fs_} -f ${ENIQ_CONF_DIR}/${STORAGE_INI} -v SHARE_PATH`
	_mountpoint_=`iniget ${_fs_} -f ${ENIQ_CONF_DIR}/${STORAGE_INI} -v MOUNT_PATH`
	_mount_stage_=`iniget ${_fs_} -f ${ENIQ_CONF_DIR}/${STORAGE_INI} -v STAGE`
	if [ ! "${_nas_alias_}" -o ! "${_mountpoint_}" -o ! "${_nas_dir_}" -o ! "${_mount_stage_}" ]; then
		$ECHO "Could not filter required mount info from ${ENIQ_CONF_DIR}/${STORAGE_INI}" | $TEE -a ${LOGFILE}
		return 1
	fi

	if [ "${_mount_stage_}" == "${_stage_}" ]; then
		# Flag to determine if a mount is required
		_mount_=0

		# Create the mountpoint if its not there
		if [ ! -d ${_mountpoint_} ]; then
			$ECHO -e "\nMaking mountpoint - ${_mountpoint_}" >> $LOGFILE
			$MKDIR -p ${_mountpoint_}
		fi

		$ECHO "Checking if ${_mountpoint_} is already mounted" >> ${LOGFILE}
		_mount_exists_=`mount | $GREP "${_mountpoint_}" | $AWK '{print $1}'`
		if [ ! "${_mount_exists_}" ]; then
			_mount_=1
		fi

		if [ ${_mount_} -eq 1 ]; then
			$ECHO "Mounting ${_nas_alias_}:${_nas_dir_} on ${_mountpoint_}" | $TEE -a ${LOGFILE}
			$MOUNT -t nfs -o vers=3 ${_nas_alias_}:${_nas_dir_} ${_mountpoint_} >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
				$ECHO "Could not mount ${_nas_alias_}:${_nas_dir_} on ${_mountpoint_}" | $TEE -a ${LOGFILE}
				return 1
			fi

			if [ ${_change_owner_} -eq 1 ]; then
				$ECHO "Changing ownership of ${_mountpoint_} to ${_sysuser_}:${_sysgrp_}" >> ${LOGFILE}
				$CHOWN ${_sysuser_}:${_sysgrp_} ${_mountpoint_} >> /dev/null 2>&1
				if [ $? -ne 0 ]; then
					$ECHO "Could not change ownership of ${_mountpoint_} to ${_sysuser_}:${_sysgrp_}" | $TEE -a ${LOGFILE}
					return 1
				fi
			fi
		fi
		$ECHO "${_nas_alias_}::${_nas_dir_}::${_mountpoint_}" >> ${TEM_DIR}/nasd_config
	fi
done

# Update nasd config file
update_nasd_config ${TEM_DIR}/nasd_config

return 0
}

### Function: populate_nasd_config ###
#
# Populate the NASd config file
#
# Arguments:
#   none
# Return Values:
#   none
populate_nasd_config()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" == "fs" ]; then
	insert_header_footer foot "FS Install - Skipping core install stage - ${NEXT_STAGE} " ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi
$RM -rf ${TEM_DIR}/nasd_config

if [ ! -s ${ENIQ_CONF_DIR}/${STORAGE_INI} ]; then
	_err_msg_="${ENIQ_CONF_DIR}/${STORAGE_INI} not found, or is empty"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_fs_list_=`iniget Storage_NAS_FS_LIST -f ${ENIQ_CONF_DIR}/${STORAGE_INI}`
if [ ! "${_fs_list_}" ]; then
	_err_msg_="Could not read NAS information from ${ENIQ_CONF_DIR}/${STORAGE_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_nas_smf_str_=`iniget NAS_DAEMON -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v NAS_SERVICE_STR`
if [ ! "${_nas_smf_str_}" ]; then
	_err_msg_="Could not read NASd service string from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

NAS_online_FMRI=`iniget NAS_DAEMON -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v NAS_MILESTONE_FMRI`
if [ ! "${NAS_online_FMRI}" ]; then
	_err_msg_="Could not read NAS milestone FMRI from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$ECHO "Stopping ${_nas_smf_str_}" | $TEE -a ${LOGFILE}
$SYSTEMCTL stop ${_nas_smf_str_}

if [ $? -ne 0 ]; then
	_err_msg_="Could not stop ${_nas_smf_str_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
else
	$SYSTEMCTL disable ${_nas_smf_str_}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not disable ${_nas_smf_str_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi


for _fs_ in ${_fs_list_}; do
	_nas_alias_=`iniget ${_fs_} -f ${ENIQ_CONF_DIR}/${STORAGE_INI} -v NFS_HOST`
	_nas_dir_=`iniget ${_fs_} -f ${ENIQ_CONF_DIR}/${STORAGE_INI} -v SHARE_PATH`
	_mountpoint_=`iniget ${_fs_} -f ${ENIQ_CONF_DIR}/${STORAGE_INI} -v MOUNT_PATH`
	if [ ! "${_nas_alias_}" -o ! "${_mountpoint_}" -o ! "${_nas_dir_}" ]; then
		_err_msg_="Could not filter required mount info from ${ENIQ_CONF_DIR}/${STORAGE_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
	$ECHO -e "${_nas_alias_}::${_nas_dir_}::${_mountpoint_}" >> ${TEM_DIR}/nasd_config
done

$ECHO "Updating $ENIQ_BASE_DIR/smf/nasd/nasd_config file" >> ${LOGFILE}
$CP ${TEM_DIR}/nasd_config $ENIQ_BASE_DIR/smf/nasd/nasd_config
if [ $? -ne 0 ]; then
	_err_msg_="Could not copy ${TEM_DIR}/nasd_config to $ENIQ_BASE_DIR/smf/nasd/nasd_config"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Don't enable NASd if this is a restore, the restore script will handle it
if [ ! "${RESTORE}" ]; then
	# Check that NASD milestone is online
	check_nasd_milestone_online ${ENIQ_CONF_DIR} ${SUNOS_INI} ${ENIQ_BASE_DIR}
	if [ $? -ne 0 ]; then
		_err_msg_=""
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

insert_header_footer foot "Successfully completed stage - ${NEXT_STAGE}" ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

## Function: read_storage_type ###
#
# Arguments:
#   none
# Return Values:
#   set varibale STORAGE_TYPE
read_storage_type()
{
# Read the storage type
if [ -s ${ENIQ_CONF_DIR}/${SUNOS_INI} ]; then
	STORAGE_TYPE=`iniget STOR_TYPE -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v STORAGE_TYPE`
else
	if [ -s ${ENIQ_CONF_DIR}/san_details ]; then
		STORAGE_TYPE=`$CAT ${ENIQ_CONF_DIR}/san_details | $EGREP "^STORAGE_TYPE=" | $AWK -F\= '{print $2}'`
	fi
fi

if [ ! "${STORAGE_TYPE}" ]; then
	_err_msg_="Could not read STORAGE_TYPE param "
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Read the SAN device type
if [ "${STORAGE_TYPE}" = "raw" ]; then
	if [ -s ${ENIQ_CONF_DIR}/${SUNOS_INI} ]; then
		SAN_DEVICE=`iniget SAN_DEV -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v SAN_DEVICE`
	else
		if [ -s ${ENIQ_CONF_DIR}/san_details ]; then
			SAN_DEVICE=`$CAT ${ENIQ_CONF_DIR}/san_details | $EGREP "^SAN_DEVICE=" | $AWK -F\= '{print $2}'`
		fi
	fi
	
	if [ "${SAN_DEVICE}" == "local" ]; then
		SAN_DEVICE="vnx"
		_san_device_="local"
	fi
else
	if [ "${_deployment_} == "small" -o "${_deployment_} == "ft" ]; then
		SAN_DEVICE="${STORAGE_TYPE}_compact"
	else
		SAN_DEVICE="${STORAGE_TYPE}"
	fi
	_san_device_="local"
fi

if [ ! "${SAN_DEVICE}" ]; then
	_err_msg_="Could not read SAN_DEVICE param"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
}

### Function: regenerateslots ###
#
# Regenerates the slots for engine towards Sybase
#
# Arguments:
#   none
# Return Values:
#   none
regenerateslots()
{
if [ ! -s ${ENIQ_ADMIN_BIN_DIR}/regenerateslots ]; then
	_err_msg_="${ENIQ_ADMIN_BIN_DIR}/regenerateslots not found"
	abort_script "${_err_msg_}"  "${EXEC_SHELL_CMD}"
fi

# Get the System User/Group. All directories are owned by this
_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file\n${ENIQ_CONF_DIR}/${ENIQ_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$ECHO "$SU - ${_sysuser_} -c \"/usr/bin/bash ${ENIQ_ADMIN_BIN_DIR}/regenerateslots\"" >> ${LOGFILE}
$SU - ${_sysuser_} -c "/usr/bin/bash ${ENIQ_ADMIN_BIN_DIR}/regenerateslots"
if [ $? -ne 0 ]; then
	_err_msg_="Issue encountered while running ${ENIQ_ADMIN_BIN_DIR}/regenerateslots"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
else
	$ECHO "${ENIQ_ADMIN_BIN_DIR}/regenerateslots completed successfully" | $TEE -a ${LOGFILE}
fi
}

### Function: relocate_sentinel ###
#
# Move the Sentinel binaries to NAS
#
# Arguments:
#   none
# Return Values:
#   none
relocate_sentinel()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" == "fs" ]; then
	insert_header_footer foot "FS install - Skipping core install stage - ${NEXT_STAGE}" ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

# Move Sentinel to a temp location
_sentinel_systemd_str_=`iniget SENTINEL -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v SENTINEL_SYSTEMD_STR`
if [ ! "${_sentinel_systemd_str_}" ]; then
	_err_msg_="Could not get Sentinel service string from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sentinel_tmp_dir_="/var/tmp/sentinel"
$MKDIR -p ${_sentinel_tmp_dir_}
if [ $? -ne 0 ]; then
	_err_msg_="Could not create ${_sentinel_tmp_dir_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

log_msg -s "Copying files from ${ENIQ_BASE_DIR}/sentinel to ${_sentinel_tmp_dir_}" -l ${LOGFILE}
$CP -rp ${ENIQ_BASE_DIR}/sentinel/* ${_sentinel_tmp_dir_}
if [ $? -ne 0 ]; then
	_err_msg_="Failed to copy ${ENIQ_BASE_DIR}/sentinel/* to ${_sentinel_tmp_dir_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

log_msg -s "Recreating ${ENIQ_BASE_DIR}/sentinel" -l ${LOGFILE}
$RM -rf ${ENIQ_BASE_DIR}/sentinel
if [ $? -ne 0 ]; then
	_err_msg_="Failed to remove ${ENIQ_BASE_DIR}/sentinel"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$MKDIR -p ${ENIQ_BASE_DIR}/sentinel
if [ $? -ne 0 ]; then
	_err_msg_="Failed to create ${ENIQ_BASE_DIR}/sentinel"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ "${STORAGE_TYPE}" == "raw" ]; then
	# Check mountpoints and mount if not there
	mount_req_dirs
	if [ $? -ne 0 ]; then
	   _err_msg_="Could not mount required directories, Sentinel has not been relocated"
	   abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

log_msg -s "Copying files from ${_sentinel_tmp_dir_} to ${ENIQ_BASE_DIR}/sentinel" -l ${LOGFILE}
$CP -rp ${_sentinel_tmp_dir_}/* ${ENIQ_BASE_DIR}/sentinel
if [ $? -ne 0 ]; then
	_err_msg_="Failed to copy ${_sentinel_tmp_dir_}/* to ${ENIQ_BASE_DIR}/sentinel"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

log_msg -s "Validating Sentinel startup by starting Sentinel process." -l ${LOGFILE}
start_Sentinel ${ENIQ_SENTINEL_BIN_DIR} ${ENIQ_SENTINEL_ENV} ${LOGFILE}
if [ $? -ne 0 ]; then
	_err_msg_="Could not start Sentinel"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Adding 10 second sleep before startup and shutdown of
# Sentinel Process
$SLEEP 10

log_msg -s "Shutting down Sentinel process." -l ${LOGFILE}
${ENIQ_SENTINEL_BIN_DIR}/lsrvdown localhost > /dev/null 2>&1
if [ $? -ne 0 ]; then
   _err_msg_="Could not shutdown Sentinel process."
   abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

insert_header_footer foot "Successfully migrated to NAS" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: restore_hosts_file ###
#
# Restore hosts file
#
# Arguments:
#	   full path to the host file to restore
# Return Values:
#	   none
restore_hosts_file()
{
if [ "$1" ]; then
	_restore_file_="$1"
else
	_err_msg_="Incorrect arguments to restore_hosts_file function: File not specified"
	echo "${_err_msg_}" | $TEE -a ${LOGFILE}
	return 1
fi

if [ -s ${_restore_file_} ]; then
	$CP ${_restore_file_} /etc/hosts
	if [ $? -ne 0 ]; then
		$CAT ${_tmp_log_} >> ${LOGFILE}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not copy ${_tmp_log_} to ${LOGFILE}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
		_err_msg_="Failed to copy ${_restore_file_} to /etc/hosts"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi
}
### Function: set_next_stage ###
#
# Set up the stage to be run
#
# Arguments:
#   $1 : Stage to be set to. Either numeric value or 'cleanup'
# Return Values:
#   none
set_next_stage()
{
# Do I have to reset stage
if [ "${USER_STAGE}" -a "${NO_RESET_STAGE}" ]; then
	return 0
fi

_stage_time_=`$DATE '+%Y-%b-%d_%H.%M.%S'`
$ECHO "# Setting new stage at $_stage_time_" > ${STAGEFILE} | $TEE -a ${LOGFILE}
$ECHO "${ENIQ_CORE_STAGES[$1]} " >> ${STAGEFILE} | $TEE -a ${LOGFILE}
}

### Function: setup_env ###
#
# Set up environment variables for script.
#
# Arguments:
#   none
# Return Values:
#   none
setup_env()
{
# Determine Solaris OS version
unset RHEL7_4
OS_VERSION=`$UNAME -r`
if [ "${OS_VERSION}" == "3.10.0-693.el7.x86_64" ]; then
	RHEL7_4=YES
fi

# Define root user's home 
#ROOT_HOME=/
#if [ ! "${SOLARIS_10}" ]; then
	ROOT_HOME=/root

	# Setting the env HOME to /root for console run
	export HOME=/root
#fi

if [ ! "${ENIQ_BASE_DIR}" ]; then
	# Directory on the root filesystem
	ENIQ_BASE_DIR=/eniq
fi

# ENIQ Admin Directory
ENIQ_ADMIN_DIR=${ENIQ_BASE_DIR}/admin

# ENIQ connectd Directory
ENIQ_CONNECTD_DIR=${ENIQ_BASE_DIR}/connectd

# ENIQ Log Directory
ENIQ_LOG_DIR=${ENIQ_BASE_DIR}/local_logs

# ENIQ Admin Bin Directory
ENIQ_ADMIN_BIN_DIR=${ENIQ_ADMIN_DIR}/bin

# ENIQ Installer Directory
ENIQ_INSTALLER_DIR=${ENIQ_BASE_DIR}/sw/installer

# ENIQ TP Installer
TP_INSTALLER=tp_installer

# ENIQ SW conf
CLI_CONF_DIR=${ENIQ_BASE_DIR}/sw/conf

# Main Directory for the Core Installation SW
ENIQ_INST_DIR=${ENIQ_BASE_DIR}/installation

# Main Directory for the Core Installation SW
ENIQ_CORE_INST_DIR=${ENIQ_INST_DIR}/core_install

# Core bin dir
ENIQ_CORE_BIN_DIR=${ENIQ_CORE_INST_DIR}/bin

# Main Directory for the Core Installation etc SW
ENIQ_CORE_ETC_DIR=${ENIQ_CORE_INST_DIR}/etc

# ENIQ Config Directory
ENIQ_CONF_DIR=${ENIQ_INST_DIR}/config

#UDEV File
UDEV_FILE=/etc/udev/rules.d/99-iq-raw-devs.rules

#BIS directory
BIS_MOUNT_PT=/eniq/BIS

# File containing the type of OSS installation. Eg. events or statistics
INST_TYPE_FILE=${ENIQ_CONF_DIR}/ericsson_use_config
if [ ! -s "${INST_TYPE_FILE}" ]; then
	_err_msg_="ENIQ install type not defined in ${INST_TYPE_FILE}"
	abort_script "${_err_msg_}"  "${EXEC_SHELL_CMD}"
fi
# Read the installation type - should be "events" or "stats"
INSTALL_TYPE=`$CAT ${INST_TYPE_FILE} | $AWK -F\= '{print $2}'`

# Templates Directory
ENIQ_TEMPL_DIR="`$DIRNAME ${SCRIPTHOME}`/templates/${INSTALL_TYPE}"

# Common SW directory
ENIQ_COMMON_SW_DIR="`$DIRNAME ${SCRIPTHOME}`/templates/common"

# File containg IP address of jumpstart server (if any)
SERVERFILE=${ENIQ_CONF_DIR}/INSTALL_SERVER

# Location of ENIQ status file. This contains overall version of ENIQ
ENIQ_STATUS_FILE=${ENIQ_ADMIN_DIR}/${ENIQ_VERSION_DIR}/${ENIQ_STATUS}

# File containing the list of server types
SERVER_TYPE_LIST_FILE=${ENIQ_CORE_INST_DIR}/etc/${INSTALL_TYPE}_server_list

# File containing the list of mount points
FSTAB=/etc/fstab

#String denoting the filesystem type
FS_TYPE=ext4

# Var Tem dir
VAR_TMP_DIR=/var/tmp

#String denoting the partition number
PARTITION_NUM=1

#String denoting the partition ID
PARTITION_ID="8e"

# String denoting the start of and OSS reference name. Appended
# to this will be the next available number

OSS_REF_STR=eniq_oss_

# OM dir
OM_DIR=om_linux

# OM File
OM_FILE=.om_linux

PORT_PING=${ENIQ_CORE_INST_DIR}/lib/port_ping.pl
if [ ! -x $PORT_PING ]; then
	_err_msg_="$PORT_PING not found or not executable"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Set up Variable to hold network path to SW
if [ -s ${ENIQ_CONF_DIR}/eniq_sw_locate ]; then
	ENIQ_SW_PATH_FILE=${ENIQ_CONF_DIR}/eniq_sw_locate
else
	unset ENIQ_SW_PATH_FILE
fi

# Set up Variable to hold network path to OM
if [ -s ${ENIQ_CONF_DIR}/om_sw_locate ]; then
	OM_SW_PATH_FILE="${ENIQ_CONF_DIR}/om_sw_locate"
else
	unset OM_SW_PATH_FILE
fi

#Set up Variable to hold feature path
if [ -s ${ENIQ_CONF_DIR}/eniq_feature_locate ]; then
	FEATURE_SW_LOCATE=${ENIQ_CONF_DIR}/eniq_feature_locate
else
	unset FEATURE_SW_LOCATE
fi

# Set up Variable to hold network path to SW
if [ ! -s ${SCRIPTHOME}/../lib/iniadd.pl ]; then
	_err_msg_="Cannot locate ${SCRIPTHOME}/../lib/iniadd"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
else
	INIADD=${SCRIPTHOME}/../lib/iniadd.pl
fi

if [ ! -s ${SCRIPTHOME}/../lib/inidel.pl ]; then
	_err_msg_="Cannot locate ${SCRIPTHOME}/../lib/inidel"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
else
	INIDEL=${SCRIPTHOME}/../lib/inidel.pl
fi

# Source the common functions
if [ -s ${SCRIPTHOME}/../lib/common_functions.lib ]; then
	. ${SCRIPTHOME}/../lib/common_functions.lib
else
	_err_msg_="File ${SCRIPTHOME}/../lib/common_functions.lib not found"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ -s ${SCRIPTHOME}/../lib/common_core_install_functions.lib ]; then
	. ${SCRIPTHOME}/../lib/common_core_install_functions.lib
else
	_err_msg_="File ${SCRIPTHOME}/../lib/common_core_install_functions.lib not found"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ -s ${SCRIPTHOME}/../lib/common_inirator_functions.lib ]; then
	. ${SCRIPTHOME}/../lib/common_inirator_functions.lib
else
	_err_msg_="File ${SCRIPTHOME}/../lib/common_inirator_functions.lib not found"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# File to hold stage information
STAGEFILE=${ENIQ_CORE_INST_DIR}/etc/eniq_core_inst_stage

HNAME=`${MYHOSTNAME}`
#HOST_IP=`$GETENT hosts ${HNAME} | $AWK '{print $1}' | $HEAD -1`   ----changed
HOST_IP=`hostname --all-ip-addresses | $AWK '{print $1}' | $HEAD -1`

# Has debug flag been used?
if [ -s ${ENIQ_CONF_DIR}/extra_params/debug ]; then
	set -xv
	BASH="/usr/bin/bash -xv"
fi

# String used to determine if the service is an actual ENIQ managed service
MANAGED_STR="ENIQ"

}

### Function: setup_ipmp ###
#
# Set up IPMP.
#
# Arguments:
#   none
# Return Values:
#   none
setup_ipmp()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" != "raw" ]; then
	insert_header_footer foot "FS install - Skipping bond setup stage" ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

#read the deployment type
if [ -s ${ENIQ_CONF_DIR}/extra_params/deployment ]; then
	_deployment_=`$CAT ${ENIQ_CONF_DIR}/extra_params/deployment`
	if [ ! "${_deployment_}" ]; then
		_err_msg_="Could determine the deployment type from ${ENIQ_CONF_DIR}/extra_params/deployment"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

# Set an upgrade flag if required
_upg_flag_=""

if [ "${IPV6_UPGRADE}" ]; then
	_upg_flag_="U"
fi
log_msg "Commencing bond Configuration ..."  | $TEE -a ${LOGFILE}

#to configure the bond vlans
core_install_setup_ipmp ${LOGFILE} ${TEM_DIR} ${ENIQ_CONF_DIR}/${IPMP_INI} ${_deployment_} ${_upg_flag_}
if [ $? -ne 0 ]; then
	_err_msg_="Failed to setup bond"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

insert_header_footer foot "Successfully setup bond" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: setup_SMF_scripts ###
# 
# Set up SMF start/stop scripts
# 
# Arguments:
#   none
# Return Values:
#   none
setup_SMF_scripts()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

_rootdir_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_BASE_DIR`

if [ "${UPGRADE}" ]; then
	$ECHO -e "Removing existing service files in ${ENIQ_SVC_UNIT_LOC}" | $TEE -a ${LOGFILE}
	$RM -f ${ENIQ_SVC_UNIT_LOC}/eniq-*.service >> /dev/null 2>&1
	if [ $? -ne 0 ]; then
		_err_msg_="Could not remove service files in ${ENIQ_SVC_UNIT_LOC}"
		abort_script "${_err_msg_}"
	fi
fi

$ECHO -e "\nImporting new /etc directory"  >> ${LOGFILE}
$FIND ${_rootdir_}/admin/${STORAGE_TYPE}/${ENIQ_SVC_UNIT_LOC}/eniq/runtime/ -name 'eniq-*.service' | $XARGS -i $CP {} ${ENIQ_SVC_UNIT_LOC}

insert_header_footer foot "Successfully installed Service scripts" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: store_initial_oss_tp_feat_det ###
#
# Store the ENIQ interface list for the first OSS
#
# Arguments:
#   $1 : interface file
# Return Values:
#   none
store_initial_oss_tp_feat_det()
{
_tp_file_=${1}

$ECHO "Checking ${ENIQ_ADMIN_DIR} is mounted" >> $LOGFILE
_mount_exists_=`mount | $GREP "${ENIQ_ADMIN_DIR}" | $AWK '{print $1}'`
if [ ! "${_mount_exists_}" ]; then
	_err_msg_="${ENIQ_ADMIN_DIR} is not mounted"
	abort_script "${_err_msg_}"
fi

# Make the required output directorys
_eniq_tp_feat_dir_=${ENIQ_ADMIN_DIR}/managed_oss
_eniq_feat_output_file_=${_eniq_tp_feat_dir_}/total_feature_install_list
$ECHO "Creating ${_eniq_tp_feat_dir_} directory" >> $LOGFILE
$MKDIR -p ${_eniq_tp_feat_dir_}
if [ $? -ne 0 ]; then
	_err_msg_="Could not create ${_eniq_tp_feat_dir_}"
	abort_script "${_err_msg_}"
fi

# Update niq.ini with OSS feature file
$ECHO "Updating ${_eniq_feat_output_file_}" | $TEE -a $LOGFILE
$CAT ${_tp_file_}|$AWK -F"::" '{print $1"::"$2"::"$3}' | $SORT -u > ${_eniq_feat_output_file_}
if [ $? -ne 0 ]; then
	_err_msg_="Could not update ${_eniq_feat_output_file_} using ${_tp_file_} as input"
	abort_script "${_err_msg_}"
fi

# This is the OSS HNAME for first OSS
OSS_REF_NAME="${OSS_REF_STR}1"

# Okay store the ENIQ Interface details per OSS
$MKDIR -p ${_eniq_tp_feat_dir_}/feature_info/${OSS_REF_NAME}
$RM -f ${_eniq_tp_feat_dir_}/feature_info/${OSS_REF_NAME}/feature_install_list
$ECHO "Updating ${_eniq_tp_feat_dir_}/feature_info/${OSS_REF_NAME}/feature_install_list" | $TEE -a $LOGFILE
$CAT ${_tp_file_}|$AWK -F"::" '{print $1"::"$2"::"$3}' > ${_eniq_tp_feat_dir_}/feature_info/${OSS_REF_NAME}/feature_install_list
iniset FEATURE_INFO -f ${ENIQ_CONF_DIR}/${ENIQ_INI} Feature_Interface_Dir=${_eniq_tp_feat_dir_}
if [ $? -ne 0 ]; then
	_err_msg_="Could not set Feature_Interface_Dir=${_eniq_tp_feat_dir_} in ${ENIQ_CONF_DIR}/${ENIQ_INI}"
	abort_script "${_err_msg_}"
fi
}

### Function: update_defaultrouter_file ###
#
# Updates /etc/defaultrouter file
#
# Arguments:
#   none
# Return Values:
#   none
update_defaultrouter_file()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}


_update_=1

# Set up the defaultrouter if necessary
_defrouter_=`iniget SunOS_GATEWAY -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v DEFAULTROUTERS`
if [ -s /etc/sysconfig/network ]; then
	$CAT /etc/sysconfig/network | $EGREP "^[[:blank:]]*${_defrouter_}[[:blank:]]*$" >> /dev/null 2>&1
	if [ $? -eq 0 ]; then
		_update_=0
	fi
fi

if [ ${_update_} -eq 1 ]; then
   $ECHO "Updating /etc/sysconfig/network with ${_defrouter_}" >> ${LOGFILE}
   if [ -s /etc/sysconfig/network ]; then
		if [ ! -f /etc/sysconfig/network.orig ]; then
			$CP -p /etc/sysconfig/network /etc/sysconfig/network.orig >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Could not make backup of /etc/sysconfig/network"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		fi
		# There are already some entries in the file. I will put required
		# router first and then append the rest
		$RM -f ${TEM_DIR}/defroute
		$CAT /etc/sysconfig/network > ${TEM_DIR}/defroute
		$ECHO "${_defrouter_}" >> ${TEM_DIR}/defroute
		$CP ${TEM_DIR}/defroute /etc/sysconfig/network
		if [ $? -ne 0 ]; then
			_err_msg_="Could not update /etc/sysconfig/network"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	else
		$ECHO "${_defrouter_}" > /etc/sysconfig/network
		if [ $? -ne 0 ]; then
			_err_msg_="Could not create /etc/sysconfig/network"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi
else
	$ECHO "No updates required for /etc/sysconfig/network" >> ${LOGFILE}
fi

if [ ${_update_} -eq 1 ]; then
	insert_header_footer foot "Successfully updated /etc/sysconfig/network file" ${LOGFILE}
else
	insert_header_footer foot "Successfully Completed core install stage - ${NEXT_STAGE}" ${LOGFILE}
fi

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: update_dns_files ###
#
# Updates DNS files
#
# Arguments:
#   none
# Return Values:
#   none
update_dns_files()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

_update_srv_=0
_update_dom_=1
_update_nss_=0

# Set up the /etc/resolv.conf if necessary
_dnsserver_=`iniget SunOS_DNS -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v NAMESERVERS`
_dnsdomain_=`iniget SunOS_DNS -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v DNSDOMAIN`

if [ "${_dnsserver_}" == "none" ]; then
	insert_header_footer foot "No DNS configuration required - skipping ${NEXT_STAGE} stage" ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

if [ ! "${_dnsdomain_}" ]; then
	_err_msg_="Could not read DNSDOMAIN from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}"
fi

# Make a backup if I'm going to change anything
if [ ${_update_srv_} -eq 1 -o ${_update_dom_} -eq 1 ]; then
	$ECHO "Updating /etc/resolv.conf file with DNS information" >> ${LOGFILE}
	core_install_update_resolv_conf ${LOGFILE} ${TEM_DIR} ${_dnsserver_} ${_dnsdomain_} ${_update_srv_} ${_update_dom_}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not update /etc/resolv.conf"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	# Update the nsswitch.conf to use DNS if DNS exists
	core_install_update_nsswitch_conf ${LOGFILE} ${TEM_DIR}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not update /etc/nsswitch.conf"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

if [ ${_update_srv_} -eq 1 -o ${_update_dom_} -eq 1 ]; then
	insert_header_footer foot "Successfully updated system DNS file(s)" ${LOGFILE}
else
	insert_header_footer foot "Successfully completed core install stage - ${NEXT_STAGE}" ${LOGFILE}
fi

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: update_ec_service_name ###
#
# Update service file with ec info
#
# Arguments:
#   none
# Return Values:
#   none
update_ec_service_name()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Get the System User/Group. All directories are owned by this
_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysgrp_=`$ID ${_sysuser_} | $AWK '{print $2}' | $AWK -F\( '{print $2}' | $AWK -F\) '{print $1}'`
if [ ! "${_sysgrp_}" ]; then
	_err_msg_="Could not determine group ID of ${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# If it's a mediation server then remove any existing entries that the host IP has in the service_names file
if [ "${CURR_SERVER_TYPE}" == "eniq_mz" ]; then
	log_msg -s "\nRemoving existing ${HOST_IP} entries from ${CLI_CONF_DIR}/service_names" -q -l ${LOGFILE}
	$CAT ${CLI_CONF_DIR}/service_names | $EGREP -v ${HOST_IP} > ${TEM_DIR}/service_names.$$
	if [ $? -ne 0 ]; then
		_err_msg_="Could not remove ${HOST_IP} from ${CLI_CONF_DIR}/service_names file"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	$CP ${TEM_DIR}/service_names.$$ ${CLI_CONF_DIR}/service_names >> /dev/null 2>&1
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy ${TEM_DIR}/service_names.$$ to ${CLI_CONF_DIR}/service_names"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	log_msg -s "Changing ownership of ${CLI_CONF_DIR}/service_names to ${_sysuser_}:${_sysgrp_}" -q -l ${LOGFILE}
	$CHOWN ${_sysuser_}:${_sysgrp_} ${CLI_CONF_DIR}/service_names
	if [ $? -ne 0 ]; then
		_err_msg_="Failed to change ownership of ${CLI_CONF_DIR}/service_names to ${_sysuser_}:${_sysgrp_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi


# Get the EC number being installed
_chk_num_=0

# Look for any ec instances
if [ "${CURR_SERVER_TYPE}" == "eniq_es" ]; then
	log_msg -s "\n${CURR_SERVER_TYPE} install, setting this as the first ec" -q -l ${LOGFILE}
	_chk_num_=1
else
	_ec_list_=`$CAT ${CLI_CONF_DIR}/service_names | $EGREP "ec_[0-9]+" | $AWK -F"::" '{print $3}' | $AWK -F\_ '{print $2}'`
	if [ ! "${_ec_list_}" ]; then
		_chk_num_=1
	else
		for _ec_num_ in ${_ec_list_}; do
			if [ ${_ec_num_} -gt ${_chk_num_} ]; then
				_chk_num_=${_ec_num_}
			fi
		done
		let _chk_num_=_chk_num_+1
	fi
fi

_ec_service_name="ec_${_chk_num_}"

# Update the service_names file
log_msg -s "\nUpdating ${CLI_CONF_DIR}/service_names with ${_ec_service_name}" -q -l ${LOGFILE}
update_service_file ${CLI_CONF_DIR}/service_names ${HOST_IP} ${HNAME} ${_ec_service_name} "NULL_GRP"
if [ $? -ne 0 ]; then
	_err_msg_="Failed to update ${CLI_CONF_DIR}/service_names with ${_ec_service_name}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

log_msg -s "\nChanging ownership of ${CLI_CONF_DIR}/service_names to ${_sysuser_}:${_sysgrp_} after updates for ${_ec_service_name}" -q -l ${LOGFILE}
$CHOWN ${_sysuser_}:${_sysgrp_} ${CLI_CONF_DIR}/service_names
if [ $? -ne 0 ]; then
	_err_msg_="Failed to change ownership of ${CLI_CONF_DIR}/service_names to ${_sysuser_}:${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

insert_header_footer foot "Successfully completed core install stage - ${NEXT_STAGE}" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: update_ENIQ_env_files ###
#
# Update ENIQ env file
#
# Arguments:
#   none
# Return Values:
#   none
update_ENIQ_env_files()
{
insert_header_footer head "Entering Core Install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

if [ ! -s ${ENIQ_TEMPL_DIR}/${ENIQ_ENV} ]; then
	_err_msg_="Could not locate ${ENIQ_TEMPL_DIR}/${ENIQ_ENV}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_cli_conf_dir_=`$CAT ${ENIQ_CONF_DIR}/${ENIQ_ENV} | $EGREP "^[[:blank:]]*CONF_DIR=" | $AWK -F\= '{print $2}' | $SED -e 's|"||g'`
if [ ! "${_cli_conf_dir_}" ]; then
	_err_msg_="Could not read CONF_DIR parameter from ${ENIQ_CONF_DIR}/${ENIQ_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Get the System User/Group. All directories are owned by this
_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysgrp_=`$ID ${_sysuser_} | $AWK '{print $2}' | $AWK -F\( '{print $2}' | $AWK -F\) '{print $1}'`
if [ ! "${_sysgrp_}" ]; then
	_err_msg_="Could not determine group ID of ${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ -s ${_cli_conf_dir_}/${ENIQ_INI} ]; then
	log_msg -s "Copying ${_cli_conf_dir_}/${ENIQ_INI} to ${ENIQ_CONF_DIR}" -q -l ${LOGFILE}
	$CP ${_cli_conf_dir_}/${ENIQ_INI} ${ENIQ_CONF_DIR}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy ${_cli_conf_dir_}/${ENIQ_INI} to ${ENIQ_CONF_DIR}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

if [ "${SERVER_TYPE}" == "CO" -o "${CURR_SERVER_TYPE}" == "stats_engine" ]; then
	# Set the Heap Memory size of the ENIQ engine.
	
		if [ "${CURR_SERVER_TYPE}" == "stats_engine" ]; then
			_heap_factor_=2
		else
			_heap_factor_=18
		fi
	

	if [ ! -f ${ENIQ_CONF_DIR}/extra_params/verbose_settings ]; then
		log_msg -s "Updating engine heap size in ${ENIQ_CONF_DIR}/${ENIQ_INI}" -q -l ${LOGFILE}
		update_engine_java_heap_size ${ENIQ_CONF_DIR}/${ENIQ_INI} ${_heap_factor_}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not update engine Heap Memory size"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi

fi

if [ "${SERVER_TYPE}" == "CO" ]; then
	# Copy the inirator feature selection to the location thats used from now on
	if [ ! "${UPGRADE}" ]; then
		if [ -f ${ENIQ_CONF_DIR}/no_feature -a "${INSTALL_TYPE}" == "stats" ]; then
			log_msg -s "No initial feature to update on ${ENIQ_CONF_DIR}/feature_output_list" -q -l ${LOGFILE}
		else
			 # Update the TP data files for the first OSS
			if [ ! -s ${ENIQ_CONF_DIR}/feature_output_list ]; then
				_err_msg_="${ENIQ_CONF_DIR}/feature_output_list not found or is empty"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
			store_initial_oss_tp_feat_det ${ENIQ_CONF_DIR}/feature_output_list
		fi
	fi
fi

_eniq_tp_feat_dir_=${ENIQ_ADMIN_DIR}/managed_oss
_eniq_feat_output_file_=${_eniq_tp_feat_dir_}/total_feature_install_list

# This is eventually not needed.
log_msg -s "Setting Feature_Interface_Dir to ${_eniq_tp_feat_dir_} in ${ENIQ_CONF_DIR}/${ENIQ_INI}" -q -l ${LOGFILE}
iniset FEATURE_INFO -f ${ENIQ_CONF_DIR}/${ENIQ_INI} Feature_Interface_Dir=${_eniq_tp_feat_dir_}
if [ $? -ne 0 ]; then
	_err_msg_="Could not set Feature_Interface_Dir=${_eniq_tp_feat_dir_} in ${ENIQ_CONF_DIR}/${ENIQ_INI}"
	abort_script "${_err_msg_}"
fi

log_msg -s "Setting Feature_Output_File to ${_eniq_feat_output_file_} in ${ENIQ_CONF_DIR}/${ENIQ_INI}" -q -l ${LOGFILE}
iniset FEATURE_INFO -f ${ENIQ_CONF_DIR}/${ENIQ_INI} Feature_Output_File=${_eniq_feat_output_file_}
if [ $? -ne 0 ]; then
	_err_msg_="Could not set Feature_Output_File=${_eniq_feat_output_file_} in ${ENIQ_CONF_DIR}/${ENIQ_INI}"
	abort_script "${_err_msg_}"
fi

# update the FileSystem info for Stats raw
if [ "${INSTALL_TYPE}" == "stats" ]; then
	if [ "${STORAGE_TYPE}" == "raw" ]; then
		# Set the FileSystem to 4
		iniset DIRECTORY_STRUCTURE -f ${ENIQ_CONF_DIR}/${ENIQ_INI} FileSystems=4
		if [ $? -ne 0 ]; then
			_err_msg_="Could not set FileSystems=4 in ${ENIQ_CONF_DIR}/${ENIQ_INI}"
			abort_script "${_err_msg_}"
		fi
	fi
fi


# Get the System User/Group. All directories are owned by this
_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file\n${ENIQ_CONF_DIR}/${ENIQ_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysgrp_=`$ID ${_sysuser_} | $AWK '{print $2}' | $AWK -F\( '{print $2}' | $AWK -F\) '{print $1}'`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not determine group ID of ${_sysuser_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# For security reasons
log_msg -s "\nChanging permissions of ${ENIQ_CONF_DIR}/${SUNOS_INI} to -rw-r--r--" -q -l ${LOGFILE}
$CHMOD 644 ${ENIQ_CONF_DIR}/${SUNOS_INI}
if [ $? -ne 0 ]; then
	_err_msg_="Could not change permissions on ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

log_msg -s "Changing permissions of ${ENIQ_CONF_DIR}/${ENIQ_ENV} to -rw-r--r--" -q -l ${LOGFILE}
$CHMOD 644 ${ENIQ_CONF_DIR}/${ENIQ_ENV}
if [ $? -ne 0 ]; then
	_err_msg_="Could not change permissions on ${ENIQ_CONF_DIR}/${ENIQ_ENV}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

log_msg -s "Changing permissions of ${ENIQ_CONF_DIR}/${ENIQ_INI} to -rw-r--r--" -q -l ${LOGFILE}
$CHMOD 644 ${ENIQ_CONF_DIR}/${ENIQ_INI}
if [ $? -ne 0 ]; then
	_err_msg_="Could not change permissions on ${ENIQ_CONF_DIR}/${ENIQ_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

log_msg -s "Changing permissions of ${ENIQ_CONF_DIR}/${SYM_INI} to -rw-r--r--" -q -l ${LOGFILE}
$CHMOD 644 ${ENIQ_CONF_DIR}/${SYM_INI}
if [ $? -ne 0 ]; then
	_err_msg_="Could not change permissions on ${ENIQ_CONF_DIR}/${SYM_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi


if [ "${STORAGE_TYPE}" == "raw" ]; then
	log_msg -s "Changing permissions of ${ENIQ_CONF_DIR}/${STORAGE_INI} to -rw-rw-r--" -q -l ${LOGFILE}
	$CHMOD 664 ${ENIQ_CONF_DIR}/${STORAGE_INI}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not change permissions on ${ENIQ_CONF_DIR}/${STORAGE_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

# Move the required files to where the ENIQ CLI program expects them
_mount_exists_=`mount | $GREP "${ENIQ_BASE_DIR}/sw" | $AWK '{print $1}'`
if [ "${_mount_exists_}" ]; then
	log_msg -s "Creating ${_cli_conf_dir_}" -q -l ${LOGFILE}
	$MKDIR -p ${_cli_conf_dir_}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not make directory ${_cli_conf_dir_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	if [ ! -s ${_cli_conf_dir_}/${ENIQ_ENV} ]; then
		log_msg -s "\nCopying ${ENIQ_CONF_DIR}/${ENIQ_ENV} to ${_cli_conf_dir_}" -q -l ${LOGFILE}
		$CP ${ENIQ_CONF_DIR}/${ENIQ_ENV} ${_cli_conf_dir_}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not copy ${ENIQ_CONF_DIR}/${ENIQ_ENV} to ${_cli_conf_dir_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		log_msg -s "Changing permissions of ${_cli_conf_dir_}/${ENIQ_ENV} to -rw-------" -q -l ${LOGFILE}
		$CHMOD 600 ${_cli_conf_dir_}/${ENIQ_ENV}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not change permissions on ${_cli_conf_dir_}/${ENIQ_ENV}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi

	log_msg -s "\nCopying ${ENIQ_CONF_DIR}/${ENIQ_INI} to ${_cli_conf_dir_}" -q -l ${LOGFILE}
	$CP ${ENIQ_CONF_DIR}/${ENIQ_INI} ${_cli_conf_dir_}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy ${ENIQ_CONF_DIR}/${ENIQ_INI} to ${_cli_conf_dir_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	log_msg -s "Changing permissions of ${_cli_conf_dir_}/${ENIQ_INI} to -rw-------" -q -l ${LOGFILE}
	$CHMOD 600 ${_cli_conf_dir_}/${ENIQ_INI}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not change permissions on ${_cli_conf_dir_}/${ENIQ_INI}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	
	if [ "${STORAGE_TYPE}" == "raw" ]; then
		if [ ! -s ${_cli_conf_dir_}/${STORAGE_INI} ]; then
			log_msg -s "\nCopying ${ENIQ_CONF_DIR}/${STORAGE_INI} to ${_cli_conf_dir_}" -q -l ${LOGFILE}
			$CP ${ENIQ_CONF_DIR}/${STORAGE_INI} ${_cli_conf_dir_}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not copy ${ENIQ_CONF_DIR}/${STORAGE_INI} to ${_cli_conf_dir_}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			log_msg -s "Changing permissions of ${_cli_conf_dir_}/${STORAGE_INI} to -rw-rw-r--" -q -l ${LOGFILE}
			$CHMOD 664 ${_cli_conf_dir_}/${STORAGE_INI}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not change permissions on ${_cli_conf_dir_}/${STORAGE_INI}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			log_msg -s "Changing ownership of ${_cli_conf_dir_}/${STORAGE_INI} to root:storage" -q -l ${LOGFILE}
			$CHOWN root:storage ${_cli_conf_dir_}/${STORAGE_INI}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not change ownership of ${_cli_conf_dir_}/${STORAGE_INI}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		fi

		# Create the copy of the coordinators LUN IDs on the NAS and in the local dir
		if [ "${SERVER_TYPE}" == "CO" ]; then
			log_msg -s "Creating ${ENIQ_CONF_DIR}/${COORD_SYM_INI} from ${ENIQ_CONF_DIR}/${SYM_INI}" -q -l ${LOGFILE}
			$CP ${ENIQ_CONF_DIR}/${SYM_INI} ${ENIQ_CONF_DIR}/${COORD_SYM_INI}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not create ${ENIQ_CONF_DIR}/${COORD_SYM_INI}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi

			log_msg -s "Copying ${ENIQ_CONF_DIR}/${COORD_SYM_INI} to ${_cli_conf_dir_}/${COORD_SYM_INI}" -q -l ${LOGFILE}
			$CP ${ENIQ_CONF_DIR}/${COORD_SYM_INI} ${_cli_conf_dir_}/${COORD_SYM_INI}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not copy ${ENIQ_CONF_DIR}/${COORD_SYM_INI} to ${_cli_conf_dir_}/${COORD_SYM_INI}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		fi
	fi

	# Update a config file with this servers info
	log_msg -s "\nAdding ${HOST_IP}::${HNAME}::${CURR_SERVER_TYPE} to ${_cli_conf_dir_}/server_types file" -q -l ${LOGFILE}
	if [ -s ${_cli_conf_dir_}/server_types ]; then
		log_msg -s "Creating a backup of ${_cli_conf_dir_}/server_types file before updates" -q -l ${LOGFILE}
		$CP ${_cli_conf_dir_}/server_types ${TEM_DIR}/server_types
		if [ $? -ne 0 ]; then
			_err_msg_="Could not copy ${_cli_conf_dir_}/server_types to ${TEM_DIR}/server_types"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi

	$ECHO "${HOST_IP}::${HNAME}::${CURR_SERVER_TYPE}" >> ${TEM_DIR}/server_types
	$ECHO "Updating ${_cli_conf_dir_}/server_types file" >> ${LOGFILE}
	$CAT ${TEM_DIR}/server_types | $SORT -u > ${_cli_conf_dir_}/server_types

	log_msg -s "\nChanging ownership of ${_cli_conf_dir_} to ${_sysuser_}:${_sysgrp_}" -q -l ${LOGFILE}
	$CHOWN -R ${_sysuser_}:${_sysgrp_} ${_cli_conf_dir_} >> /dev/null 2>&1
	if [ $? -ne 0 ]; then
		_err_msg_="Could not change ${_cli_conf_dir_} ownership to ${_sysuser_}:${_sysgrp_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
else
	_err_msg_="${ENIQ_BASE_DIR}/sw is not mounted"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Here we need to add the initial OSS.
if [ -s ${ENIQ_CONF_DIR}/.add_initial_oss.bsh ]; then
	${BASH} ${ENIQ_CONF_DIR}/.add_initial_oss.bsh -l ${LOGFILE}
	if [ $? -ne 0 ]; then
		_err_msg_="Error running command ${BASH} ${ENIQ_CONF_DIR}/.add_initial_oss.bsh"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	$RM -f ${ENIQ_CONF_DIR}/.add_initial_oss.bsh
fi

if [ ! -s ${_cli_conf_dir_}/.oss_ref_name_file ]; then
	if [ -s ${ENIQ_CONNECTD_DIR}/mount_info/.oss_ref_name_file ]; then
		log_msg -s "\nCopying ${ENIQ_CONNECTD_DIR}/mount_info/.oss_ref_name_file to ${_cli_conf_dir_}" -q -l ${LOGFILE}
		$CP ${ENIQ_CONNECTD_DIR}/mount_info/.oss_ref_name_file ${_cli_conf_dir_}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not copy ${ENIQ_CONNECTD_DIR}/mount_info/.oss_ref_name_file to ${_cli_conf_dir_}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi
fi

# Log rotation mechanism for wtmp file.
$SED -i '1,/minsize 1M/s/minsize 1M/size=200M/;1,/monthly/s/monthly/daily/' /etc/logrotate.conf >> /dev/null 2>&1

if [ $? -eq 0 ]; then
		 log_msg -s "Successfully nullified the wtmp file" -l ${LOGFILE}
else
		log_msg -s "Warning:Failed to nullify wtmp file"  -l ${LOGFILE}
fi


insert_header_footer foot "Successfully updated ENIQ ENV file" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: update_nasd_config ###
#
# Update nasd config file
#
# Arguments:
#   none
# Return Values:
#   none
update_nasd_config()
{
_temp_nasd_file_=$1

# Get the System User/Group. All directories are owned by this
_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file\n${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$GETENT passwd ${_sysuser_} >> /dev/null 2>&1
if [ $? -eq 0 ]; then
	_sysgrp_=`$ID ${_sysuser_} | $AWK '{print $2}' | $AWK -F\( '{print $2}' | $AWK -F\) '{print $1}'`
	if [ ! "${_sysgrp_}" ]; then
		_err_msg_="Could not determine group ID of ${_sysuser_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi


$RM -rf ${TEM_DIR}/nasd_config_new

if [ -s $ENIQ_BASE_DIR/smf/nasd/nasd_config ]; then
	$CAT $ENIQ_BASE_DIR/smf/nasd/nasd_config | $EGREP '^[[:blank:]]*' > ${TEM_DIR}/nasd_config_new
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy $ENIQ_BASE_DIR/smf/nasd/nasd_config to ${TEM_DIR}/nasd_config_new"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

$CAT ${_temp_nasd_file_} | $EGREP -v '^[[:blank:]]*#' >> ${TEM_DIR}/nasd_config_new
if [ $? -ne 0 ]; then
	_err_msg_="Could not update ${TEM_DIR}/nasd_config_new with new mounts"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Update nasd config file
$ECHO "Updating $ENIQ_BASE_DIR/smf/nasd/nasd_config with new mounts\n" >> ${LOGFILE}

if [ ! -d $ENIQ_BASE_DIR/smf/nasd -a "${_sysgrp_}" ]; then
	$MKDIR $ENIQ_BASE_DIR/smf/nasd
	$CHOWN ${_sysuser_}:${_sysgrp_} $ENIQ_BASE_DIR/smf/nasd
fi

$CAT ${TEM_DIR}/nasd_config_new | $SORT -u > $ENIQ_BASE_DIR/smf/nasd/nasd_config
if [ $? -ne 0 ]; then
	_err_msg_="Could not update $ENIQ_BASE_DIR/smf/nasd/nasd_config"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
}

### Function: update_netmasks_file ###
#
# Updates /etc/inet/netmasks file
#
# Arguments:
#   none
# Return Values:
#   none
update_netmasks_file()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

# Read the storage type
read_storage_type

if [ "${STORAGE_TYPE}" == "fs" ]; then
	insert_header_footer foot "FS install - Skipping update_netmasks_file stage" ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
fi

if [ -s ${ENIQ_CONF_DIR}/extra_params/deployment ]; then
	_deployment_=`$CAT ${ENIQ_CONF_DIR}/extra_params/deployment`
	if [ "${_deployment_}" == "ft" ]; then
	$ECHO "No updates required to /etc/inet/netmasks" >> ${LOGFILE}
	insert_header_footer foot "Successfully completed core install stage - ${NEXT_STAGE}" ${LOGFILE}
	set_next_stage `$EXPR ${ARRAY_ELEM}+1`
	return 0
	fi
else
	_err_msg_="Parameter \"deployment\" incorrectly specified, or is missing from boot command"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_update_=0

# Set up the netmask if necessary
# Get the System User/Group. All filesystems are owned by this
_netmask_info_=`iniget STOR_NETMASK -f ${ENIQ_CONF_DIR}/${IPMP_INI} -v NETMASKS`
if [ ! "${_netmask_info_}" ]; then
	_err_msg_="Could not get netmask info from ${ENIQ_CONF_DIR}/${IPMP_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_net_num_=`$ECHO ${_netmask_info_} | $AWK -F\: '{print $1}'`
_mask_=`$ECHO ${_netmask_info_} | $AWK -F\: '{print $2}'`

$ECHO "Checking if ${_netmask_info_} exists in /etc/inet/netmasks" >> ${LOGFILE}
$CAT /etc/inet/netmasks | $EGREP "^[[:blank:]]*${_net_num_}[[:blank:]]+${_mask_}[[:blank:]]*$" >> /dev/null 2>&1
if [ $? -ne 0 ]; then
	if [ ! -f /etc/inet/netmasks.orig ]; then
		$CP -p /etc/inet/netmasks /etc/inet/netmasks.orig >> /dev/null 2>&1
		if [ $? -ne 0 ]; then
			_err_msg_="Could not make backup of /etc/inet/netmasks"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi
	$ECHO "Updating /etc/inet/netmasks with ${_net_num_}\t${_mask_}" >> ${LOGFILE}
	$ECHO "${_net_num_}\t${_mask_}" >> /etc/inet/netmasks
	_update_=1
fi

if [ ${_update_} -eq 1 ]; then
	insert_header_footer foot "Successfully updated /etc/inet/netmasks file" ${LOGFILE}
	REBOOT_FLAG=1
else
	$ECHO "No updates required to /etc/inet/netmasks" >> ${LOGFILE}
	insert_header_footer foot "Successfully completed core install stage - ${NEXT_STAGE}" ${LOGFILE}
fi

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: update_sentinel_ini ###
#
# Updates Sentinel information
#
# Arguments:
#   none
# Return Values:
#   none
update_sentinel_ini()
{
# Copy the sentinel.ini file to /eniq/installation/config
if [ ! -s ${ENIQ_CONF_DIR}/${SENTINEL_INI} ]; then
	if [ -s ${ENIQ_TEMPL_DIR}/${SENTINEL_INI} ]; then
		$CP ${ENIQ_TEMPL_DIR}/${SENTINEL_INI} ${ENIQ_CONF_DIR}
		if [ $? -ne 0 ]; then
			_err_msg_="Failed to copy ${ENIQ_TEMPL_DIR}/${SENTINEL_INI} to ${ENIQ_CONF_DIR}"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi

		$CHMOD 644 ${ENIQ_CONF_DIR}/${SENTINEL_INI}
		if [ $? -ne 0 ]; then
			_err_msg_="Failed to change permissions of ${ENIQ_CONF_DIR}/${SENTINEL_INI} to -rw-r--r--"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	else
		_err_msg_="${ENIQ_TEMPL_DIR}/${SENTINEL_INI} does not exist or is empty"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi
}

### Function: update_reader_info ###
#
# Update dwh.ini with reader info
#
# Arguments:
#	   none
# Return Values:
#	   none
update_reader_info()
{
if [ ! -s ${SCRIPTHOME}/update_iq_mem_settings.bsh ]; then
	_err_msg_="${SCRIPTHOME}/update_iq_mem_settings.bsh could not be found"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_stored_reader_name_=`$CAT ${ENIQ_CONF_DIR}/.reader_info | $AWK -F"::" '{print $1}'`
_stored_reader_ip_=`$CAT ${ENIQ_CONF_DIR}/.reader_info | $AWK -F"::" '{print $2}'`
_stored_reader_num_=`$ECHO ${_stored_reader_name_} | $AWK -F\_ '{print $NF}'`
if [ ! "${_stored_reader_name_}" -o ! "${_stored_reader_ip_}" -o ! "${_stored_reader_num_}" ]; then
	_err_msg_="Could not read values from ${ENIQ_CONF_DIR}/.reader_info"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Get the System User/Group. All directories are owned by this
_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
	_err_msg_="Could not read parameter ENIQ_SYSUSER from file ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_sysgrp_=`$ID ${_sysuser_} | $AWK '{print $2}' | $AWK -F\( '{print $2}' | $AWK -F\) '{print $1}'`
if [ ! "${_sysgrp_}" ]; then
	_err_msg_="Could not determine group ID of ${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

$CP ${CLI_CONF_DIR}/${ENIQ_INI} ${TEM_DIR}/${ENIQ_INI}
if [ $? -ne 0 ]; then
	_err_msg_="Could not copy ${CLI_CONF_DIR}/${ENIQ_INI} to ${TEM_DIR}/${ENIQ_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Get a list of readers already in ini
_reader_list_=`iniget DWH_READER -f ${TEM_DIR}/${ENIQ_INI}`
if [ "${_reader_list_}" ]; then
	for _reader_ in ${_reader_list_}; do
		$RM -rf ${TEM_DIR}/${ENIQ_INI}_upd

		_rdr_serv_name_=`iniget ${_reader_} -f ${TEM_DIR}/${ENIQ_INI} -v Service_Name`
		_rdr_ip_=`iniget ${_reader_} -f ${TEM_DIR}/${ENIQ_INI} -v Reader_IP`

		# If the entered reader info is already in the ini file,
		# then we need to remove the existing entry
		if [ "${_rdr_serv_name_}" == "${_stored_reader_name_}" -a "${_rdr_ip_}" == "${_stored_reader_ip_}" ]; then
			log_msg -s "Removing current instance of ${_reader_}" -l ${LOGFILE}
			$INIDEL -g DWH_READER -p ${_reader_} -i ${TEM_DIR}/${ENIQ_INI} -o ${TEM_DIR}/${ENIQ_INI}_upd
			if [ $? -ne 0 ]; then
				_err_msg_="Error removing ${_reader_} from ${TEM_DIR}/${ENIQ_INI}"
				abort_script "${_err_msg_}"
			fi

			$CP ${TEM_DIR}/${ENIQ_INI}_upd ${TEM_DIR}/${ENIQ_INI}
			if [ $? -ne 0 ]; then
				_err_msg_="Could not copy ${TEM_DIR}/${ENIQ_INI}_upd to ${TEM_DIR}/${ENIQ_INI}"
				abort_script "${_err_msg_}"
			fi
		fi
	done
fi

$RM -rf ${TEM_DIR}/inst_det ${TEM_DIR}/${ENIQ_INI}_tmp

_nxt_num_=${_stored_reader_num_}

$ECHO "[DWH_READER_${_nxt_num_}]
Service_Name=${_stored_reader_name_}
Reader_IP=${_stored_reader_ip_}
MainCache=
TempCache=
LargeMemory=
CatalogCache=\n" > ${TEM_DIR}/inst_det

$INIADD -g DWH_READER -p DWH_READER_${_nxt_num_} -i ${TEM_DIR}/${ENIQ_INI} -d ${TEM_DIR}/inst_det -o ${TEM_DIR}/${ENIQ_INI}_tmp
if [ $? -ne 0 ]; then
	_err_msg_="Error adding DWH_READER_${_nxt_num_} to ${TEM_DIR}/${ENIQ_INI}"
	abort_script "${_err_msg_}"
fi

$CP ${TEM_DIR}/${ENIQ_INI}_tmp ${TEM_DIR}/${ENIQ_INI}
if [ $? -ne 0 ]; then
	_err_msg_="Could not update ${TEM_DIR}/${ENIQ_INI}"
	abort_script "${_err_msg_}"
fi

log_msg -s "Updating memory cache values for DWH_READER_${_nxt_num_}" -q -l ${LOGFILE}
log_msg -s "${BASH} ${SCRIPTHOME}/update_iq_mem_settings.bsh -d ${TEM_DIR} -p DWH_READER_${_nxt_num_} -r ${_stored_reader_name_} -l ${LOGFILE} -N" -q -l ${LOGFILE}
${BASH} ${SCRIPTHOME}/update_iq_mem_settings.bsh -d ${TEM_DIR} -p DWH_READER_${_nxt_num_} -r ${_stored_reader_name_} -l ${LOGFILE} -N
if [ $? -ne 0 ]; then
	_err_msg_="Error running ${SCRIPTHOME}/update_iq_mem_settings.bsh"
	abort_script "${_err_msg_}"
fi

$CP ${TEM_DIR}/${ENIQ_INI} ${CLI_CONF_DIR}/${ENIQ_INI}
if [ $? -ne 0 ]; then
	_err_msg_="Could not update ${CLI_CONF_DIR}/${ENIQ_INI}"
	abort_script "${_err_msg_}"
fi

$CP ${CLI_CONF_DIR}/${ENIQ_INI} ${ENIQ_CONF_DIR}/${ENIQ_INI}
if [ $? -ne 0 ]; then
	_err_msg_="Could not copy ${CLI_CONF_DIR}/${ENIQ_INI} to ${ENIQ_CONF_DIR}/${ENIQ_INI}"
	abort_script "${_err_msg_}"
fi

# Update the service_names file with the licence service
log_msg -s "Updating ${CLI_CONF_DIR}/service_names with ${_stored_reader_name_} information" -q -l ${LOGFILE}
update_service_file ${CLI_CONF_DIR}/service_names ${_stored_reader_ip_} ${HNAME} ${_stored_reader_name_} "NULL_GRP"
if [ $? -ne 0 ]; then
	_err_msg_="Failed to update ${CLI_CONF_DIR}/service_names with ${_stored_reader_name_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

log_msg -s "Changing ownership of ${CLI_CONF_DIR}/service_names to ${_sysuser_}:${_sysgrp_} after updates for ${_stored_reader_name_}" -q -l ${LOGFILE}
$CHOWN ${_sysuser_}:${_sysgrp_} ${CLI_CONF_DIR}/service_names
if [ $? -ne 0 ]; then
	_err_msg_="Failed to change ownership of ${CLI_CONF_DIR}/service_names to ${_sysuser_}:${_sysgrp_}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
}

### Function: update_system_file ###
#
# Updates set core memory
#
# Arguments:
#   none
# Return Values:
#   none
update_system_file()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

if [ ! -s ${SCRIPTHOME}/set_core_memcache.bsh ]; then
	_err_msg_="Failed to locate script ${SCRIPTHOME}/set_core_memcache.bsh"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

######## Need to merge set_core_memcache.bsh
$ECHO "Updating system setting with command:" >> ${LOGFILE}
$ECHO "${BASH} ${SCRIPTHOME}/set_core_memcache.bsh -d ${ENIQ_CONF_DIR} -m -f -z -l ${LOGFILE}" >> ${LOGFILE}
${BASH} ${SCRIPTHOME}/set_core_memcache.bsh -d ${ENIQ_CONF_DIR} -m -f -z -l ${LOGFILE}
if [ $? -ne 0 ]; then
	abort_script "Exiting...." "${EXEC_SHELL_CMD}"
fi

insert_header_footer foot "Successfully completed core install stage - ${NEXT_STAGE}" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: update_sysuser_file ###
#
# Update the SYSTEM USER profile file
#
# Arguments:
#   none
# Return Values:
#   none
update_sysuser_file()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

_update_=0

# Read the storage type
read_storage_type

_asa_tgt_dir_=`iniget SYBASE_ASA -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v SYBASE_ASA_TARGET_DIR`
_bin_dir_=`$CAT ${ENIQ_CONF_DIR}/${ENIQ_ENV} | $EGREP '^[[:blank:]]*BIN_DIR=' | $AWK -F\= '{print $2}'`
_cli_conf_dir_=`$CAT ${ENIQ_CONF_DIR}/${ENIQ_ENV} | $EGREP "^[[:blank:]]*CONF_DIR=" | $AWK -F\= '{print $2}' | $SED -e 's|"||g'`
_iq_dir_=`iniget SYBASE_IQ -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v SYBASE_IQ_TARGET_DIR`
_rt_dir_=`$CAT ${ENIQ_CONF_DIR}/${ENIQ_ENV} | $EGREP '^[[:blank:]]*RT_DIR=' | $AWK -F\= '{print $2}'`

# Check the home area ismounted for raw storage
if [ "${STORAGE_TYPE}" == "raw" ]; then
	_mount_exists_=`$MOUNT | $GREP "${ENIQ_BASE_DIR}/home" | $AWK '{print $1}'`
	if [ ! "${_mount_exists_}" ]; then
		_err_msg_="${ENIQ_BASE_DIR}/home not mounted during $NEXT_STAGE"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

# Set the system architecture
local _arch_=`$UNAME -p`

# Get a list of users to be updated
_user_list_=`iniget SunOS_USER -f ${ENIQ_CONF_DIR}/${SUNOS_INI}`
for _user_ in ${_user_list_}; do
	_user_name_=`iniget ${_user_} -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v name`
	$GETENT passwd ${_user_name_} >> /dev/null 2>&1
	if [ $? -ne 0 ]; then
		_err_msg_="User ${_user_name_} not created"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	local _sys_home_=`$GETENT passwd ${_user_name_} | $AWK -F\: '{print $6}'`
	if [ ! "${_sys_home_}" ]; then
		_err_msg_="Error reading ${_user_name_} home area from /etc/passwd"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	if [ ! -d "${_sys_home_}" ]; then
		_err_msg_="${_sys_home_} is not a directory"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	if [ -f ${ENIQ_TEMPL_DIR}/${_arch_}/skel_dir/.bash_profile ]; then
		$CAT ${ENIQ_TEMPL_DIR}/${_arch_}/skel_dir/.bash_profile | $SED -e "s|<CHANGE><IQ_SYB_DIR>|${_iq_dir_}|g"	 \
			-e "s|<CHANGE><ASA_SYB_DIR>|${_asa_tgt_dir_}|g"							  \
			-e "s|<CHANGE><CONF_DIR>|${_cli_conf_dir_}|g"								\
			-e "s|<CHANGE><BIN_DIR>|${_bin_dir_}|g"									  \
			-e "s|<CHANGE><RT_DIR>|${_rt_dir_}|g" > ${TEM_DIR}/bash_profile

		$CP ${TEM_DIR}/bash_profile ${_sys_home_}/.bash_profile
		if [ $? -ne 0 ]; then
			_err_msg_="Error executing: $CP ${TEM_DIR}/profile ${_sys_home_}/.bash_profile "
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
		
		if [ -L ${_sys_home_}/.profile ]; then
			$RM -rf ${_sys_home_}/.profile
			if [ $? -ne 0 ]; then
			   _err_msg_="Could not remove .profile symbolic link"
			   abort_script "${_err_msg_}" 
			fi
		fi
		
		$LN -s ${_sys_home_}/.bash_profile ${_sys_home_}/.profile
		if [ $? -ne 0 ]; then
			_err_msg_="Error executing: $LN -s ${_sys_home_}/.bash_profile ${_sys_home_}/.profile "
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi	   
		_update_=1
	fi
done

if [ ${_update_} -eq 1 ]; then
	insert_header_footer foot "Successfully updated home areas and profiles" ${LOGFILE}
else
	insert_header_footer foot "Successfully completed core install stage - ${NEXT_STAGE}" ${LOGFILE}
fi

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: update_timezone_info ###
#
# Updates TIMEZONE information
#
# Arguments:
#   none
# Return Values:
#   none
update_timezone_info()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

_update_=1
# Set up the timezone if necessary
# Get the System User/Group. All filesystems are owned by this
_timezone_=`iniget SunOS_MISC -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v TIMEZONE`
if [ ! "${_timezone_}" ]; then
	_err_msg_="Could not read timezone information from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

timedatectl set-timezone ${_timezone_} >> /dev/null 2>&1
if [ $? -eq 0 ]; then
	_update_=1
fi


if [ ${_update_} -eq 1 ]; then
	insert_header_footer foot "Successfully updated Timezone Information" ${LOGFILE}
	REBOOT_FLAG=1
else
	insert_header_footer foot "Successfully completed core install stage - ${NEXT_STAGE}" ${LOGFILE}
fi

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: validate_SMF_contracts ###
#
# Validate the SMF scripts and
#
# Arguments:
#   none
# Return Values:
#   none
validate_SMF_contracts()
{
insert_header_footer head "Entering core install stage - ${NEXT_STAGE}" ${LOGFILE}

SVC_CONTRACT_INFO=$ENIQ_ADMIN_DIR/etc/smf_contract_config
if [ ! -s ${SVC_CONTRACT_INFO} ]; then
	_err_msg_="Could not find ${SVC_CONTRACT_INFO} file, or it is empty"
	abort_script "${_err_msg_}"
fi

get_all_services

# Validate the Service files
for _svc_ in ${_service_list_}; do
	log_msg -s "Validating eniq-${_svc_}.service" -l ${LOGFILE}
	$SYSTEMD_ANALYZE verify eniq-${_svc_}.service >> /dev/null 2>&1
	if [ $? -ne 0 ]; then
		_err_msg_="Error validating Service file eniq-${_svc_}.service"
		abort_script "${_err_msg_}"
	fi
done
log_msg -s "Loading new unit into Service" -l ${LOGFILE}
${SYSTEMCTL} daemon-reload
if [ $? -ne 0 ]; then
	_err_msg_="Error Loading new unit files."
	abort_script "${_err_msg_}"
fi

# Enabling the Services	
for _svc_ in ${_service_list_}; do
	${SYSTEMCTL} enable eniq-${_svc_}.service >> /dev/null 2>&1
	local _service_state=`${SYSTEMCTL} is-enabled eniq-${_svc_}.service | $AWK '{print $1}'`
	if [ "${_service_state}" != "enabled" ] ; then
		_err_msg_="Error enabling the eniq-${_svc_}.service"
		abort_script "${_err_msg_}"
	fi
done

# Stop the loaded ENIQ services 
if [ "${UPGRADE}" ]; then
	for _svc_ in ${_service_list_}; do
		$ECHO "Stopping eniq-${_svc_}.service\n" | $TEE -a ${LOGFILE}
		${SYSTEMCTL} stop eniq-${_svc_}.service >> /dev/null 2>&1
		_service_state=`${SYSTEMCTL} show eniq-${_svc_}.service -p ActiveState | $AWK -F= '{print $2}'`
		if [ "${_service_state}" == "failed" ]; then
			log_msg -s "Clearing the failed state for ${_service_state}" -l ${LOGFILE}
			${SYSTEMCTL} reset-failed eniq-${_svc_}.service >> /dev/null 2>&1
		fi
		${SYSTEMCTL} disable eniq-${_svc_}.service >> /dev/null 2>&1
		local _service_state=`${SYSTEMCTL} is-enabled eniq-${_svc_}.service | $AWK '{print $1}'`
		if [ "${_service_state}" != "disabled" ] ; then
			_err_msg_="Error disabling the eniq-${_svc_}.service"
			abort_script "${_err_msg_}"
		fi
	done
fi

insert_header_footer foot "Successfully validated SMF manifest files" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

# ********************************************************************
#
#   Main body of program
#
# ********************************************************************
#
RUN_TIME=`$DATE '+%Y-%b-%d_%H.%M.%S'`

# Determine absolute path to software
get_absolute_path

# Check that the effective id of the user is root
check_id $DEFAULT_USER

while getopts ":b:d:l:no:MRus:t:" arg; do
  case $arg in
	b) ENIQ_BASE_DIR="$OPTARG"
	   ;;
	d) BASE_SW_DIR="$OPTARG"
	   ;;
	l) LOGFILE="$OPTARG"
	   ;;
	M) MIGRATION="YES"
	   ;;
	n) NO_RESET_STAGE="YES"
	   ;;
	o) OM_SW_DIR="$OPTARG"
	   ;;
	R) RESTORE="YES"
	   ;;
	s) USER_STAGE="$OPTARG"
	   ;;
	t) STORAGE_TYPE="$OPTARG"
	   ;;
	u) UPGRADE="YES"
	   ;;
   \?) _err_msg_="`$BASENAME $0` -s <stage>"
	   abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	   ;;
  esac
done
shift `expr $OPTIND - 1`

# Set up environment variables for script.
setup_env

# Log file
if [ ! "${LOGFILE}" ]; then
	$MKDIR -p ${ENIQ_LOG_DIR}/installation
	LOGFILE="${ENIQ_LOG_DIR}/installation/${HNAME}_install.log"
fi

PATCH_LOG="${ENIQ_LOG_DIR}/installation/${HNAME}_solaris_patching.log"

$ECHO -e "\n=======================================================" >> ${LOGFILE}
$ECHO "${RUN_TIME} - Entering Core Installation" >> ${LOGFILE}
$ECHO -e "=======================================================\n" >> ${LOGFILE}

# Create a temporary Directory
TEM_DIR=/tmp/core_installation.$$.$$
$RM -rf ${TEM_DIR}
$MKDIR -p ${TEM_DIR}
if [ $? -ne 0 ]; then
	_err_msg_="Could not create directory $TEM_DIR"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Check that I have a templates directory
# associated with my installation type
core_install_check_templates_dir ${LOGFILE} ${TEM_DIR} ${ENIQ_TEMPL_DIR}
if [ $? -ne 0 ]; then
	_err_msg_="Could not determine if ${ENIQ_TEMPL_DIR} is valid"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# Check that the vold daemon is running
#core_install_check_vold ${LOGFILE} ${TEM_DIR}

# Update files with root dir
$RM -rf ${TEM_DIR}/etc_file_updates.$$
for _file_ in `$LS ${ENIQ_CORE_INST_DIR}/etc`; do
	$CAT ${ENIQ_CORE_INST_DIR}/etc/${_file_} | $SED -e "s|<CHANGE><ENIQ_BASE_DIR>|${ENIQ_BASE_DIR}|g" > ${TEM_DIR}/etc_file_updates.$$
	$CP ${TEM_DIR}/etc_file_updates.$$ ${ENIQ_CORE_INST_DIR}/etc/${_file_}
	if [ $? -ne 0 ]; then
		_err_msg_="Could not copy ${TEM_DIR}/etc_file_updates.$$ to ${_file_}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
done

# Flag to determine if I need to give a reboot
REBOOT_FLAG=0

# Get server type
	if [ ! -s $ENIQ_CONF_DIR/installed_server_type ]; then
		core_install_get_server_type ${LOGFILE} ${TEM_DIR} ${SERVER_TYPE_LIST_FILE} ${ENIQ_CONF_DIR}
		if [ $? -ne 0 ]; then
			_err_msg_="Could not determine the type of install profile to use"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi

# Set a variable to be used from now on that will guide the install flow
# so as it will install the relevant pieces, based on the install type (writer/reader/mediation/coordinator/etc)
CURR_SERVER_TYPE=`$CAT $ENIQ_CONF_DIR/installed_server_type | $EGREP -v  '^[[:blank:]]*#' | $SED -e 's/ //g'`
if [ ! "${CURR_SERVER_TYPE}" ]; then
	_err_msg_="Could not determine which server type this is"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ "${CURR_SERVER_TYPE}" == "eniq_coordinator" -o "${CURR_SERVER_TYPE}" == "stats_coordinator"   \
	 -o "${CURR_SERVER_TYPE}" == "eniq_stats" -o "${CURR_SERVER_TYPE}" == "eniq_iqw"  ]; then
	SERVER_TYPE="CO"
else
	SERVER_TYPE="${CURR_SERVER_TYPE}"
fi

# Create a stage array
core_install_build_stage_array ${LOGFILE} ${TEM_DIR} ${INSTALL_TYPE} ${CURR_SERVER_TYPE} ${ENIQ_CORE_INST_DIR}
if [ $? -ne 0 ]; then
	_err_msg_="Could not build a stage array for ${CURR_SERVER_TYPE}"
	abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

# If stage specified, make sure it is in the stage list for this server type
if [ "$USER_STAGE" ]; then
	core_install_check_user_stage ${LOGFILE} ${TEM_DIR} ${USER_STAGE}
	if [ $? -ne 0 ]; then
	   _err_msg_="The specified stage ${USER_STAGE} is not in the stage list for ${CURR_SERVER_TYPE}"
	   abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi
fi

if [ "$USER_STAGE" ]; then
	NEXT_STAGE="${USER_STAGE}"
	# Get the element number so we can move along the array
	get_array_element
else
	get_next_stage
fi

# If we read cleanup from the stagefile
if [ "$NEXT_STAGE" == "cleanup" ]; then
	# We exit unless the user specified that the stage be run again
	if [ ! "$USER_STAGE" ]; then
		$ECHO "All Stages are already completed"
		exit 0
	fi
fi

# Has the installation to stop at any specific stage?
if [ -s ${ENIQ_CONF_DIR}/extra_params/stop_stage ]; then
	_stop_stage_=`$CAT ${ENIQ_CONF_DIR}/extra_params/stop_stage`
	$ECHO ${ENIQ_CORE_STAGES[*]} | $GREP -w ${_stop_stage_} >> /dev/null 2>&1
	if [ $? -eq 0 ]; then
		$ECHO "User defined stop stage - Installation will stop at stage ${_stop_stage_} "
	else
		$ECHO "User defined stop stage - ${_stop_stage_} not valid.....Ignoring"
		unset _stop_stage_
		$RM -f ${ENIQ_CONF_DIR}/extra_params/stop_stage
	fi
fi

# Only check the milestone if this is being run
# outside of a restore situation, and on raw FS
_check_nasd_=0
if [ "${UPGRADE}" ]; then
	if [ ! "${STORAGE_TYPE}" ]; then
		read_storage_type
	fi

	if [ "${STORAGE_TYPE}" == "fs" ]; then
		_check_nasd_=1
	fi
fi

if [ "${RESTORE}" ]; then
	_check_nasd_=1
fi

if [ -s ${ENIQ_CONF_DIR}/${SUNOS_INI} ]; then
	if [ ${_check_nasd_} -eq 0 ]; then
		# Check that NASD milestone is online
		check_nasd_milestone_online ${ENIQ_CONF_DIR} ${SUNOS_INI} ${ENIQ_BASE_DIR}
		if [ $? -ne 0 ]; then
			_err_msg_="NASd not in a correct state to continue"
			abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
		fi
	fi
fi

# Loop through the stages for installation
while :; do
	_nxt_stage_="${NEXT_STAGE}"
	$_nxt_stage_
	if [ $? -ne 0 ]; then
		_err_msg_="Error in Stage ${NEXT_STAGE}"
		abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
	fi

	# Exit if the user specified to run a specific stage only
	if [ "$USER_STAGE" ]; then
		break
	fi

	# If we read cleanup from the stagefile
	if [ "$NEXT_STAGE" == "cleanup" ]; then
		break
	fi

	# Exit if the user specified to run a stop at a certain stage only
	if [ "${_stop_stage_}" ]; then
		# Exit if the user specified to run a stop at a certain stage only
		if [ "${NEXT_STAGE}" == "${_stop_stage_}" ]; then
			$ECHO -e "\n\nStopping after stage ${NEXT_STAGE} at user request"
			$RM -f ${ENIQ_CONF_DIR}/extra_params/stop_stage
			break
		fi
	fi

	get_next_stage
done

$RM -rf ${TEM_DIR}

exit 0
